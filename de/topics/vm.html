<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Compiler und virtuelle Maschine </a></li><li><a href="/de/topics/vm.html" aria-current="page" class="active sidebar-link">Compiler und virtuelle Maschine </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/de/topics/vm.html#source-code-storage-and-compilation" class="sidebar-link">Speicherung und Kompilierung des Quellcodes </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#virtual-machine-structures" class="sidebar-link">Strukturen virtueller Maschinen </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/de/topics/vm.html#vm-structure" class="sidebar-link">VM-Struktur </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#block-structure" class="sidebar-link">Blockstruktur </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#objinfo-structure" class="sidebar-link">ObjInfo-Struktur </a></li></ul></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#virtual-machine-commands" class="sidebar-link">Befehle für virtuelle Maschinen </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/de/topics/vm.html#bytecode-structure" class="sidebar-link">ByteCode-Struktur </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#command-identifiers" class="sidebar-link">Befehlskennungen </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#stack-operation-commands" class="sidebar-link">Stack-Operationsbefehle </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#runtime-structure" class="sidebar-link">Laufzeitstruktur </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#runcode-function" class="sidebar-link">RunCode-Funktion </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#other-functions-for-operations-with-vm" class="sidebar-link">Weitere Funktionen für Operationen mit VM </a></li></ul></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#compiler" class="sidebar-link">Compiler </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#lexical-analyzer" class="sidebar-link">Lexikalischer Analysator </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/de/topics/vm.html#lextable-lextable-go" class="sidebar-link">lextable/lextable.go </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#lex-go" class="sidebar-link">lex.go </a></li></ul></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#needle-language" class="sidebar-link">Needle Sprache </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/de/topics/vm.html#lexemes" class="sidebar-link">Lexemes </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#types" class="sidebar-link">Typen </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#expressions" class="sidebar-link">Ausdrücke </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#scope" class="sidebar-link">Zielfernrohr </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#contract-execution" class="sidebar-link">Vertragsabwicklung </a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#backus-naur-form-bnf" class="sidebar-link">Backus–Naur Form (BNF) </a></li></ul></li></ul></li><li><a href="/de/topics/script.html" class="sidebar-link">Intelligente Verträge </a></li><li><a href="/de/topics/daemons.html" class="sidebar-link">Dämon </a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="compiler-and-virtual-machine"><a href="#compiler-and-virtual-machine" class="header-anchor">#</a> Compiler und virtuelle Maschine </h1> <ul><li><a href="#source-code-storage-and-compilation">Speicherung und Kompilierung des Quellcodes</a></li> <li><a href="#virtual-machine-structures">Strukturen virtueller Maschinen</a> <ul><li><a href="#vm-structure">VM-Struktur</a></li> <li><a href="#block-structure">Blockstruktur</a></li> <li><a href="#objinfo-structure">ObjInfo-Struktur</a> <ul><li><a href="#contractinfo-structure">ContractInfo-Struktur</a></li> <li><a href="#fieldinfo-structure">FieldInfo-Struktur</a></li> <li><a href="#funcinfo-structure">FuncInfo-Struktur</a></li> <li><a href="#funcname-structure">Funktionsname-Struktur</a></li> <li><a href="#extfuncinfo-structure">ExtFuncInfo-Struktur</a></li> <li><a href="#varinfo-structure">VarInfo-Struktur</a></li> <li><a href="#objextend-value">ObjExtend-Wert</a></li></ul></li></ul></li> <li><a href="#virtual-machine-commands">Befehle für virtuelle Maschinen</a> <ul><li><a href="#bytecode-structure">ByteCode-Struktur</a></li> <li><a href="#command-identifiers">Befehlskennungen</a></li> <li><a href="#stack-operation-commands">Befehle für Stapeloperationen</a></li> <li><a href="#runtime-structure">Laufzeitstruktur</a> <ul><li><a href="#blockstack-structure">blockStack-Struktur</a></li></ul></li> <li>[RunCode-Funktion] (#runcode-function)</li> <li><a href="#other-functions-for-operations-with-vm">Andere Funktionen für Operationen mit VM</a></li></ul></li> <li><a href="#compiler">Compiler</a></li> <li><a href="#lexical-analyzer">Lexikalanalyse</a> <ul><li><a href="#lextable-lextable-go">lextable/lextable.go</a></li> <li><a href="#lex-go">lex.go</a></li></ul></li> <li><a href="#needle-language">Nadelsprache</a> <ul><li><a href="#lexemes">Lexeme</a></li> <li><a href="#types">Typen</a></li> <li><a href="#expressions">Ausdrücke</a></li> <li><a href="#scope">Bereich</a></li> <li><a href="#contract-execution">Vertragsausführung</a></li> <li><a href="#backus-naur-form-bnf">Backus-Naur-Form (BNF)</a></li></ul></li></ul> <p>Dieser Abschnitt umfasst Programmkompilierung und Needle-Language-Operationen in der virtuellen Maschine (VM).</p> <h2 id="source-code-storage-and-compilation"><a href="#source-code-storage-and-compilation" class="header-anchor">#</a> Speicherung und Kompilierung des Quellcodes </h2> <p>Verträge und Funktionen werden mit Golang geschrieben und in den Vertragstabellen von Ökosystemen gespeichert.</p> <p>Wenn ein Vertrag ausgeführt wird, wird sein Quellcode aus der Datenbank gelesen und in Bytecode kompiliert.</p> <p>Wenn ein Vertrag geändert wird, wird sein Quellcode aktualisiert und in der Datenbank gespeichert. Dann wird der Quellcode kompiliert, wodurch der Bytecode in der entsprechenden virtuellen Maschine aktualisiert wird.</p> <p>Da Bytecodes nicht physikalisch gespeichert werden, werden sie bei einer erneuten Programmausführung neu kompiliert.</p> <p>Der gesamte in der Vertragstabelle jedes Ökosystems beschriebene Quellcode wird in einer strengen Reihenfolge in eine virtuelle Maschine kompiliert, und der Status der virtuellen Maschine ist auf allen Knoten gleich.</p> <p>Beim Vertragsaufruf ändert die virtuelle Maschine ihren Status in keiner Weise. Die Ausführung eines Vertrages oder das Aufrufen einer Funktion erfolgt auf einem separaten laufenden Stack, der während jedes externen Aufrufs erstellt wird.</p> <p>Jedes Ökosystem kann ein sogenanntes virtuelles Ökosystem haben, das innerhalb eines Knotens in Verbindung mit Tabellen außerhalb der Blockchain verwendet werden kann, ohne direkten Einfluss auf die Blockchain oder andere virtuelle Ökosysteme. In diesem Fall erstellt der Knoten, der ein solches virtuelles Ökosystem hostet, seinen Vertrag und erstellt seine eigene virtuelle Maschine.</p> <h2 id="virtual-machine-structures"><a href="#virtual-machine-structures" class="header-anchor">#</a> Strukturen virtueller Maschinen </h2> <h3 id="vm-structure"><a href="#vm-structure" class="header-anchor">#</a> VM-Struktur </h3> <p>Eine virtuelle Maschine ist im Arbeitsspeicher als Struktur wie unten organisiert.</p> <div class="language- extra-class"><pre class="language-text"><code>type VM struct {
   Block
   ExtCost func(string) int64
   FuncCallsDB map[string]struct{}
   Extern bool
   ShiftContract int64
   logger *log.Entry
}
</code></pre></div><p>Eine VM-Struktur hat die folgenden Elemente:</p> <ul><li>Block - enthält eine [Blockstruktur] (#block-structure);</li> <li>ExtCost - eine Funktion gibt die Kosten für die Ausführung einer externen Golang-Funktion zurück;</li> <li>FuncCallsDB - eine Sammlung von Golang-Funktionsnamen. Diese Funktion gibt die Ausführungskosten als ersten Parameter zurück. Diese Funktionen verwenden EXPLAIN, um die Kosten der Datenbankverarbeitung zu berechnen;</li> <li>Extern – ein Boolesches Flag, das angibt, ob ein Vertrag ein externer Vertrag ist. Es wird auf „true“ gesetzt, wenn eine VM erstellt wird. Aufgerufene Verträge werden beim Kompilieren des Codes nicht angezeigt. Mit anderen Worten, es ermöglicht, den in Zukunft festgelegten Vertragscode aufzurufen;</li> <li>Schichtvertrag – ID des ersten Vertrags in der VM;</li> <li>logger - Ausgabe des VM-Fehlerprotokolls.</li></ul> <h3 id="block-structure"><a href="#block-structure" class="header-anchor">#</a> Blockstruktur </h3> <p>Eine virtuelle Maschine ist ein Baum, der aus <strong>Blocktyp</strong>-Objekten besteht.</p> <p>Ein Block ist eine unabhängige Einheit, die einige Bytecodes enthält. Einfach ausgedrückt ist alles, was Sie in der Sprache in die geschweiften Klammern (<code>{}</code>) setzen, ein Block.</p> <p>Der folgende Code würde beispielsweise einen Block mit Funktionen erstellen. Dieser Block enthält auch einen weiteren Block mit einer if-Anweisung, der wiederum einen Block mit einer while-Anweisung enthält.</p> <div class="language- extra-class"><pre class="language-text"><code>func my() {
   if true {
      while false {
      ...
      }
   }
}
</code></pre></div><p>Der Block ist im Speicher als Struktur wie unten organisiert.</p> <div class="language- extra-class"><pre class="language-text"><code>type Block struct {
   Objects map[string]*ObjInfo
   Type int
   Owner *OwnerInfo
   Info interface{}
   Parent *Block
   Vars []reflect.Type
   Code ByteCodes
   Children Blocks
}
</code></pre></div><p>Eine Blockstruktur besteht aus folgenden Elementen:</p> <ul><li><strong>Objekte</strong> - eine Abbildung interner Objekte des Zeigertyps <a href="#objInfo-Struktur">ObjInfo</a>. Wenn der Block beispielsweise eine Variable enthält, können Sie anhand ihres Namens Informationen darüber erhalten.</li> <li><strong>Typ</strong> - der Typ des Blocks. Bei einem Funktionsblock ist sein Typ <strong>ObjFunc</strong>; für einen Vertragsblock ist sein Typ <strong>ObjContract</strong>;</li> <li><strong>Eigentümer</strong> – eine Struktur vom Zeigertyp <strong>Eigentümerinfo</strong>. Diese Struktur enthält Informationen über den Eigentümer des kompilierten Vertrags, der während der Vertragserstellung angegeben oder aus der Tabelle <strong>Verträge</strong> erhalten wird;</li> <li><strong>Info</strong> - enthält Informationen über das Objekt, die vom Blocktyp abhängen;</li> <li><strong>Parent</strong> – ein Zeiger auf den Elternblock;</li> <li><strong>Vars</strong> - ein Array, das die Typen der aktuellen Blockvariablen enthält;</li> <li><strong>Code</strong> - der Bytecode des Blocks selbst, der ausgeführt wird, wenn die Kontrollrechte an den Block übergeben werden, zum Beispiel Funktionsaufrufe oder Schleifenkörper;</li> <li><strong>Children</strong> - ein Array mit Unterblöcken, wie z. B. Funktionsverschachtelung, Schleifen, bedingte Operatoren.</li></ul> <h3 id="objinfo-structure"><a href="#objinfo-structure" class="header-anchor">#</a> ObjInfo-Struktur </h3> <p>Die ObjInfo-Struktur enthält Informationen über interne Objekte.</p> <div class="language- extra-class"><pre class="language-text"><code>type ObjInfo struct {
   Type int
   Value interface{}
}
</code></pre></div><p>Die ObjInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Typ</strong> ist der Objekttyp, der einen der folgenden Werte hat:
<ul><li><strong>ObjContract</strong> – <a href="#contractInfo-Struktur">Vertrag</a>;</li> <li><strong>ObjFunc</strong> - Funktion;</li> <li><strong>ObjExtFunc</strong> - externe Golang-Funktion;</li> <li><strong>ObjVar</strong> - Variable;</li> <li><strong>ObjExtend</strong> - $name-Variable.</li></ul></li> <li><strong>Wert</strong> – enthält die Struktur jedes Typs.</li></ul> <h4 id="contractinfo-structure"><a href="#contractinfo-structure" class="header-anchor">#</a> ContractInfo-Struktur </h4> <p>Zeigt auf den Typ <strong>ObjContract</strong>, und das Feld <strong>Value</strong> enthält eine <strong>ContractInfo</strong>-Struktur.</p> <div class="language- extra-class"><pre class="language-text"><code>type ContractInfo struct {
   ID uint32
   Name string
   Owner *OwnerInfo
   Used map[string]bool
   Tx *[]*FieldInfo
}
</code></pre></div><p>Die ContractInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>ID</strong> - Vertrags-ID, die beim Aufruf des Vertrags in der Blockchain angezeigt wird;</li> <li><strong>Name</strong> - Vertragsname;</li> <li><strong>Eigentümer</strong> - andere Informationen zum Vertrag;</li> <li><strong>Verwendet</strong> - Karte der aufgerufenen Vertragsnamen;</li> <li><strong>Tx</strong> – ein Datenarray, das im <a href="/de/topics/script.html#data-section">Datenabschnitt</a> des Vertrags beschrieben wird.</li></ul> <h4 id="fieldinfo-structure"><a href="#fieldinfo-structure" class="header-anchor">#</a> FieldInfo-Struktur </h4> <p>Die FieldInfo-Struktur wird in der <strong>ContractInfo</strong>-Struktur verwendet und beschreibt Elemente im <a href="/de/topics/script.html#data-section">Datenabschnitt</a> eines Vertrags.</p> <div class="language- extra-class"><pre class="language-text"><code>type FieldInfo struct {
   Name string
   Type reflect.Type
   Original uint32
   Tags string
}
</code></pre></div><p>Die FieldInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Name</strong> - Feldname;</li> <li><strong>Typ</strong> - Feldtyp;</li> <li><strong>Original</strong> - optionales Feld;</li> <li><strong>Tags</strong> - zusätzliche Beschriftungen für dieses Feld.</li></ul> <h4 id="funcinfo-structure"><a href="#funcinfo-structure" class="header-anchor">#</a> FuncInfo-Struktur </h4> <p>Zeigt auf den ObjFunc-Typ, und das Value-Feld enthält eine FuncInfo-Struktur.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncInfo struct {
   Params []reflect.Type
   Results []reflect.Type
   Names *map[string]FuncName
   Variadic bool
   ID uint32
}
</code></pre></div><p>Die FuncInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Params</strong> - ein Array von Parametertypen;</li> <li><strong>Ergebnisse</strong> - ein Array zurückgegebener Typen;</li> <li><strong>Namen</strong> - Abbildung von Daten für Tail-Funktionen, zum Beispiel <code>DBFind().Columns ()</code>;</li> <li><strong>Variadic</strong> - wahr, wenn die Funktion eine variable Anzahl von Parametern haben kann;</li> <li><strong>ID</strong> - Funktions-ID.</li></ul> <h4 id="funcname-structure"><a href="#funcname-structure" class="header-anchor">#</a> FuncName-Struktur </h4> <p>Die Struktur FuncName wird für FuncInfo verwendet und beschreibt die Daten einer Tail-Funktion.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
</code></pre></div><p>Die FuncName-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Params</strong> - ein Array von Parametertypen;</li> <li><strong>Offset</strong> - das Array von Offsets für diese Variablen. Tatsächlich können die Werte aller Parameter in einer Funktion mit dem Punkt . initialisiert werden;</li> <li><strong>Variadic</strong> - true, wenn die Tail-Funktion eine variable Anzahl von Parametern haben kann.</li></ul> <h4 id="extfuncinfo-structure"><a href="#extfuncinfo-structure" class="header-anchor">#</a> ExtFuncInfo-Struktur </h4> <p>Zeigt auf den ObjExtFunc-Typ, und das Value-Feld enthält eine ExtFuncInfo-Struktur. Es wird verwendet, um Golang-Funktionen zu beschreiben.</p> <div class="language- extra-class"><pre class="language-text"><code>type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
</code></pre></div><p>Die ExtFuncInfo-Struktur hat die folgenden Elemente:</p> <ul><li>Die Parameter <strong>Name</strong>, <strong>Params</strong>, <strong>Results</strong> haben die gleiche Struktur wie <a href="#funcinfo-structure">FuncInfo</a>;</li> <li><strong>Auto</strong> - ein Array von Variablen. Wird gegebenenfalls als zusätzlicher Parameter an die Funktion übergeben. Beispielsweise eine Variable vom Typ SmartContract sc;</li> <li><strong>Func</strong> - Golang-Funktionen.</li></ul> <h4 id="varinfo-structure"><a href="#varinfo-structure" class="header-anchor">#</a> VarInfo-Struktur </h4> <p>Zeigt auf den Typ <strong>ObjVar</strong>, und das Feld <strong>Value</strong> enthält eine <strong>VarInfo</strong>-Struktur.</p> <div class="language- extra-class"><pre class="language-text"><code>type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
</code></pre></div><p>Die VarInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Obj</strong> - Informationen über Typ und Wert der Variablen;</li> <li><strong>Eigentümer</strong> - Zeiger auf den Eigentümerblock.</li></ul> <h4 id="objextend-value"><a href="#objextend-value" class="header-anchor">#</a> ObjExtend-Wert </h4> <p>Zeigt auf den Typ <strong>ObjExtend</strong>, und das Feld <strong>Value</strong> enthält eine Zeichenfolge, die den Namen der Variablen oder Funktion enthält.</p> <h2 id="virtual-machine-commands"><a href="#virtual-machine-commands" class="header-anchor">#</a> Befehle für virtuelle Maschinen </h2> <h3 id="bytecode-structure"><a href="#bytecode-structure" class="header-anchor">#</a> ByteCode-Struktur </h3> <p>Ein Bytecode ist eine Folge von Strukturen vom Typ <strong>ByteCode</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type ByteCode struct {
   Cmd uint16
   Value interface{}
}
</code></pre></div><p>Diese Struktur hat die folgenden Felder:</p> <ul><li><strong>Cmd</strong> - der Bezeichner der Speicherbefehle;</li> <li><strong>Wert</strong> - enthält den Operanden (Wert).</li></ul> <p>Im Allgemeinen führen Befehle eine Operation auf dem obersten Element des Stapels aus und schreiben bei Bedarf den Ergebniswert hinein.</p> <h3 id="command-identifiers"><a href="#command-identifiers" class="header-anchor">#</a> Befehlskennungen </h3> <p>Bezeichner der Befehle der virtuellen Maschine sind in der Datei vm/cmds_list.go beschrieben.</p> <ul><li><strong>cmdPush</strong> – legt einen Wert aus dem Value-Feld auf den Stack. Legen Sie zum Beispiel Zahlen und Linien auf den Stapel;</li> <li><strong>cmdVar</strong> - Legt den Wert einer Variablen auf den Stack. Value enthält einen Zeiger auf die VarInfo-Struktur und Informationen über die Variable;</li> <li><strong>cmdExtend</strong> – legt den Wert einer externen Variablen auf den Stack. Wert enthält eine Zeichenfolge mit dem Variablennamen (beginnend mit $);</li> <li><strong>cmdCallExtend</strong> – Aufruf einer externen Funktion (beginnend mit $). Die Parameter der Funktion werden aus dem Stapel abgerufen und die Ergebnisse auf dem Stapel abgelegt. Wert enthält einen Funktionsnamen (beginnend mit $);</li> <li><strong>cmdPushStr</strong> – legt den String in Value auf den Stack;</li> <li><strong>cmdCall</strong> - ruft die Funktion der virtuellen Maschine auf. Wert enthält eine <strong>ObjInfo</strong>-Struktur. Dieser Befehl gilt für die Golang-Funktion <strong>ObjExtFunc</strong> und die Needle-Funktion <strong>ObjFunc</strong>. Wenn eine Funktion aufgerufen wird, werden ihre Parameter vom Stapel abgerufen und die Ergebniswerte werden auf dem Stapel abgelegt;</li> <li><strong>cmdCallVari</strong> - Ähnlich wie der Befehl <strong>cmdCall</strong> ruft er die Funktion der virtuellen Maschine auf. Dieser Befehl wird verwendet, um eine Funktion mit einer variablen Anzahl von Parametern aufzurufen;</li> <li><strong>cmdReturn</strong> - wird verwendet, um die Funktion zu verlassen. Die Rückgabewerte werden auf den Stack gelegt und das Value-Feld wird nicht verwendet;</li> <li><strong>cmdIf</strong> – übergibt die Kontrolle an den Bytecode in der Struktur <strong>block</strong>, der im Feld Wert übergeben wird. Das Steuerelement wird nur dann auf den Stack übertragen, wenn das oberste Element des Stacks von der <em>valueToBool</em>-Funktion aufgerufen und <code>true</code> zurückgegeben wird. Andernfalls wird die Steuerung an den nächsten Befehl übergeben;</li> <li><strong>cmdElse</strong> - dieser Befehl funktioniert auf die gleiche Weise wie <strong>cmdIf</strong>, aber nur wenn das oberste Element des Stacks von der valueToBool-Funktion aufgerufen und <code>false</code> zurückgegeben wird, wird die Steuerung an die übertragen angegebener Block;</li> <li><strong>cmdAssignVar</strong> – erhält eine Liste von Variablen des Typs <strong>VarInfo</strong> von Value. Diese Variablen verwenden den Befehl <strong>cmdAssign</strong>, um den Wert abzurufen;</li> <li><strong>cmdAssign</strong> – weist den Wert im Stack der Variablen zu, die durch den Befehl <strong>cmdAssignVar</strong> erhalten wurde;</li> <li><strong>cmdLabel</strong> - definiert ein Label, wenn die Steuerung während der While-Schleife zurückgegeben wird;</li> <li><strong>cmdContinue</strong> - Dieser Befehl überträgt die Steuerung an das Label <strong>cmdLabel</strong>. Beim Ausführen einer neuen Iteration der Schleife wird Value nicht verwendet;</li> <li><strong>cmdWhile</strong> – Verwenden Sie valueToBool, um das oberste Element des Stapels zu überprüfen. Wenn dieser Wert „true“ ist, wird die Struktur <strong>block</strong> aus dem Wertefeld aufgerufen;</li> <li><strong>cmdBreak</strong> - beendet die Schleife;</li> <li><strong>cmdIndex</strong> – legt den Wert in der Map oder im Array nach Index in den Stack, ohne Value zu verwenden. Beispiel: <code>(map | array) (index value) =&gt; (map | array [index value])</code>;</li> <li><strong>cmdSetIndex</strong> – weist den Wert des obersten Elements des Stapels den Elementen der Karte oder des Arrays zu, ohne Value zu verwenden. Beispiel: <code>(map | array) (index value) (value) =&gt; (map | array)</code>;</li> <li><strong>cmdFuncName</strong> - fügt Parameter hinzu, die mit sequentiellen Beschreibungen geteilt durch Punkt übergeben werden. Beispiel: <code>func name =&gt; Fun (...) .Name (...)</code>;</li> <li><strong>cmdUnwrapArr</strong> - definiert ein boolesches Flag, wenn das oberste Element des Stapels ein Array ist;</li> <li><strong>cmdMapInit</strong> – initialisiert den Wert von map;</li> <li><strong>cmdArrayInit</strong> – initialisiert den Wert des Arrays;</li> <li><strong>cmdError</strong> - Dieser Befehl wird erstellt, wenn ein Vertrag oder eine Funktion mit einem angegebenen <code>error, warning, info</code> beendet wird.</li></ul> <h3 id="stack-operation-commands"><a href="#stack-operation-commands" class="header-anchor">#</a> Stack-Operationsbefehle </h3> <blockquote><p>Hinweis</p></blockquote> <blockquote><p>In der aktuellen Version ist die automatische Typkonvertierung für diese Befehle nicht vollständig anwendbar. Zum Beispiel,</p></blockquote> <blockquote><p><code>string + float | int | decimal =&gt; float | int | decimal, float + int | str =&gt; float, but int + string =&gt; runtime error</code>.</p></blockquote> <p>Das Folgende sind Befehle für die direkte Stack-Verarbeitung. Das Feld Wert wird in diesen Befehlen nicht verwendet.</p> <ul><li><strong>cmdNot</strong> - logische Negation. <code>(val) =&gt; (!ValueToBool(val))</code>;</li> <li><strong>cmdSign</strong> - Vorzeichenwechsel. <code>(val) =&gt; (-val)</code>;</li> <li><strong>cmdAdd</strong> - Ergänzung. <code>(val1)(val2) =&gt; (val1 + val2)</code>;</li> <li><strong>cmdSub</strong> - Subtraktion. <code>(val1)(val2) =&gt; (val1-val2)</code>;</li> <li><strong>cmdMul</strong> - Multiplikation. <code>(val1)(val2) =&gt; (val1 * val2)</code>;</li> <li><strong>cmdDiv</strong> - Division. <code>(val1)(val2) =&gt; (val1 / val2)</code>;</li> <li><strong>cmdAnd</strong> - logisches UND. <code>(val1)(val2) =&gt; (valueToBool(val1) &amp;&amp; valueToBool(val2))</code>;</li> <li><strong>cmdOr</strong> - logisches ODER. <code>(val1)(val2) =&gt; (valueToBool(val1) || valueToBool(val2))</code>;</li> <li><strong>cmdEqual</strong> - Gleichheitsvergleich, bool wird zurückgegeben. <code>(val1)(val2) =&gt; (val1 == val2)</code>;</li> <li><strong>cmdNotEq</strong> - Ungleichheitsvergleich, bool wird zurückgegeben. <code>(val1)(val2) =&gt; (val1 != val2)</code>;</li> <li><strong>cmdLess</strong> - Kleiner-als-Vergleich, bool wird zurückgegeben. <code>(val1)(val2) =&gt; (val1 &lt;val2)</code>;</li> <li><strong>cmdNotLess</strong> - Größer-gleich-Vergleich, bool wird zurückgegeben. <code>(val1)(val2) =&gt; (val1 &gt;= val2)</code>;</li> <li><strong>cmdGreat</strong> - Größer-als-Vergleich, bool wird zurückgegeben. <code>(val1)(val2) =&gt; (val1&gt; val2)</code>;</li> <li><strong>cmdNotGreat</strong> - Kleiner-gleich-Vergleich, bool wird zurückgegeben. <code>(val1)(val2) =&gt; (val1 &lt;= val2)</code>.</li></ul> <h3 id="runtime-structure"><a href="#runtime-structure" class="header-anchor">#</a> Laufzeitstruktur </h3> <p>Die Ausführung von Bytecodes wirkt sich nicht auf die virtuelle Maschine aus. Beispielsweise können verschiedene Funktionen und Verträge gleichzeitig in einer einzigen virtuellen Maschine ausgeführt werden. Die Runtime-Struktur wird verwendet, um Funktionen und Verträge sowie beliebige Ausdrücke und Bytecode auszuführen.</p> <div class="language- extra-class"><pre class="language-text"><code>type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}
</code></pre></div><ul><li><strong>stack</strong> - der Stack zum Ausführen des Bytecodes;</li> <li><strong>blocks</strong> - Stack für Blockaufrufe;</li> <li><strong>vars</strong> - Stapel von Variablen. Seine Variable wird dem Stapel von Variablen hinzugefügt, wenn der Bytecode im Block aufgerufen wird. Nach dem Verlassen des Blocks kehrt die Größe des Variablenstapels zum vorherigen Wert zurück;</li> <li><strong>extend</strong> - ein Zeiger zum Abbilden mit Werten externer Variablen (<code>$name</code>);</li> <li><strong>vm</strong> - ein Zeiger einer virtuellen Maschine;</li> <li><strong>cost</strong> - Kraftstoffeinheit der resultierenden Ausführungskosten;</li> <li><strong>err</strong> - Fehler während der Ausführung aufgetreten.</li></ul> <h4 id="blockstack-structure"><a href="#blockstack-structure" class="header-anchor">#</a> blockStack-Struktur </h4> <p>Die blockStack-Struktur wird in der Runtime-Struktur verwendet.</p> <div class="language- extra-class"><pre class="language-text"><code>type blockStack struct {
   Block *Block
   Offset int
}
</code></pre></div><ul><li><strong>Block</strong> – ein Zeiger auf den ausgeführten Block;</li> <li><strong>Offset</strong> – der Offset des letzten ausgeführten Befehls im Bytecode des angegebenen Blocks.</li></ul> <h3 id="runcode-function"><a href="#runcode-function" class="header-anchor">#</a> RunCode-Funktion </h3> <p>Bytecodes werden in der Funktion <strong>RunCode</strong> ausgeführt. Es enthält eine Schleife, die die entsprechende Operation für jeden Bytecode-Befehl durchführt. Vor der Verarbeitung eines Bytecodes müssen die erforderlichen Daten initialisiert werden.</p> <p>Neue Blöcke werden zu anderen Blöcken hinzugefügt.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = append(rt.blocks, &amp;blockStack{block, len(rt.vars)})
</code></pre></div><p>Rufen Sie als Nächstes die Informationen zu den relevanten Parametern der Tail-Funktion ab. Diese Parameter sind im letzten Element des Stapels enthalten.</p> <div class="language- extra-class"><pre class="language-text"><code>var namemap map[string][]interface{}
if block.Type == ObjFunc &amp;&amp; block.Info.(*FuncInfo).Names != nil {
   if rt.stack[len(rt.stack)-1] != nil {
      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
   }
   rt.stack = rt.stack[:len(rt.stack)-1]
}
</code></pre></div><p>Anschließend müssen alle im aktuellen Block definierten Variablen mit ihren Anfangswerten initialisiert werden.</p> <div class="language- extra-class"><pre class="language-text"><code>start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
   rt.cost--
   var value interface{}
</code></pre></div><p>Da Variablen in der Funktion auch Variablen sind, müssen wir sie vom letzten Element des Stacks in der von der Funktion selbst beschriebenen Reihenfolge abrufen.</p> <div class="language- extra-class"><pre class="language-text"><code>   if block.Type == ObjFunc &amp;&amp; vkey &lt;len(block.Info.(*FuncInfo).Params) {
      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
   } else {
</code></pre></div><p>Lokale Variablen mit ihren Anfangswerten initialisieren.</p> <div class="language- extra-class"><pre class="language-text"><code>      value = reflect.New(vpar).Elem().Interface()

      if vpar == reflect.TypeOf(map[string]interface{}{}) {

         value = make(map[string]interface{})
      } else if vpar == reflect.TypeOf([]interface{}{}) {
         value = make([]interface{}, 0, len(rt.vars)+1)
      }
   }
   rt.vars = append(rt.vars, value)
}
</code></pre></div><p>Aktualisieren Sie als Nächstes die Werte der variablen Parameter, die in der Tail-Funktion übergeben werden.</p> <div class="language- extra-class"><pre class="language-text"><code>if namemap != nil {
   for key, item := range namemap {
      params := (*block.Info.(*FuncInfo).Names)[key]
      for i, value := range item {
         if params.Variadic &amp;&amp; i &gt;= len(params.Params)-1 {
</code></pre></div><p>Wenn übergebene variable Parameter zu einer variablen Anzahl von Parametern gehören, werden diese Parameter zu einem Array von Variablen kombiniert.</p> <div class="language- extra-class"><pre class="language-text"><code>            off := varoff + params.Offset[len(params.Params)-1]
            rt.vars[off] = append(rt.vars[off].([]interface{}), value)
         } else {
            rt.vars[varoff+params.Offset[i]] = value
         }
      }
   }
}
</code></pre></div><p>Danach müssen wir nur noch Werte löschen, die von der Spitze des Stacks als Funktionsparameter übergeben wurden, wodurch der Stack verschoben wird. Wir haben ihre Werte in ein Variablenarray kopiert.</p> <div class="language- extra-class"><pre class="language-text"><code>if block.Type == ObjFunc {
   start -= len(block.Info.(*FuncInfo).Params)
}
</code></pre></div><p>Wenn eine Bytecode-Befehlsschleife beendet ist, müssen wir den Stack korrekt leeren.</p> <div class="language- extra-class"><pre class="language-text"><code>last := rt.blocks[len(rt.blocks)-1]
</code></pre></div><p>Löschen Sie den aktuellen Block aus dem Blockstapel.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
</code></pre></div><p>Wenn eine bereits ausgeführte Funktion erfolgreich beendet wird, fügen wir den Rückgabewert am Ende des vorherigen Stacks hinzu.</p> <div class="language- extra-class"><pre class="language-text"><code>   if last.Block.Type == ObjFunc {
      for count := len(last.Block.Info.(*FuncInfo).Results); count &gt; 0; count-- {
         rt.stack[start] = rt.stack[len(rt.stack)-count]
         start++
      }
      status = statusNormal
   } else {
</code></pre></div><p>Wie Sie sehen können, stellen wir den Stack-Status nicht wieder her und beenden die Funktion unverändert, wenn wir die Funktion nicht ausführen. Der Grund ist, dass Schleifen und bedingte Strukturen, die in der Funktion ausgeführt wurden, ebenfalls Bytecode-Blöcke sind.</p> <div class="language- extra-class"><pre class="language-text"><code>   return

   }
}

rt.stack = rt.stack[:start]
</code></pre></div><h3 id="other-functions-for-operations-with-vm"><a href="#other-functions-for-operations-with-vm" class="header-anchor">#</a> Weitere Funktionen für Operationen mit VM </h3> <p>Mit der Funktion <strong>NewVM</strong> können Sie eine virtuelle Maschine erstellen. Jeder virtuellen Maschine werden über die Funktion <strong>Extend</strong> vier Funktionen hinzugefügt, z. B. <strong>ExecContract</strong>, <strong>MemoryUsage</strong>, <strong>CallContract</strong> und <strong>Settings</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>for key, item := range ext.Objects {
   fobj := reflect.ValueOf(item).Type()
</code></pre></div><p>Wir durchlaufen alle übergebenen Objekte und betrachten nur die Funktionen.</p> <div class="language- extra-class"><pre class="language-text"><code>   switch fobj.Kind() {
   case reflect.Func:
</code></pre></div><p>Wir füllen die <strong>ExtFuncInfo</strong>-Struktur gemäß den über die Funktion erhaltenen Informationen und fügen ihre Struktur namentlich der Top-Level-Map <strong>Objects</strong> hinzu.</p> <div class="language- extra-class"><pre class="language-text"><code>   data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),
   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}
   for i := 0; i &lt;fobj.NumIn(); i++ {
</code></pre></div><p>Die <strong>ExtFuncInfo</strong>-Struktur hat ein <strong>Auto</strong>-Parameter-Array. Normalerweise ist der erste Parameter <code>sc *SmartContract</code> oder <code>rt *Runtime</code>, wir können sie nicht von der Sprache Needle übergeben, da sie für uns notwendig sind, um einige Golang-Funktionen auszuführen. Daher legen wir fest, dass diese Variablen automatisch verwendet werden, wenn diese Funktionen aufgerufen werden. In diesem Fall ist der erste Parameter der obigen vier Funktionen <code>rt *Runtime</code>.</p> <div class="language- extra-class"><pre class="language-text"><code>   if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
      data.Auto[i] = isauto
   }
</code></pre></div><p>Informationen zur Parametrierung.</p> <div class="language- extra-class"><pre class="language-text"><code>      data.Params[i] = fobj.In(i)
   }
</code></pre></div><p>Und die Typen der Rückgabewerte.</p> <div class="language- extra-class"><pre class="language-text"><code>for i := 0; i &lt;fobj.NumOut(); i++ {
   data.Results[i] = fobj.Out(i)
}
</code></pre></div><p>Fügt eine Funktion zu den <strong>Objekten</strong> des Stammverzeichnisses hinzu, damit der Compiler sie später finden kann, wenn er den Vertrag verwendet.</p> <div class="language- extra-class"><pre class="language-text"><code>      vm.Objects[key] = &amp;ObjInfo{ObjExtFunc, data}
   }

}
</code></pre></div><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> Compiler </h2> <p>Funktionen in der Datei compile.go sind für das Kompilieren des Token-Arrays verantwortlich, das vom lexikalischen Analysator erhalten wird. Die Zusammenstellung kann bedingt in zwei Ebenen unterteilt werden. Auf der obersten Ebene beschäftigen wir uns mit Funktionen, Verträgen, Codeblöcken, Bedingungs- und Schleifenanweisungen, Variablendefinitionen und so weiter. Auf der unteren Ebene kompilieren wir Ausdrücke in Codeblöcke oder Bedingungen in Schleifen und bedingte Anweisungen.</p> <p>Zunächst beginnen wir mit der einfachen unteren Ebene. In der Funktion <strong>compileEval</strong> können Ausdrücke in Bytecode umgewandelt werden. Da wir eine virtuelle Maschine mit einem Stack verwenden, ist es notwendig, gewöhnliche Infix-Record-Ausdrücke in Postfix-Notation oder umgekehrte polnische Notation umzuwandeln. Zum Beispiel wandeln wir „1+2“ in „12+“ um und legen „1“ und „2“ auf den Stack. Dann wenden wir die Additionsoperation auf die letzten beiden Elemente im Stack an und schreiben das Ergebnis in den Stack. Sie finden diesen <a href="https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/" target="_blank" rel="noopener noreferrer">Konvertierungs-<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Algorithmus im Internet.</p> <p>Die globale Variable „opers = map [uint32] operPrior“ enthält die Priorität der Operationen, die für die Konvertierung in die inverse polnische Notation erforderlich sind.</p> <p>Die folgenden Variablen werden am Anfang der Funktion <strong>compileEval</strong> definiert:</p> <ul><li><strong>Puffer</strong> - temporärer Puffer für Bytecode-Befehle;</li> <li><strong>Bytecode</strong> - letzter Puffer von Bytecode-Befehlen;</li> <li><strong>parcount</strong> - temporärer Puffer, der zum Berechnen von Parametern beim Aufrufen einer Funktion verwendet wird;</li> <li><strong>setIndex</strong> - Variablen im Arbeitsprozess werden auf true gesetzt, wenn wir Map- oder Array-Elemente zuweisen. Beispiel: <code>a[&quot;my&quot;] = 10</code>. In diesem Fall müssen wir den angegebenen Befehl <strong>cmdSetIndex</strong> verwenden.</li></ul> <p>Wir erhalten ein Token in einer Schleife und verarbeiten es entsprechend. Beispielsweise wird die Ausdruckstrennung gestoppt, wenn geschweiften Klammern gefunden werden. Beim Verschieben der Zeichenfolge prüfen wir, ob die vorherige Anweisung eine Operation ist und ob sie innerhalb der Klammern steht, andernfalls wird der Ausdruck beendet und analysiert.</p> <div class="language- extra-class"><pre class="language-text"><code>case isRCurly, isLCurly:
   i--
   if prevLex == isComma || prevLex == lexOper {
      return errEndExp
   }
   break main
case lexNewLine:
   if i &gt; 0 &amp;&amp; ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {
      continue main
   }
   for k := len(buffer) - 1; k &gt;= 0; k-- {
   if buffer[k].Cmd == cmdSys {
      continue main
   }
}
break main

</code></pre></div><p>Im Allgemeinen entspricht der Algorithmus selbst einem Algorithmus zum Umwandeln in die inverse polnische Notation. Unter Berücksichtigung des Aufrufs notwendiger Verträge, Funktionen und Indizes sowie anderer Dinge, die beim Parsing nicht vorkommen, und Optionen zum Parsing von Token vom Typ lexIdent werden dann Variablen, Funktionen oder Verträge mit diesem Namen überprüft. Wenn nichts gefunden wird und es sich nicht um einen Funktions- oder Vertragsaufruf handelt, wird ein Fehler angezeigt.</p> <div class="language- extra-class"><pre class="language-text"><code>objInfo, tobj := vm.findObj(lexem.Value.(string), block)
if objInfo == nil &amp;&amp; (!vm.Extern || i&gt; *ind || i &gt;= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {
   return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))
}
</code></pre></div><p>Wir können auf eine solche Situation stoßen, und der Vertragsaufruf wird später beschrieben. Wenn in diesem Beispiel keine Funktionen oder Variablen mit demselben Namen gefunden werden, halten wir es für notwendig, einen Vertrag aufzurufen. In dieser kompilierten Sprache gibt es keinen Unterschied zwischen Verträgen und Funktionsaufrufen. Aber wir müssen den Vertrag über die Funktion <strong>ExecContract</strong> aufrufen, die im Bytecode verwendet wird.</p> <div class="language- extra-class"><pre class="language-text"><code>if objInfo.Type == ObjContract {
   if objInfo.Value != nil {
      objContract = objInfo.Value.(*Block)
   }
   objInfo, tobj = vm.findObj(`ExecContract`, block)
   isContract = true
}
</code></pre></div><p>Die Anzahl der bisherigen Variablen erfassen wir in <code>count</code>, die zusammen mit der Anzahl der Funktionsparameter auch auf den Stack geschrieben werden. Bei jeder weiteren Erkennung von Parametern müssen wir diese Zahl nur am letzten Element des Stapels um eine Einheit erhöhen.</p> <div class="language- extra-class"><pre class="language-text"><code>count := 0
if (*lexems)[i+2].Type != isRPar {
   count++
}
</code></pre></div><p>Wir haben eine Liste mit aufgerufenen Parametern für Verträge verwendet, dann müssen wir den Fall markieren, in dem der Vertrag aufgerufen wird. Wenn der Vertrag ohne Parameter aufgerufen wird, müssen wir zwei leere Parameter hinzufügen, um <strong>ExecContract</strong> aufzurufen, um mindestens zwei Parameter zu erhalten.</p> <div class="language- extra-class"><pre class="language-text"><code>if isContract {
   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))
   for j := len(*block) - 1; j &gt;= 0; j-- {
   topblock := (*block)[j]
      if topblock.Type == ObjContract {
         if topblock.Info.(*ContractInfo).Used == nil {
            topblock.Info.(*ContractInfo).Used = make(map[string]bool)
         }
         topblock.Info.(*ContractInfo).Used[name] = true
      }
   }
   bytecode = append(bytecode, &amp;ByteCode{cmdPush, name})
   if count == 0 {
      count = 2
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
   }
   count++
}
</code></pre></div><p>Wenn wir sehen, dass als nächstes eine eckige Klammer steht, fügen wir den Befehl <strong>cmdIndex</strong> hinzu, um den Wert durch den Index zu erhalten.</p> <div class="language- extra-class"><pre class="language-text"><code>if (*lexems)[i+1].Type == isLBrack {
   if objInfo == nil || objInfo.Type != ObjVar {
      return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))
   }
   buffer = append(buffer, &amp;ByteCode{cmdIndex, 0})
}
</code></pre></div><p>Die Funktion <strong>CompileBlock</strong> kann Objektbäume und ausdrucksunabhängige Bytecodes generieren. Der Kompilierungsprozess basiert auf einer endlichen Zustandsmaschine, genau wie ein lexikalischer Analysator, aber mit den folgenden Unterschieden. Erstens verwenden wir keine Symbole, sondern Tokens; zweitens werden wir gleich die <em>states</em>-Variablen in allen Zuständen und Übergängen beschreiben. Es stellt ein Array von Objekten dar, die nach Tokentyp indiziert sind. Jedes Token hat eine Struktur von <em>compileState</em>, und ein neuer Status wird in <em>NewState</em> angegeben. Wenn klar ist, welche Struktur wir aufgelöst haben, können wir die Funktion des Handlers im Feld <em>Func</em> angeben.</p> <p>Betrachten wir den Hauptzustand als Beispiel.</p> <p>Wenn wir auf einen Zeilenumbruch oder einen Kommentar stoßen, bleiben wir im selben Zustand. Wenn wir auf das Schlüsselwort <strong>contract</strong> stoßen, ändern wir den Status in <em>stateContract</em> und beginnen mit dem Parsen der Struktur. Wenn wir auf das Schlüsselwort <strong>func</strong> stoßen, ändern wir den Status in <em>stateFunc</em>. Wenn andere Token empfangen werden, wird die Funktion, die einen Fehler generiert, aufgerufen.</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateRoot
   lexNewLine: {stateRoot, 0},
   lexKeyword | (keyContract &lt;&lt; 8): {stateContract | statePush, 0},
   lexKeyword | (keyFunc &lt;&lt; 8): {stateFunc | statePush, 0},
   lexComment: {stateRoot, 0},
   0: {errUnknownCmd, cfError},
},
</code></pre></div><p>Angenommen, wir sind auf das Schlüsselwort <strong>func</strong> gestoßen und haben den Status in <em>stateFunc</em> geändert. Da der Funktionsname auf das Schlüsselwort <strong>func</strong> folgen muss, behalten wir denselben Zustand bei, wenn wir den Funktionsnamen ändern. Für alle anderen Token werden wir entsprechende Fehler generieren. Wenn wir den Funktionsnamen in der Token-ID erhalten, gehen wir zum <em>stateFParams</em>-Zustand, wo wir die Parameter der Funktion erhalten können.</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateFunc
   lexNewLine: {stateFunc, 0},
   lexIdent: {stateFParams, cfNameBlock},
   0: {errMustName, cfError},
},
</code></pre></div><p>Gleichzeitig mit den obigen Operationen rufen wir die Funktion <strong>fNameBlock</strong> auf. Es sollte beachtet werden, dass die Blockstruktur mit der statePush-Markierung erstellt wird, wo wir sie aus dem Puffer holen und mit den Daten füllen, die wir benötigen. Die <strong>fNameBlock</strong>-Funktion eignet sich für Verträge und Funktionen (einschließlich der darin verschachtelten). Er füllt das <em>Info</em>-Feld mit der entsprechenden Struktur und schreibt sich in die <em>Objects</em> des übergeordneten Blocks. Auf diese Weise können wir die Funktion oder den Vertrag mit dem angegebenen Namen aufrufen. Ebenso erstellen wir entsprechende Funktionen für alle Zustände und Variablen. Diese Funktionen sind normalerweise sehr klein und führen einige Aufgaben beim Erstellen des Baums der virtuellen Maschine aus.</p> <div class="language- extra-class"><pre class="language-text"><code>func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {
   var itype int
   prev := (*buf)[len(*buf)-2]
   fblock := (*buf)[len(*buf)-1]
   name := lexem.Value.(string)
   switch state {
      case stateBlock:
         itype = ObjContract
         name = StateName((*buf)[0].Info.(uint32), name)
         fblock.Info = &amp;ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,
         Owner: (*buf)[0].Owner}
      default:
         itype = ObjFunc
         fblock.Info = &amp;FuncInfo{}
   }
   fblock.Type = itype
   prev.Objects[name] = &amp;ObjInfo{Type: itype, Value: fblock}
   return nil
}
</code></pre></div><p>Für die Funktion <strong>CompileBlock</strong> durchläuft sie einfach alle Tokens und wechselt die Zustände gemäß den in den Zuständen beschriebenen Tokens. Fast alle zusätzlichen Token entsprechen zusätzlichen Programmcodes.</p> <ul><li><strong>statePush</strong> – fügt das Objekt <strong>Block</strong> zum Objektbaum hinzu;</li> <li><strong>statePop</strong> - wird verwendet, wenn der Block mit einer schließenden geschweiften Klammer endet;</li> <li><strong>stateStay</strong> - Sie müssen die aktuelle Markierung beibehalten, wenn Sie in einen neuen Status wechseln;</li> <li><strong>stateToBlock</strong> - Übergang in den Zustand <strong>stateBlock</strong> zur Verarbeitung von <em>while</em> und <em>if</em>. Nach der Verarbeitung von Ausdrücken müssen Sie Blöcke innerhalb der geschweiften Klammern verarbeiten;</li> <li><strong>stateToBody</strong> - Übergang in den Zustand <strong>stateBody</strong>;</li> <li><strong>stateFork</strong> - speichert die markierte Position. Wenn der Ausdruck mit einem Bezeichner oder einem Namen mit <code>$</code> beginnt, können wir Funktionsaufrufe oder Zuweisungen vornehmen;</li> <li><strong>stateToFork</strong> – wird verwendet, um das in <strong>stateFork</strong> gespeicherte Token abzurufen, das an die Prozessfunktion übergeben wird;</li> <li><strong>stateLabel</strong> – wird zum Einfügen von <strong>cmdLabel</strong>-Befehlen verwendet. <em>während</em> die Struktur dieses Flag erfordert;</li> <li><strong>stateMustEval</strong> – prüft die Verfügbarkeit von bedingten Ausdrücken am Anfang von <em>if</em>- und <em>while</em>-Strukturen.</li></ul> <p>Neben der Funktion <strong>CompileBlock</strong> ist auch die Funktion <strong>FlushBlock</strong> zu nennen. Das Problem besteht jedoch darin, dass der Blockbaum unabhängig von vorhandenen virtuellen Maschinen erstellt wird. Genauer gesagt erhalten wir Informationen über Funktionen und Verträge, die in einer virtuellen Maschine vorhanden sind, aber wir sammeln die kompilierten Blöcke in einem separaten Baum. Andernfalls, wenn während der Kompilierung ein Fehler auftritt, müssen wir die virtuelle Maschine auf den vorherigen Zustand zurücksetzen. Daher gehen wir separat zum Kompilierungsbaum, aber nachdem die Kompilierung erfolgreich ist, muss die Funktion <strong>FlushContract</strong> aufgerufen werden. Diese Funktion fügt den fertigen Blockbaum zur aktuellen virtuellen Maschine hinzu. Die Kompilierungsphase ist nun abgeschlossen.</p> <h2 id="lexical-analyzer"><a href="#lexical-analyzer" class="header-anchor">#</a> Lexikalischer Analysator </h2> <p>Der lexikalische Analysator verarbeitet eingehende Zeichenfolgen und bildet eine Folge von Token der folgenden Typen:</p> <ul><li><strong>lexSys</strong> - Systemtoken, zum Beispiel: <code>{}, [], (), ,, .</code> usw.;</li> <li><strong>lexOper</strong> - Vorgangstoken, zum Beispiel: <code>+, -, /, \, *</code>;</li> <li><strong>lexNumber</strong> - Zahl;</li> <li><strong>lexident</strong> - Kennung;</li> <li><strong>lexNewline</strong> - Zeilenumbruchzeichen;</li> <li><strong>lexString</strong> - Zeichenkette;</li> <li><strong>lexComment</strong> - Kommentar;</li> <li><strong>lexKeyword</strong> - Schlüsselwort;</li> <li><strong>lexType</strong> - Typ;</li> <li><strong>lexExtend</strong> - Verweis auf externe Variablen oder Funktionen, zum Beispiel: <code>$myname</code>.</li></ul> <p>In der aktuellen Version wird zunächst mit Hilfe der Datei <a href="#lextablelextablego">script/lextable/lextable.go</a> eine Konvertierungstabelle (finite state machine) zum Parsen der Tokens aufgebaut, die in die Datei lex_table.go geschrieben wird. Im Allgemeinen können Sie die ursprünglich von der Datei generierte Konvertierungstabelle loswerden und direkt beim Start eine Konvertierungstabelle im Speicher erstellen (<code>init()</code>). Die lexikalische Analyse selbst findet in der lexParser-Funktion in der Datei <a href="#lex-go">lex.go</a> statt.</p> <h3 id="lextable-lextable-go"><a href="#lextable-lextable-go" class="header-anchor">#</a> lextable/lextable.go </h3> <p>Hier definieren wir das zu betreibende Alphabet und beschreiben, wie die endliche Zustandsmaschine basierend auf dem nächsten empfangenen Symbol von einem Zustand in einen anderen wechselt.</p> <p><em>states</em> ist ein JSON-Objekt, das eine Liste von Zuständen enthält.
Mit Ausnahme bestimmter Symbole steht „d“ für alle Symbole, die nicht im Staat angegeben sind.
„n“ steht für 0x0a, „s“ steht für Leerzeichen, „q“ steht für Backquote, „Q“ steht für doppeltes Anführungszeichen, „r“ steht für Zeichen &gt;= 128, „a“ steht für AZ und az und „ 1` steht für 1-9.</p> <p>Die Namen dieser Zustände sind Schlüssel, und die möglichen Werte sind im Wertobjekt aufgelistet. Dann gibt es einen neuen Zustand, um Übergänge für jede Gruppe vorzunehmen. Dann gibt es noch den Namen des Tokens. Wenn wir zum Anfangszustand zurückkehren müssen, ist der dritte Parameter das Service-Token, das angibt, wie mit dem aktuellen Symbol umgegangen werden soll.</p> <p>Zum Beispiel haben wir den Hauptzustand und die eingehenden Zeichen <code>/</code>, <code>&quot;/&quot;: [&quot;solidus&quot;, &quot;&quot;, &quot;push next&quot;]</code>,</p> <ul><li><strong>push</strong> - gibt den Befehl, sich daran zu erinnern, dass es sich in einem separaten Stack befindet ;</li> <li><strong>nächster</strong> - geht zum nächsten Zeichen, und gleichzeitig ändern wir den Status auf <strong>solidus</strong>. Ruft danach das nächste Zeichen ab und überprüft den Status von <strong>solidus</strong>.</li></ul> <p>Wenn das nächste Zeichen <code>/</code> oder <code>/*</code> hat, gehen wir zum Kommentarstatus <strong>Kommentar</strong>, weil sie mit <code>//</code> oder <code>/*</code> beginnen. Offensichtlich hat jeder Kommentar danach einen anderen Zustand, weil sie mit einem anderen Symbol enden.</p> <p>Wenn das nächste Zeichen nicht <code>/</code> und <code>*</code> ist, dann zeichnen wir alles im Stack als Tags vom Typ <strong>lexOper</strong> auf, leeren den Stack und kehren zum Hauptzustand zurück.
Das folgende Modul konvertiert den Zustandsbaum in ein numerisches Array und schreibt es in die Datei <em>lex_table.go</em>.</p> <p>In der ersten Schleife:</p> <p>Wir bilden ein Alphabet gültiger Symbole.</p> <div class="language- extra-class"><pre class="language-text"><code>for ind, ch := range alphabet {
   i := byte(ind)
</code></pre></div><p>Darüber hinaus versehen wir in <strong>state2int</strong> jeden Zustand mit einer eigenen Sequenzkennung.</p> <div class="language- extra-class"><pre class="language-text"><code>   state2int := map[string]uint{`main`: 0}
   if err := json.Unmarshal([]byte(states), &amp;data); err == nil {
   for key := range data {
   if key != `main` {
   state2int[key] = uint(len(state2int))
</code></pre></div><p>Wenn wir alle Zustände und jede Menge in einem Zustand und jedes Symbol in einer Menge durchlaufen, schreiben wir eine Drei-Byte-Zahl [neue Zustandskennung (0 = Haupt)] + [Tokentyp (0-kein Token)] + [Token] .
Die Zweidimensionalität des Arrays <em>table</em> besteht darin, dass es in Zustände und 34 Eingabesymbole aus dem Array <em>alphabet</em> unterteilt ist, die in derselben Reihenfolge angeordnet sind.
Wir befinden uns im <em>Hauptzustand</em> in der Nullzeile der <em>Tabelle</em>. Nehmen Sie das erste Zeichen, finden Sie seinen Index im Array <em>alphabet</em> und erhalten Sie den Wert aus der Spalte mit dem angegebenen Index. Ausgehend vom empfangenen Wert erhalten wir den Token im Low-Byte. Wenn die Analyse abgeschlossen ist, zeigt das zweite Byte den Typ des empfangenen Tokens an. Im dritten Byte erhalten wir den Index des nächsten neuen Zustands.
All dies wird ausführlicher in der Funktion <strong>lexParser</strong> in <em>lex.go</em> beschrieben.
Wenn Sie einige neue Zeichen hinzufügen möchten, müssen Sie sie dem Array <em>alphabet</em> hinzufügen und die Menge der Konstante <em>AlphaSize</em> erhöhen. Wenn Sie eine neue Symbolkombination hinzufügen möchten, sollte diese ähnlich wie bei den bestehenden Optionen im Status beschrieben werden. Führen Sie nach dem obigen Vorgang die Datei <em>lextable.go</em> aus, um die Datei <em>lex_table.go</em> zu aktualisieren.</p> <h3 id="lex-go"><a href="#lex-go" class="header-anchor">#</a> lex.go </h3> <p>Die <strong>lexParser</strong>-Funktion generiert direkt eine lexikalische Analyse und gibt basierend auf eingehenden Zeichenfolgen ein Array empfangener Tags zurück. Lassen Sie uns die Struktur von Token analysieren.</p> <div class="language- extra-class"><pre class="language-text"><code>type Lexem struct {
   Type  uint32 // Type of the lexem
   Value interface{} // Value of lexem
   Line  uint32 // Line of the lexem
   Column uint32 // Position inside the line
}
</code></pre></div><ul><li><strong>Type</strong> - Token-Typ. Es hat einen der folgenden Werte: <code>lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend</code>;</li> <li><strong>Value</strong> – Wert des Tokens. Die Art des Werts hängt vom Token-Typ ab. Lassen Sie uns das genauer analysieren:
<ul><li><strong>lexSys</strong> - enthält Klammern, Kommas usw. In diesem Fall `Type = ch &lt;&lt; 8 | lexSys“, beziehen Sie sich bitte auf die Konstante „isLPar ... isRBrack“, und ihr Wert ist uint32 Bits;</li> <li><strong>lexOper</strong> - der Wert stellt eine äquivalente Zeichenfolge in Form von uint32 dar. Siehe die <code>isNot ... isOr</code>-Konstanten;</li> <li><strong>lexNumber</strong> - Zahlen werden als int64 oder float64 gespeichert. Wenn die Zahl einen Dezimalpunkt hat, ist sie Float64;</li> <li><strong>lexIdent</strong> - Identifikatoren werden als String gespeichert;</li> <li><strong>lexNewLine</strong> - Zeilenumbruchzeichen. Wird auch zur Berechnung der Reihen- und Tokenposition verwendet;</li> <li><strong>lexString</strong> - Zeilen werden als String gespeichert;</li> <li><strong>lexComment</strong> - Kommentare werden als String gespeichert;</li> <li><strong>lexKeyword</strong> - für Schlüsselwörter werden nur die entsprechenden Indizes gespeichert, siehe <code>keyContract ... keyTail</code>-Konstante. In diesem Fall <code>Type = KeyID &lt;&lt; 8 | lexKeyword</code>. Außerdem ist zu beachten, dass die Schlüsselwörter „true, false, nil“ sofort in Token vom Typ „lexNumber“ umgewandelt und die entsprechenden Typen „bool“ und „interface {}“ verwendet werden;</li> <li><strong>lexType</strong> – dieser Wert enthält den entsprechenden „reflect.Type“-Typwert;</li> <li><strong>lexExtend</strong> – Bezeichner, die mit einem <code>$</code> beginnen. Diese Variablen und Funktionen werden von außen übergeben und sind daher speziellen Arten von Token zugeordnet. Dieser Wert enthält den Namen als String ohne $ am Anfang.</li></ul></li> <li><strong>Line</strong> - die Zeile, in der das Token gefunden wird;</li> <li><strong>Column</strong> - Inline-Position des Tokens.
Lassen Sie uns die Funktion <strong>lexParser</strong> im Detail analysieren. Die <strong>todo</strong>-Funktion schlägt den Symbolindex im Alphabet basierend auf dem aktuellen Status und dem eingehenden Symbol nach und erhält einen neuen Status, Token-Identifikator (falls vorhanden) und andere Token aus der Umwandlungstabelle. Das Parsing selbst beinhaltet das Aufrufen der <strong>todo</strong>-Funktion der Reihe nach für jedes nächste Zeichen und das Wechseln in einen neuen Zustand. Sobald das Tag empfangen wurde, erstellen wir das entsprechende Token in den Ausgabekriterien und setzen den Parsing-Prozess fort. Es sollte beachtet werden, dass wir während des Parsing-Prozesses die Token-Symbole nicht in einem separaten Stack oder Array akkumulieren, weil wir nur den Offset des Starts des Tokens speichern. Nachdem wir das Token erhalten haben, verschieben wir den Offset des nächsten Tokens an die aktuelle Parsing-Position.</li></ul> <p>Es bleibt nur noch, die beim Parsing verwendeten lexikalischen Status-Token zu überprüfen:</p> <ul><li><strong>lexfPush</strong> - dieses Token bedeutet, dass wir beginnen, Symbole in einem neuen Token zu sammeln;</li> <li><strong>lexfNext</strong> - das Zeichen muss dem aktuellen Token hinzugefügt werden;</li> <li><strong>lexfPop</strong> - Der Empfang des Tokens ist abgeschlossen. Normalerweise haben wir mit diesem Flag den Bezeichnertyp des geparsten Tokens;</li> <li><strong>lexfSkip</strong> - Dieses Token wird verwendet, um Zeichen vom Parsen auszuschließen. Beispielsweise sind die Kontrollschrägstriche in der Zeichenfolge \n \r &quot;. Sie werden während der lexikalischen Analysephase automatisch ersetzt.</li></ul> <h2 id="needle-language"><a href="#needle-language" class="header-anchor">#</a> Needle Sprache </h2> <h3 id="lexemes"><a href="#lexemes" class="header-anchor">#</a> Lexemes </h3> <p>Der Quellcode eines Programms muss in UTF-8-Kodierung vorliegen.</p> <p>Die folgenden lexikalischen Typen werden verarbeitet:</p> <ul><li><strong>Schlüsselwörter</strong> - <code>action, break, conditions, Continue, Contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while</code> ;</li> <li><strong>Zahl</strong> - nur Dezimalzahlen werden akzeptiert. Es gibt zwei Grundtypen: <strong>int</strong> und <strong>float</strong>. Wenn die Zahl einen Dezimalpunkt hat, wird sie zu einem Float <strong>float</strong>. Der Typ <strong>int</strong> entspricht in Golang <strong>int64</strong>, während der Typ <strong>float</strong> in Golang <strong>float64</strong> entspricht.</li> <li><strong>String</strong> - Der String kann in doppelte Anführungszeichen <code>(&quot;ein String&quot;)</code> oder Backquotes <code>(\`ein String\`)</code> eingeschlossen werden. Beide Arten von Zeichenfolgen können Zeilenumbruchzeichen enthalten. Zeichenfolgen in doppelten Anführungszeichen können doppelte Anführungszeichen, Zeilenumbruchzeichen und mit Schrägstrichen maskierte Wagenrückläufe enthalten. Beispiel: <code>&quot;Dies ist eine \&quot;erste Zeichenfolge\&quot;.\r\nDies ist eine zweite Zeichenfolge.&quot;</code>.</li> <li><strong>Kommentar</strong> - Es gibt zwei Arten von Kommentaren. Einzeilige Kommentare verwenden zwei Schrägstriche (//). Beispiel: // Dies ist ein einzeiliger Kommentar. Mehrzeilige Kommentare verwenden Schrägstriche und Sternchen und können sich über mehrere Zeilen erstrecken. Beispiel: <code>/* Dies ist ein mehrzeiliger Kommentar */</code>.</li> <li><strong>Bezeichner</strong> - die Namen von Variablen und Funktionen, die aus Buchstaben a-z und A-Z, UTF-8-Symbolen, Zahlen und Unterstrichen bestehen. Der Name kann mit einem Buchstaben, Unterstrich, <code>@</code> oder <code>$</code> beginnen. Der Name, der mit <code>$</code> beginnt, ist der Name der Variablen, die im <strong>Datenabschnitt</strong> definiert ist. Der mit <code>$</code> beginnende Name kann auch verwendet werden, um globale Variablen im Bereich von <strong>Bedingungen</strong> und <strong>Aktionsabschnitten</strong> zu definieren. Ökosystemverträge können über das Symbol <code>@</code> aufgerufen werden. Zum Beispiel: <code>@1NewTable(...)</code>.</li></ul> <h3 id="types"><a href="#types" class="header-anchor">#</a> Typen </h3> <p>Neben den Nadeltypen sind entsprechende Golang-Typen angegeben.</p> <ul><li><strong>bool</strong> - bool, standardmäßig <strong>false</strong>;</li> <li><strong>bytes</strong> - []byte{}, standardmäßig ein leeres Byte-Array;</li> <li><strong>int</strong> - standardmäßig int64, <strong>0</strong>;</li> <li><strong>address</strong> - uint64, standardmäßig <strong>0</strong>;</li> <li><strong>array</strong> - []interface{}, standardmäßig ein leeres Array;</li> <li><strong>map</strong> - map[string]interface{}, standardmäßig ein leeres Objekt-Array;</li> <li><strong>money</strong> - Dezimalzahl. Dezimal, standardmäßig <strong>0</strong>;</li> <li><strong>float</strong> - float64, standardmäßig <strong>0</strong>;</li> <li><strong>string</strong> - String, standardmäßig ein leerer String;</li> <li><strong>file</strong> - map[string]interface{}, standardmäßig ein leeres Objekt-Array.
Diese Variablentypen werden mit dem Schlüsselwort <code>var</code> definiert. Beispiel: <code>var var1, var2 int</code>. Bei dieser Definition wird einer Variablen ein Standardwert nach Typ zugewiesen.</li></ul> <p>Alle Variablenwerte sind vom Typ interface{} und werden dann den erforderlichen Golang-Typen zugewiesen. Daher sind beispielsweise Array- und Map-Typen Golang-Typen []interface{} und map[string]interface{}. Beide Arten von Arrays können Elemente beliebigen Typs enthalten.</p> <h3 id="expressions"><a href="#expressions" class="header-anchor">#</a> Ausdrücke </h3> <p>Ein Ausdruck kann arithmetische Operationen, logische Operationen und Funktionsaufrufe enthalten. Alle Ausdrücke werden von links nach rechts nach Priorität der Operatoren ausgewertet. Bei gleicher Priorität werden Operatoren von links nach rechts ausgewertet.</p> <p>Priorität der Operationen von hoch nach niedrig:</p> <ul><li><strong>Funktionsaufruf und Klammern</strong> - Beim Aufruf einer Funktion werden übergebene Parameter von links nach rechts berechnet;</li> <li><strong>Unäre Operation</strong> - logische Negation <code>!</code> und arithmetischer Vorzeichenwechsel <code>-</code>;</li> <li><strong>Multiplikation und Division</strong> - arithmetische Multiplikation <code>*</code> und Division <code>/</code>;</li> <li><strong>Addition und Subtraktion</strong> - arithmetische Addition <code>+</code> und Subtraktion <code>-</code>;</li> <li><strong>Logischer Vergleich</strong> - <code>&gt;=&gt;&gt; &gt;=</code>;</li> <li><strong>Logische Gleichheit und Ungleichheit</strong> - <code>== !=</code>;</li> <li><strong>Logisches UND</strong> - <code>&amp;&amp;</code>;</li> <li><strong>Logisches ODER</strong> - <code>||</code>.</li></ul> <p>Bei der Auswertung von logischem AND und OR werden in jedem Fall beide Seiten des Ausdrucks ausgewertet.</p> <p>Needle hat keine Typprüfung während der Kompilierung. Beim Auswerten von Operanden wird versucht, den Typ in einen komplexeren Typ umzuwandeln. Die Art der Komplexitätsreihenfolge kann wie folgt sein: <code>string, int, float, money</code>. Nur ein Teil der Typkonvertierungen ist implementiert. Der Zeichenfolgentyp unterstützt Additionsoperationen, und das Ergebnis ist eine Zeichenfolgenverkettung. Beispiel: <code>string + string = string, money-int = money, int * float = float</code>.</p> <p>Bei Funktionen wird während der Ausführung eine Typprüfung für die Typen <code>string</code> und <code>int</code> durchgeführt.
Die Typen <strong>array</strong> und <strong>map</strong> können per Index adressiert werden. Beim Typ <strong>array</strong> muss als Index der Wert <strong>int</strong> angegeben werden. Für den Typ <strong>Map</strong> muss eine Variable oder ein <strong>String</strong>-Wert angegeben werden. Wenn Sie einem <strong>Array</strong>-Element einen Wert zuweisen, dessen Index größer als der aktuelle maximale Index ist, wird dem Array ein leeres Element hinzugefügt. Der Anfangswert dieser Elemente ist <strong>nil</strong>. Zum Beispiel: .. Code:</p> <div class="language- extra-class"><pre class="language-text"><code>var my array
my[5] = 0
var mymap map
mymap[&quot;index&quot;] = my[3]
</code></pre></div><p>In Ausdrücken mit bedingten logischen Werten (z. B. <code>if, while, &amp;&amp;, ||, !</code>) wird der Typ automatisch in einen logischen Wert konvertiert. Wenn der Typ nicht der Standardwert ist, ist er wahr.</p> <div class="language- extra-class"><pre class="language-text"><code>var mymap map
var val string
if mymap &amp;&amp; val {
...
}
</code></pre></div><h3 id="scope"><a href="#scope" class="header-anchor">#</a> Zielfernrohr </h3> <p>Klammern geben einen Block an, der lokale Bereichsvariablen enthalten kann. Standardmäßig erstreckt sich der Geltungsbereich einer Variablen auf ihre eigenen Blöcke und alle verschachtelten Blöcke. In einem Block können Sie eine neue Variable mit dem Namen einer vorhandenen Variablen definieren. In diesem Fall sind jedoch externe Variablen mit demselben Namen nicht mehr verfügbar.</p> <div class="language- extra-class"><pre class="language-text"><code>var a int
a = 3
{
   var a int
   a = 4
   Println(a) // 4
}
Println(a) // 3
</code></pre></div><h3 id="contract-execution"><a href="#contract-execution" class="header-anchor">#</a> Vertragsabwicklung </h3> <p>Beim Aufruf eines Contracts müssen ihm in <strong>data</strong> definierte Parameter übergeben werden. Vor Ausführung eines Auftrags erhält die virtuelle Maschine diese Parameter und weist sie den entsprechenden Variablen ($Param) zu. Dann werden die vordefinierten Funktionen <strong>conditions</strong> und <strong>action</strong> aufgerufen.</p> <p>Fehler, die während der Vertragsausführung auftreten, können in zwei Arten unterteilt werden: Formularfehler und Umgebungsfehler. Formularfehler werden mit speziellen Befehlen generiert: <code>error, warning, info</code> und wenn die eingebaute Funktion <code>err</code> ungleich <em>nil</em> zurückgibt.</p> <p>Die Needle-Sprache behandelt keine Ausnahmen. Jeder Fehler wird die Ausführung von Verträgen beenden. Da ein separater Stack und eine separate Struktur zum Speichern von Variablenwerten erstellt werden, wenn ein Vertrag ausgeführt wird, löscht der Golang-Garbage-Collection-Mechanismus diese Daten automatisch, wenn ein Vertrag ausgeführt wird.</p> <h3 id="backus-naur-form-bnf"><a href="#backus-naur-form-bnf" class="header-anchor">#</a> Backus–Naur Form (BNF) </h3> <p>In der Informatik ist BNF eine Notationstechnik für kontextfreie Syntax und wird normalerweise verwendet, um die Syntax der beim Rechnen verwendeten Sprache zu beschreiben.</p> <ul><li>&lt;decimal digit&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
</code></pre></div><ul><li>&lt;decimal number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; {&lt;decimal digit&gt;}
</code></pre></div><ul><li>&lt;symbol code&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'''&lt;any symbol&gt;'''
</code></pre></div><ul><li>&lt;real number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number'.'[&lt;decimal number&gt;]
</code></pre></div><ul><li>&lt;integer number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number&gt; | &lt;symbol code&gt;
</code></pre></div><ul><li>&lt;number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'&lt;integer number&gt; | &lt;real number&gt;'
</code></pre></div><ul><li>&lt;letter&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF
</code></pre></div><ul><li>&lt;space&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x20'
</code></pre></div><ul><li>&lt;tabulation&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x09'
</code></pre></div><ul><li>&lt;newline&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x0D 0x0A'
</code></pre></div><ul><li>&lt;special symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'!' |'&quot;' |'$' |''' |'(' |')' |'\*' |'+' |',' |'-' |'.' |'/ '|'&lt;' |'=' |'&gt;' |'[' |'\\' |']' |'_' |'|' |'}' | '{' | &lt;tabulation&gt; | &lt;space&gt; | &lt;newline&gt;
</code></pre></div><ul><li>&lt;symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; | &lt;letter&gt; | &lt;special symbol&gt;
</code></pre></div><ul><li>&lt;name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(&lt;letter&gt; |'_') {&lt;letter&gt; |'_' | &lt;decimal digit&gt;}
</code></pre></div><ul><li>&lt;function name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;variable name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;type name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;string symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;tabulation&gt; | &lt;space&gt; |'!' |'#' | ... |'[' |']' | ...
</code></pre></div><ul><li>&lt;string element&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{&lt;string symbol&gt; |'\&quot;' |'\n' |'\r'}
</code></pre></div><ul><li>&lt;string&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'&quot;' {&lt;string element&gt;}'&quot;' |'\`' {&lt;string element&gt;}'\`'
</code></pre></div><ul><li>&lt;assignment operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'='
</code></pre></div><ul><li>&lt;unary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'-'
</code></pre></div><ul><li>&lt;binary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'==' |'!=' |'&gt;' |'&lt;' |'&lt;=' |'&gt;=' |'&amp;&amp;' |'||' |'\*' |'/' |'+ '|'-'
</code></pre></div><ul><li>&lt;operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;assignment operator&gt; | &lt;unary operator&gt; | &lt;binary operator&gt;
</code></pre></div><ul><li>&lt;parameters&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;expression&gt; {','&lt;expression&gt;}
</code></pre></div><ul><li>&lt;contract call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract name&gt;'(' [&lt;parameters&gt;]')'
</code></pre></div><ul><li>&lt;function call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract call&gt; [{'.' &lt;name&gt;'(' [&lt;parameters&gt;]')'}]
</code></pre></div><ul><li>&lt;block contents&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;block command&gt; {&lt;newline&gt;&lt;block command&gt;}
</code></pre></div><ul><li>&lt;block&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'{'&lt;block contents&gt;'}'
</code></pre></div><ul><li>&lt;block command&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(&lt;block&gt; | &lt;expression&gt; | &lt;variables definition&gt; | &lt;if&gt; | &lt;while&gt; | break | continue | return)
</code></pre></div><ul><li>&lt;if&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'if &lt;expression&gt;&lt;block&gt; [else &lt;block&gt;]'
</code></pre></div><ul><li>&lt;while&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'while &lt;expression&gt;&lt;block&gt;'
</code></pre></div><ul><li>&lt;contract&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'contract &lt;name&gt; '{'[&lt;data section&gt;] {&lt;function&gt;} [&lt;conditions&gt;] [&lt;action&gt;]'}''
</code></pre></div><ul><li>&lt;data section&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'data '{' {&lt;data parameter&gt;&lt;newline&gt;} '}''
</code></pre></div><ul><li>&lt;data parameter&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; &lt;type name&gt;'&quot;'{&lt;tag&gt;}'&quot;'
</code></pre></div><ul><li>&lt;tag&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'optional | image | file | hidden | text | polymap | map | address | signature:&lt;name&gt;'
</code></pre></div><ul><li>&lt;conditions&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'conditions &lt;block&gt;'
</code></pre></div><ul><li>&lt;action&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'action &lt;block&gt;'
</code></pre></div><ul><li>&lt;function&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'func &lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'[{&lt;tail&gt;}] [&lt;type name&gt;] &lt;block&gt;'
</code></pre></div><ul><li>&lt;variable description&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; {',' &lt;variable name&gt;} &lt;type name&gt;
</code></pre></div><ul><li>&lt;tail&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'.'&lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'
</code></pre></div><ul><li>&lt;variables definition&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'var &lt;variable description&gt;{','&lt;variable description&gt;}'
</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/IBAX-io/documentation/edit/master/docs/de/topics/vm.md" target="_blank" rel="noopener noreferrer">Bearbeiten Sie diese Seite auf GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Letzte Aktualisierung:</span> <span class="time">25.6.2023, 15:46:02</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/de/topics/templates2.html" class="prev">
        Vorlagensprache {#template-language}
      </a></span> <span class="next"><a href="/de/topics/script.html">
        Intelligente Verträge 
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d049f7ab.js" defer></script><script src="/assets/js/2.8d94a0db.js" defer></script><script src="/assets/js/28.78274c7e.js" defer></script>
  </body>
</html>
