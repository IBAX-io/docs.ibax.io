<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Compiler und virtuelle Maschine | IBAX Dokumentation</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="apple-touch-icon" size="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" size="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" size="16x16" href="/favicon-16x16.png">
    <link rel="mask-icon" color="#5bbad5" href="/safari-pinned-tab.svg">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="description" content="Ein dezentralisiertes kommerzielles kettenÃ¼bergreifendes Infrastrukturnetzwerk">
    
    <link rel="preload" href="/assets/css/0.styles.844a2aa8.css" as="style"><link rel="preload" href="/assets/js/app.1fdb8a3a.js" as="script"><link rel="preload" href="/assets/js/2.14a295a1.js" as="script"><link rel="preload" href="/assets/js/28.7895237d.js" as="script"><link rel="prefetch" href="/assets/js/10.83378578.js"><link rel="prefetch" href="/assets/js/100.dcda4418.js"><link rel="prefetch" href="/assets/js/101.3f002483.js"><link rel="prefetch" href="/assets/js/102.93011a96.js"><link rel="prefetch" href="/assets/js/103.7288a5c6.js"><link rel="prefetch" href="/assets/js/104.8f885d74.js"><link rel="prefetch" href="/assets/js/105.6b3019b7.js"><link rel="prefetch" href="/assets/js/106.2ddf3989.js"><link rel="prefetch" href="/assets/js/107.b7bef053.js"><link rel="prefetch" href="/assets/js/108.2ad33fac.js"><link rel="prefetch" href="/assets/js/109.72abead6.js"><link rel="prefetch" href="/assets/js/11.279ca8e2.js"><link rel="prefetch" href="/assets/js/110.4114438c.js"><link rel="prefetch" href="/assets/js/111.55ff9cad.js"><link rel="prefetch" href="/assets/js/112.9afb3e2d.js"><link rel="prefetch" href="/assets/js/113.fe55a09e.js"><link rel="prefetch" href="/assets/js/114.2d7b1c8b.js"><link rel="prefetch" href="/assets/js/115.f538cdf8.js"><link rel="prefetch" href="/assets/js/116.bd5b4011.js"><link rel="prefetch" href="/assets/js/117.e12a9fbf.js"><link rel="prefetch" href="/assets/js/118.f513f593.js"><link rel="prefetch" href="/assets/js/119.760ef2ca.js"><link rel="prefetch" href="/assets/js/12.7bb4f7bb.js"><link rel="prefetch" href="/assets/js/120.0be976db.js"><link rel="prefetch" href="/assets/js/121.d5cedafb.js"><link rel="prefetch" href="/assets/js/122.8dff3a57.js"><link rel="prefetch" href="/assets/js/123.bdff3bcb.js"><link rel="prefetch" href="/assets/js/124.bb513256.js"><link rel="prefetch" href="/assets/js/125.de1e04a4.js"><link rel="prefetch" href="/assets/js/126.1979b4ba.js"><link rel="prefetch" href="/assets/js/127.3b445fcd.js"><link rel="prefetch" href="/assets/js/128.fde84ac4.js"><link rel="prefetch" href="/assets/js/129.5fdca64d.js"><link rel="prefetch" href="/assets/js/13.845b3ac4.js"><link rel="prefetch" href="/assets/js/130.aacd2cdb.js"><link rel="prefetch" href="/assets/js/131.174c03f0.js"><link rel="prefetch" href="/assets/js/132.dc402607.js"><link rel="prefetch" href="/assets/js/133.71b40ea8.js"><link rel="prefetch" href="/assets/js/134.d6af2ba1.js"><link rel="prefetch" href="/assets/js/135.031ac685.js"><link rel="prefetch" href="/assets/js/136.79fa1a1e.js"><link rel="prefetch" href="/assets/js/137.d48f478a.js"><link rel="prefetch" href="/assets/js/138.7e763317.js"><link rel="prefetch" href="/assets/js/139.77214828.js"><link rel="prefetch" href="/assets/js/14.d492bd0f.js"><link rel="prefetch" href="/assets/js/140.3d3f94c2.js"><link rel="prefetch" href="/assets/js/141.b71bc8c6.js"><link rel="prefetch" href="/assets/js/142.837769b4.js"><link rel="prefetch" href="/assets/js/143.a934de75.js"><link rel="prefetch" href="/assets/js/144.5b723479.js"><link rel="prefetch" href="/assets/js/145.9382ab60.js"><link rel="prefetch" href="/assets/js/146.da6f9125.js"><link rel="prefetch" href="/assets/js/147.e3e6894e.js"><link rel="prefetch" href="/assets/js/148.aba3ae3a.js"><link rel="prefetch" href="/assets/js/149.273acb61.js"><link rel="prefetch" href="/assets/js/15.97374dd5.js"><link rel="prefetch" href="/assets/js/150.1537541e.js"><link rel="prefetch" href="/assets/js/16.d5fadb1f.js"><link rel="prefetch" href="/assets/js/17.85070bd8.js"><link rel="prefetch" href="/assets/js/18.1cff6c24.js"><link rel="prefetch" href="/assets/js/19.142e1664.js"><link rel="prefetch" href="/assets/js/20.6aa700a9.js"><link rel="prefetch" href="/assets/js/21.f79562fe.js"><link rel="prefetch" href="/assets/js/22.c36f814f.js"><link rel="prefetch" href="/assets/js/23.3fc4b8f0.js"><link rel="prefetch" href="/assets/js/24.ff0bd2fa.js"><link rel="prefetch" href="/assets/js/25.a364ffe9.js"><link rel="prefetch" href="/assets/js/26.4d190cda.js"><link rel="prefetch" href="/assets/js/27.f7273c62.js"><link rel="prefetch" href="/assets/js/29.d8f4cc81.js"><link rel="prefetch" href="/assets/js/3.5bcf211a.js"><link rel="prefetch" href="/assets/js/30.94b3175d.js"><link rel="prefetch" href="/assets/js/31.4e810261.js"><link rel="prefetch" href="/assets/js/32.ab295dfc.js"><link rel="prefetch" href="/assets/js/33.720c5bbd.js"><link rel="prefetch" href="/assets/js/34.789ca12e.js"><link rel="prefetch" href="/assets/js/35.2b42f8e4.js"><link rel="prefetch" href="/assets/js/36.fba2560a.js"><link rel="prefetch" href="/assets/js/37.d9363eaf.js"><link rel="prefetch" href="/assets/js/38.059132ee.js"><link rel="prefetch" href="/assets/js/39.0b03c921.js"><link rel="prefetch" href="/assets/js/4.1e8ca44e.js"><link rel="prefetch" href="/assets/js/40.c1393e87.js"><link rel="prefetch" href="/assets/js/41.04c6038d.js"><link rel="prefetch" href="/assets/js/42.905da8ae.js"><link rel="prefetch" href="/assets/js/43.19649e28.js"><link rel="prefetch" href="/assets/js/44.94776414.js"><link rel="prefetch" href="/assets/js/45.3ba157f9.js"><link rel="prefetch" href="/assets/js/46.8687d0eb.js"><link rel="prefetch" href="/assets/js/47.aff2b61b.js"><link rel="prefetch" href="/assets/js/48.dc9554ed.js"><link rel="prefetch" href="/assets/js/49.37da269e.js"><link rel="prefetch" href="/assets/js/5.50ebf2b0.js"><link rel="prefetch" href="/assets/js/50.61cbf8e3.js"><link rel="prefetch" href="/assets/js/51.b4b41ad6.js"><link rel="prefetch" href="/assets/js/52.63b36668.js"><link rel="prefetch" href="/assets/js/53.96aace2f.js"><link rel="prefetch" href="/assets/js/54.58c1c613.js"><link rel="prefetch" href="/assets/js/55.d9ffd6d6.js"><link rel="prefetch" href="/assets/js/56.86ca51c4.js"><link rel="prefetch" href="/assets/js/57.84653a3c.js"><link rel="prefetch" href="/assets/js/58.71b16290.js"><link rel="prefetch" href="/assets/js/59.75f73182.js"><link rel="prefetch" href="/assets/js/6.b72a56bb.js"><link rel="prefetch" href="/assets/js/60.257187e5.js"><link rel="prefetch" href="/assets/js/61.e593a701.js"><link rel="prefetch" href="/assets/js/62.5a57fa28.js"><link rel="prefetch" href="/assets/js/63.72e4ec3c.js"><link rel="prefetch" href="/assets/js/64.251500bf.js"><link rel="prefetch" href="/assets/js/65.13440155.js"><link rel="prefetch" href="/assets/js/66.b3f22aae.js"><link rel="prefetch" href="/assets/js/67.d643eaeb.js"><link rel="prefetch" href="/assets/js/68.1391041a.js"><link rel="prefetch" href="/assets/js/69.f076f69f.js"><link rel="prefetch" href="/assets/js/7.97328cfb.js"><link rel="prefetch" href="/assets/js/70.21d1fa26.js"><link rel="prefetch" href="/assets/js/71.a3d3f1cd.js"><link rel="prefetch" href="/assets/js/72.03370bd4.js"><link rel="prefetch" href="/assets/js/73.a5e6fbb3.js"><link rel="prefetch" href="/assets/js/74.3ed5a665.js"><link rel="prefetch" href="/assets/js/75.15c05bc2.js"><link rel="prefetch" href="/assets/js/76.cf457c63.js"><link rel="prefetch" href="/assets/js/77.b62b05f7.js"><link rel="prefetch" href="/assets/js/78.95a748e7.js"><link rel="prefetch" href="/assets/js/79.fec1765f.js"><link rel="prefetch" href="/assets/js/8.596f1de1.js"><link rel="prefetch" href="/assets/js/80.fc3ac8ab.js"><link rel="prefetch" href="/assets/js/81.b35c265f.js"><link rel="prefetch" href="/assets/js/82.ffbae7df.js"><link rel="prefetch" href="/assets/js/83.2c1a7eea.js"><link rel="prefetch" href="/assets/js/84.e36356eb.js"><link rel="prefetch" href="/assets/js/85.3341d558.js"><link rel="prefetch" href="/assets/js/86.92e9c8e8.js"><link rel="prefetch" href="/assets/js/87.32878110.js"><link rel="prefetch" href="/assets/js/88.ddffedd6.js"><link rel="prefetch" href="/assets/js/89.0715a479.js"><link rel="prefetch" href="/assets/js/9.ae816606.js"><link rel="prefetch" href="/assets/js/90.14e64fc9.js"><link rel="prefetch" href="/assets/js/91.cbdc1e1b.js"><link rel="prefetch" href="/assets/js/92.3726c36e.js"><link rel="prefetch" href="/assets/js/93.9b6ae4dd.js"><link rel="prefetch" href="/assets/js/94.cf9dd272.js"><link rel="prefetch" href="/assets/js/95.dc1f3866.js"><link rel="prefetch" href="/assets/js/96.e8b2265d.js"><link rel="prefetch" href="/assets/js/97.3c6e04b7.js"><link rel="prefetch" href="/assets/js/98.ecfbcf5d.js"><link rel="prefetch" href="/assets/js/99.516d8b9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.844a2aa8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/de/" class="home-link router-link-active"><img src="/ibax.ico" alt="IBAX Dokumentation" class="logo"> <span class="site-name can-hide">IBAX Dokumentation</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/de/concepts/about-the-platform.html" class="nav-link">
  Konzept
</a></div><div class="nav-item"><a href="/de/tutorials/app_tutorial.html" class="nav-link">
  Lernprogramm
</a></div><div class="nav-item"><a href="/de/topics/script.html" class="nav-link">
  Handbuch
</a></div><div class="nav-item"><a href="/de/reference/api2.html" class="nav-link">
  Referenz
</a></div><div class="nav-item"><a href="/de/howtos/deployment.html" class="nav-link">
  Einsatz
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Sprache auswÃ¤hlen" class="dropdown-title"><span class="title">Sprachen</span> <span class="arrow down"></span></button> <button type="button" aria-label="Sprache auswÃ¤hlen" class="mobile-dropdown-title"><span class="title">Sprachen</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/topics/vm.html" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/de/topics/vm.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Deutsch
</a></li><li class="dropdown-item"><!----> <a href="/es/topics/vm.html" class="nav-link">
  EspaÃ±ol
</a></li><li class="dropdown-item"><!----> <a href="/fr/topics/vm.html" class="nav-link">
  FranÃ§ais
</a></li><li class="dropdown-item"><!----> <a href="/it/topics/vm.html" class="nav-link">
  Italiano
</a></li><li class="dropdown-item"><!----> <a href="/ja/topics/vm.html" class="nav-link">
  æ¥æ¬èª
</a></li><li class="dropdown-item"><!----> <a href="/zh-CN/topics/vm.html" class="nav-link">
  ç®ä½ä¸­æ
</a></li><li class="dropdown-item"><!----> <a href="/tr-TR/topics/vm.html" class="nav-link">
  TÃ¼rkÃ§e
</a></li></ul></div></div> <a href="https://github.com/IBAX-io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/de/concepts/about-the-platform.html" class="nav-link">
  Konzept
</a></div><div class="nav-item"><a href="/de/tutorials/app_tutorial.html" class="nav-link">
  Lernprogramm
</a></div><div class="nav-item"><a href="/de/topics/script.html" class="nav-link">
  Handbuch
</a></div><div class="nav-item"><a href="/de/reference/api2.html" class="nav-link">
  Referenz
</a></div><div class="nav-item"><a href="/de/howtos/deployment.html" class="nav-link">
  Einsatz
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Sprache auswÃ¤hlen" class="dropdown-title"><span class="title">Sprachen</span> <span class="arrow down"></span></button> <button type="button" aria-label="Sprache auswÃ¤hlen" class="mobile-dropdown-title"><span class="title">Sprachen</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/topics/vm.html" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/de/topics/vm.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Deutsch
</a></li><li class="dropdown-item"><!----> <a href="/es/topics/vm.html" class="nav-link">
  EspaÃ±ol
</a></li><li class="dropdown-item"><!----> <a href="/fr/topics/vm.html" class="nav-link">
  FranÃ§ais
</a></li><li class="dropdown-item"><!----> <a href="/it/topics/vm.html" class="nav-link">
  Italiano
</a></li><li class="dropdown-item"><!----> <a href="/ja/topics/vm.html" class="nav-link">
  æ¥æ¬èª
</a></li><li class="dropdown-item"><!----> <a href="/zh-CN/topics/vm.html" class="nav-link">
  ç®ä½ä¸­æ
</a></li><li class="dropdown-item"><!----> <a href="/tr-TR/topics/vm.html" class="nav-link">
  TÃ¼rkÃ§e
</a></li></ul></div></div> <a href="https://github.com/IBAX-io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Handbuch</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/de/topics/templates2.html" class="sidebar-link">Vorlagensprache</a></li><li><a href="/de/topics/vm.html" aria-current="page" class="active sidebar-link">Compiler und virtuelle Maschine</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/de/topics/vm.html#speicherung-und-kompilierung-des-quellcodes" class="sidebar-link">Speicherung und Kompilierung des Quellcodes</a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#strukturen-virtueller-maschinen" class="sidebar-link">Strukturen virtueller Maschinen</a></li><li class="sidebar-sub-header"><a href="/de/topics/vm.html#befehle-fur-virtuelle-maschinen" class="sidebar-link">Befehle fÃ¼r virtuelle Maschinen</a></li></ul></li><li><a href="/de/topics/script.html" class="sidebar-link">Intelligente VertrÃ¤ge</a></li><li><a href="/de/topics/daemons.html" class="sidebar-link">DÃ¤mon</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="compiler-und-virtuelle-maschine"><a href="#compiler-und-virtuelle-maschine" class="header-anchor">#</a> Compiler und virtuelle Maschine</h1> <ul><li><a href="#source-code-storage-and-compilation">Speicherung und Kompilierung des Quellcodes</a></li> <li><a href="#virtual-machine-structures">Strukturen virtueller Maschinen</a> <ul><li><a href="#vm-Struktur">VM-Struktur</a></li> <li><a href="#Blockstruktur">Blockstruktur</a></li> <li><a href="#objinfo-Struktur">ObjInfo-Struktur</a> <ul><li><a href="#contractinfo-Struktur">ContractInfo-Struktur</a></li> <li><a href="#fieldinfo-Struktur">FieldInfo-Struktur</a></li> <li><a href="#funcinfo-Struktur">FuncInfo-Struktur</a></li> <li><a href="#Funktionsname-Struktur">Funktionsname-Struktur</a></li> <li><a href="#extfuncinfo-Struktur">ExtFuncInfo-Struktur</a></li> <li><a href="#varinfo-Struktur">VarInfo-Struktur</a></li> <li><a href="#objextend-Wert">ObjExtend-Wert</a></li></ul></li></ul></li> <li><a href="#virtual-machine-commands">Befehle fÃ¼r virtuelle Maschinen</a> <ul><li><a href="#Bytecode-Struktur">ByteCode-Struktur</a></li> <li><a href="#Befehlskennungen">Befehlskennungen</a></li> <li><a href="#stack-operation-commands">Befehle fÃ¼r Stapeloperationen</a></li> <li><a href="#runtime-structure">Laufzeitstruktur</a> <ul><li><a href="#blockstack-Struktur">blockStack-Struktur</a></li></ul></li> <li>[RunCode-Funktion] (#runcode-Funktion)</li> <li><a href="#other-functions-for-operations-with-vm">Andere Funktionen fÃ¼r Operationen mit VM</a></li></ul></li> <li><a href="#Compiler">Compiler</a></li> <li><a href="#lexical-analyzer">Lexikalanalyse</a> <ul><li><a href="#lextable-lextable-go">lextable/lextable.go</a></li> <li><a href="#lex-go">lex.go</a></li></ul></li> <li><a href="#Nadelsprache">Nadelsprache</a> <ul><li><a href="#lexeme">Lexeme</a></li> <li><a href="#Typen">Typen</a></li> <li><a href="#Ausdr%C3%BCcke">AusdrÃ¼cke</a></li> <li><a href="#Bereich">Bereich</a></li> <li><a href="#Vertragsausf%C3%BChrung">VertragsausfÃ¼hrung</a></li> <li><a href="#backus-naur-Form-bnf">Backus-Naur-Form (BNF)</a></li></ul></li></ul> <p>Dieser Abschnitt umfasst Programmkompilierung und Needle-Language-Operationen in der virtuellen Maschine (VM).</p> <h2 id="speicherung-und-kompilierung-des-quellcodes"><a href="#speicherung-und-kompilierung-des-quellcodes" class="header-anchor">#</a> Speicherung und Kompilierung des Quellcodes</h2> <p>VertrÃ¤ge und Funktionen werden mit Golang geschrieben und in den Vertragstabellen von Ãkosystemen gespeichert.</p> <p>Wenn ein Vertrag ausgefÃ¼hrt wird, wird sein Quellcode aus der Datenbank gelesen und in Bytecode kompiliert.</p> <p>Wenn ein Vertrag geÃ¤ndert wird, wird sein Quellcode aktualisiert und in der Datenbank gespeichert. Dann wird der Quellcode kompiliert, wodurch der Bytecode in der entsprechenden virtuellen Maschine aktualisiert wird.</p> <p>Da Bytecodes nicht physikalisch gespeichert werden, werden sie bei einer erneuten ProgrammausfÃ¼hrung neu kompiliert.</p> <p>Der gesamte in der Vertragstabelle jedes Ãkosystems beschriebene Quellcode wird in einer strengen Reihenfolge in eine virtuelle Maschine kompiliert, und der Status der virtuellen Maschine ist auf allen Knoten gleich.</p> <p>Beim Vertragsaufruf Ã¤ndert die virtuelle Maschine ihren Status in keiner Weise. Die AusfÃ¼hrung eines Vertrages oder das Aufrufen einer Funktion erfolgt auf einem separaten laufenden Stack, der wÃ¤hrend jedes externen Aufrufs erstellt wird.</p> <p>Jedes Ãkosystem kann ein sogenanntes virtuelles Ãkosystem haben, das innerhalb eines Knotens in Verbindung mit Tabellen auÃerhalb der Blockchain verwendet werden kann, ohne direkten Einfluss auf die Blockchain oder andere virtuelle Ãkosysteme. In diesem Fall erstellt der Knoten, der ein solches virtuelles Ãkosystem hostet, seinen Vertrag und erstellt seine eigene virtuelle Maschine.</p> <h2 id="strukturen-virtueller-maschinen"><a href="#strukturen-virtueller-maschinen" class="header-anchor">#</a> Strukturen virtueller Maschinen</h2> <h3 id="vm-struktur"><a href="#vm-struktur" class="header-anchor">#</a> VM-Struktur</h3> <p>Eine virtuelle Maschine ist im Arbeitsspeicher als Struktur wie unten organisiert.</p> <div class="language- extra-class"><pre class="language-text"><code>type VM struct {
   Block
   ExtCost func(string) int64
   FuncCallsDB map[string]struct{}
   Extern bool
   ShiftContract int64
   logger *log.Entry
}
</code></pre></div><p>Eine VM-Struktur hat die folgenden Elemente:</p> <ul><li>Block - enthÃ¤lt eine [Blockstruktur] (#block-structure);</li> <li>ExtCost - eine Funktion gibt die Kosten fÃ¼r die AusfÃ¼hrung einer externen Golang-Funktion zurÃ¼ck;</li> <li>FuncCallsDB - eine Sammlung von Golang-Funktionsnamen. Diese Funktion gibt die AusfÃ¼hrungskosten als ersten Parameter zurÃ¼ck. Diese Funktionen verwenden EXPLAIN, um die Kosten der Datenbankverarbeitung zu berechnen;</li> <li>Extern â ein Boolesches Flag, das angibt, ob ein Vertrag ein externer Vertrag ist. Es wird auf âtrueâ gesetzt, wenn eine VM erstellt wird. Aufgerufene VertrÃ¤ge werden beim Kompilieren des Codes nicht angezeigt. Mit anderen Worten, es ermÃ¶glicht, den in Zukunft festgelegten Vertragscode aufzurufen;</li> <li>Schichtvertrag â ID des ersten Vertrags in der VM;</li> <li>logger - Ausgabe des VM-Fehlerprotokolls.</li></ul> <h3 id="blockstruktur"><a href="#blockstruktur" class="header-anchor">#</a> Blockstruktur</h3> <p>Eine virtuelle Maschine ist ein Baum, der aus <strong>Blocktyp</strong>-Objekten besteht.</p> <p>Ein Block ist eine unabhÃ¤ngige Einheit, die einige Bytecodes enthÃ¤lt. Einfach ausgedrÃ¼ckt ist alles, was Sie in der Sprache in die geschweiften Klammern (<code>{}</code>) setzen, ein Block.</p> <p>Der folgende Code wÃ¼rde beispielsweise einen Block mit Funktionen erstellen. Dieser Block enthÃ¤lt auch einen weiteren Block mit einer if-Anweisung, der wiederum einen Block mit einer while-Anweisung enthÃ¤lt.</p> <div class="language- extra-class"><pre class="language-text"><code>func my() {
   if true {
      while false {
      ...
      }
   }
}
</code></pre></div><p>Der Block ist im Speicher als Struktur wie unten organisiert.</p> <div class="language- extra-class"><pre class="language-text"><code>type Block struct {
   Objects map[string]*ObjInfo
   Type int
   Owner *OwnerInfo
   Info interface{}
   Parent *Block
   Vars []reflect.Type
   Code ByteCodes
   Children Blocks
}
</code></pre></div><p>Eine Blockstruktur besteht aus folgenden Elementen:</p> <ul><li><strong>Objekte</strong> - eine Abbildung interner Objekte des Zeigertyps <a href="#objInfo-Struktur">ObjInfo</a>. Wenn der Block beispielsweise eine Variable enthÃ¤lt, kÃ¶nnen Sie anhand ihres Namens Informationen darÃ¼ber erhalten.</li> <li><strong>Typ</strong> - der Typ des Blocks. Bei einem Funktionsblock ist sein Typ <strong>ObjFunc</strong>; fÃ¼r einen Vertragsblock ist sein Typ <strong>ObjContract</strong>;</li> <li><strong>EigentÃ¼mer</strong> â eine Struktur vom Zeigertyp <strong>EigentÃ¼merinfo</strong>. Diese Struktur enthÃ¤lt Informationen Ã¼ber den EigentÃ¼mer des kompilierten Vertrags, der wÃ¤hrend der Vertragserstellung angegeben oder aus der Tabelle <strong>VertrÃ¤ge</strong> erhalten wird;</li> <li><strong>Info</strong> - enthÃ¤lt Informationen Ã¼ber das Objekt, die vom Blocktyp abhÃ¤ngen;</li> <li><strong>Parent</strong> â ein Zeiger auf den Elternblock;</li> <li><strong>Vars</strong> - ein Array, das die Typen der aktuellen Blockvariablen enthÃ¤lt;</li> <li><strong>Code</strong> - der Bytecode des Blocks selbst, der ausgefÃ¼hrt wird, wenn die Kontrollrechte an den Block Ã¼bergeben werden, zum Beispiel Funktionsaufrufe oder SchleifenkÃ¶rper;</li> <li><strong>Children</strong> - ein Array mit UnterblÃ¶cken, wie z. B. Funktionsverschachtelung, Schleifen, bedingte Operatoren.</li></ul> <h3 id="objinfo-struktur"><a href="#objinfo-struktur" class="header-anchor">#</a> ObjInfo-Struktur</h3> <p>Die ObjInfo-Struktur enthÃ¤lt Informationen Ã¼ber interne Objekte.</p> <div class="language- extra-class"><pre class="language-text"><code>type ObjInfo struct {
   Type int
   Value interface{}
}
</code></pre></div><p>Die ObjInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Typ</strong> ist der Objekttyp, der einen der folgenden Werte hat:
<ul><li><strong>ObjContract</strong> â <a href="#contractInfo-Struktur">Vertrag</a>;</li> <li><strong>ObjFunc</strong> - Funktion;</li> <li><strong>ObjExtFunc</strong> - externe Golang-Funktion;</li> <li><strong>ObjVar</strong> - Variable;</li> <li><strong>ObjExtend</strong> - $name-Variable.</li></ul></li> <li><strong>Wert</strong> â enthÃ¤lt die Struktur jedes Typs.</li></ul> <h4 id="contractinfo-struktur"><a href="#contractinfo-struktur" class="header-anchor">#</a> ContractInfo-Struktur</h4> <p>Zeigt auf den Typ <strong>ObjContract</strong>, und das Feld <strong>Value</strong> enthÃ¤lt eine <strong>ContractInfo</strong>-Struktur.</p> <div class="language- extra-class"><pre class="language-text"><code>type ContractInfo struct {
   ID uint32
   Name string
   Owner *OwnerInfo
   Used map[string]bool
   Tx *[]*FieldInfo
}
</code></pre></div><p>Die ContractInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>ID</strong> - Vertrags-ID, die beim Aufruf des Vertrags in der Blockchain angezeigt wird;</li> <li><strong>Name</strong> - Vertragsname;</li> <li><strong>EigentÃ¼mer</strong> - andere Informationen zum Vertrag;</li> <li><strong>Verwendet</strong> - Karte der aufgerufenen Vertragsnamen;</li> <li><strong>Tx</strong> â ein Datenarray, das im <a href="/de/topics/script.html#data-section">Datenabschnitt</a> des Vertrags beschrieben wird.</li></ul> <h4 id="fieldinfo-struktur"><a href="#fieldinfo-struktur" class="header-anchor">#</a> FieldInfo-Struktur</h4> <p>Die FieldInfo-Struktur wird in der <strong>ContractInfo</strong>-Struktur verwendet und beschreibt Elemente im <a href="/de/topics/script.html#data-section">Datenabschnitt</a> eines Vertrags.</p> <div class="language- extra-class"><pre class="language-text"><code>type FieldInfo struct {
   Name string
   Type reflect.Type
   Original uint32
   Tags string
}
</code></pre></div><p>Die FieldInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Name</strong> - Feldname;</li> <li><strong>Typ</strong> - Feldtyp;</li> <li><strong>Original</strong> - optionales Feld;</li> <li><strong>Tags</strong> - zusÃ¤tzliche Beschriftungen fÃ¼r dieses Feld.</li></ul> <h4 id="funcinfo-struktur"><a href="#funcinfo-struktur" class="header-anchor">#</a> FuncInfo-Struktur</h4> <p>Zeigt auf den ObjFunc-Typ, und das Value-Feld enthÃ¤lt eine FuncInfo-Struktur.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncInfo struct {
   Params []reflect.Type
   Results []reflect.Type
   Names *map[string]FuncName
   Variadic bool
   ID uint32
}
</code></pre></div><p>Die FuncInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Params</strong> - ein Array von Parametertypen;</li> <li><strong>Ergebnisse</strong> - ein Array zurÃ¼ckgegebener Typen;</li> <li><strong>Namen</strong> - Abbildung von Daten fÃ¼r Tail-Funktionen, zum Beispiel <code>DBFind().Columns ()</code>;</li> <li><strong>Variadic</strong> - wahr, wenn die Funktion eine variable Anzahl von Parametern haben kann;</li> <li><strong>ID</strong> - Funktions-ID.</li></ul> <h4 id="funcname-struktur"><a href="#funcname-struktur" class="header-anchor">#</a> FuncName-Struktur</h4> <p>Die Struktur FuncName wird fÃ¼r FuncInfo verwendet und beschreibt die Daten einer Tail-Funktion.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
</code></pre></div><p>Die FuncName-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Params</strong> - ein Array von Parametertypen;</li> <li><strong>Offset</strong> - das Array von Offsets fÃ¼r diese Variablen. TatsÃ¤chlich kÃ¶nnen die Werte aller Parameter in einer Funktion mit dem Punkt . initialisiert werden;</li> <li><strong>Variadic</strong> - true, wenn die Tail-Funktion eine variable Anzahl von Parametern haben kann.</li></ul> <h4 id="extfuncinfo-struktur"><a href="#extfuncinfo-struktur" class="header-anchor">#</a> ExtFuncInfo-Struktur</h4> <p>Zeigt auf den ObjExtFunc-Typ, und das Value-Feld enthÃ¤lt eine ExtFuncInfo-Struktur. Es wird verwendet, um Golang-Funktionen zu beschreiben.</p> <div class="language- extra-class"><pre class="language-text"><code>type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
</code></pre></div><p>Die ExtFuncInfo-Struktur hat die folgenden Elemente:</p> <ul><li>Die Parameter <strong>Name</strong>, <strong>Params</strong>, <strong>Results</strong> haben die gleiche Struktur wie <a href="#funcinfo-structure">FuncInfo</a>;</li> <li><strong>Auto</strong> - ein Array von Variablen. Wird gegebenenfalls als zusÃ¤tzlicher Parameter an die Funktion Ã¼bergeben. Beispielsweise eine Variable vom Typ SmartContract sc;</li> <li><strong>Func</strong> - Golang-Funktionen.</li></ul> <h4 id="varinfo-struktur"><a href="#varinfo-struktur" class="header-anchor">#</a> VarInfo-Struktur</h4> <p>Zeigt auf den Typ <strong>ObjVar</strong>, und das Feld <strong>Value</strong> enthÃ¤lt eine <strong>VarInfo</strong>-Struktur.</p> <div class="language- extra-class"><pre class="language-text"><code>type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
</code></pre></div><p>Die VarInfo-Struktur hat die folgenden Elemente:</p> <ul><li><strong>Obj</strong> - Informationen Ã¼ber Typ und Wert der Variablen;</li> <li><strong>EigentÃ¼mer</strong> - Zeiger auf den EigentÃ¼merblock.</li></ul> <h4 id="objextend-wert"><a href="#objextend-wert" class="header-anchor">#</a> ObjExtend-Wert</h4> <p>Zeigt auf den Typ <strong>ObjExtend</strong>, und das Feld <strong>Value</strong> enthÃ¤lt eine Zeichenfolge, die den Namen der Variablen oder Funktion enthÃ¤lt.</p> <h2 id="befehle-fur-virtuelle-maschinen"><a href="#befehle-fur-virtuelle-maschinen" class="header-anchor">#</a> Befehle fÃ¼r virtuelle Maschinen</h2> <h3 id="bytecode-struktur"><a href="#bytecode-struktur" class="header-anchor">#</a> ByteCode-Struktur</h3> <p>Ein Bytecode ist eine Folge von Strukturen vom Typ <strong>ByteCode</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type ByteCode struct {
   Cmd uint16
   Value interface{}
}
</code></pre></div><p>Diese Struktur hat die folgenden Felder:</p> <ul><li><strong>Cmd</strong> - der Bezeichner der Speicherbefehle;</li> <li><strong>Wert</strong> - enthÃ¤lt den Operanden (Wert).</li></ul> <p>Im Allgemeinen fÃ¼hren Befehle eine Operation auf dem obersten Element des Stapels aus und schreiben bei Bedarf den Ergebniswert hinein.</p> <h3 id="befehlskennungen"><a href="#befehlskennungen" class="header-anchor">#</a> Befehlskennungen</h3> <p>Bezeichner der Befehle der virtuellen Maschine sind in der Datei vm/cmds_list.go beschrieben.</p> <ul><li><strong>cmdPush</strong> â legt einen Wert aus dem Value-Feld auf den Stack. Legen Sie zum Beispiel Zahlen und Linien auf den Stapel;</li> <li><strong>cmdVar</strong> - Legt den Wert einer Variablen auf den Stack. Value enthÃ¤lt einen Zeiger auf die VarInfo-Struktur und Informationen Ã¼ber die Variable;</li> <li><strong>cmdExtend</strong> â legt den Wert einer externen Variablen auf den Stack. Wert enthÃ¤lt eine Zeichenfolge mit dem Variablennamen (beginnend mit $);</li> <li><strong>cmdCallExtend</strong> â Aufruf einer externen Funktion (beginnend mit $). Die Parameter der Funktion werden aus dem Stapel abgerufen und die Ergebnisse auf dem Stapel abgelegt. Wert enthÃ¤lt einen Funktionsnamen (beginnend mit $);</li> <li><strong>cmdPushStr</strong> â legt den String in Value auf den Stack;</li> <li><strong>cmdCall</strong> - ruft die Funktion der virtuellen Maschine auf. Wert enthÃ¤lt eine <strong>ObjInfo</strong>-Struktur. Dieser Befehl gilt fÃ¼r die Golang-Funktion <strong>ObjExtFunc</strong> und die Needle-Funktion <strong>ObjFunc</strong>. Wenn eine Funktion aufgerufen wird, werden ihre Parameter vom Stapel abgerufen und die Ergebniswerte werden auf dem Stapel abgelegt;</li> <li><strong>cmdCallVari</strong> - Ãhnlich wie der Befehl <strong>cmdCall</strong> ruft er die Funktion der virtuellen Maschine auf. Dieser Befehl wird verwendet, um eine Funktion mit einer variablen Anzahl von Parametern aufzurufen;</li> <li><strong>cmdReturn</strong> - wird verwendet, um die Funktion zu verlassen. Die RÃ¼ckgabewerte werden auf den Stack gelegt und das Value-Feld wird nicht verwendet;</li> <li><strong>cmdIf</strong> â Ã¼bergibt die Kontrolle an den Bytecode in der Struktur <strong>block</strong>, der im Feld Wert Ã¼bergeben wird. Das Steuerelement wird nur dann auf den Stack Ã¼bertragen, wenn das oberste Element des Stacks von der <em>valueToBool</em>-Funktion aufgerufen und <code>true</code> zurÃ¼ckgegeben wird. Andernfalls wird die Steuerung an den nÃ¤chsten Befehl Ã¼bergeben;</li> <li><strong>cmdElse</strong> - dieser Befehl funktioniert auf die gleiche Weise wie <strong>cmdIf</strong>, aber nur wenn das oberste Element des Stacks von der valueToBool-Funktion aufgerufen und <code>false</code> zurÃ¼ckgegeben wird, wird die Steuerung an die Ã¼bertragen angegebener Block;</li> <li><strong>cmdAssignVar</strong> â erhÃ¤lt eine Liste von Variablen des Typs <strong>VarInfo</strong> von Value. Diese Variablen verwenden den Befehl <strong>cmdAssign</strong>, um den Wert abzurufen;</li> <li><strong>cmdAssign</strong> â weist den Wert im Stack der Variablen zu, die durch den Befehl <strong>cmdAssignVar</strong> erhalten wurde;</li> <li><strong>cmdLabel</strong> - definiert ein Label, wenn die Steuerung wÃ¤hrend der While-Schleife zurÃ¼ckgegeben wird;</li> <li><strong>cmdContinue</strong> - Dieser Befehl Ã¼bertrÃ¤gt die Steuerung an das Label <strong>cmdLabel</strong>. Beim AusfÃ¼hren einer neuen Iteration der Schleife wird Value nicht verwendet;</li> <li><strong>cmdWhile</strong> â Verwenden Sie valueToBool, um das oberste Element des Stapels zu Ã¼berprÃ¼fen. Wenn dieser Wert âtrueâ ist, wird die Struktur <strong>block</strong> aus dem Wertefeld aufgerufen;</li> <li><strong>cmdBreak</strong> - beendet die Schleife;</li> <li><strong>cmdIndex</strong> â legt den Wert in der Map oder im Array nach Index in den Stack, ohne Value zu verwenden. Beispiel: <code>(map | array) (index value) =&gt; (map | array [index value])</code>;</li> <li><strong>cmdSetIndex</strong> â weist den Wert des obersten Elements des Stapels den Elementen der Karte oder des Arrays zu, ohne Value zu verwenden. Beispiel: <code>(map | array) (index value) (value) =&gt; (map | array)</code>;</li> <li><strong>cmdFuncName</strong> - fÃ¼gt Parameter hinzu, die mit sequentiellen Beschreibungen geteilt durch Punkt Ã¼bergeben werden. Beispiel: <code>func name =&gt; Fun (...) .Name (...)</code>;</li> <li><strong>cmdUnwrapArr</strong> - definiert ein boolesches Flag, wenn das oberste Element des Stapels ein Array ist;</li> <li><strong>cmdMapInit</strong> â initialisiert den Wert von map;</li> <li><strong>cmdArrayInit</strong> â initialisiert den Wert des Arrays;</li> <li><strong>cmdError</strong> - Dieser Befehl wird erstellt, wenn ein Vertrag oder eine Funktion mit einem angegebenen <code>error, warning, info</code> beendet wird.</li></ul> <h3 id="stack-operationsbefehle"><a href="#stack-operationsbefehle" class="header-anchor">#</a> Stack-Operationsbefehle</h3> <blockquote><p>Hinweis</p></blockquote> <blockquote><p>In der aktuellen Version ist die automatische Typkonvertierung fÃ¼r diese Befehle nicht vollstÃ¤ndig anwendbar. Zum Beispiel,</p></blockquote> <blockquote><p><code>string + float | int | decimal =&gt; float | int | decimal, float + int | str =&gt; float, but int + string =&gt; runtime error</code>.</p></blockquote> <p>Das Folgende sind Befehle fÃ¼r die direkte Stack-Verarbeitung. Das Feld Wert wird in diesen Befehlen nicht verwendet.</p> <ul><li><strong>cmdNot</strong> - logische Negation. <code>(val) =&gt; (!ValueToBool(val))</code>;</li> <li><strong>cmdSign</strong> - Vorzeichenwechsel. <code>(val) =&gt; (-val)</code>;</li> <li><strong>cmdAdd</strong> - ErgÃ¤nzung. <code>(val1)(val2) =&gt; (val1 + val2)</code>;</li> <li><strong>cmdSub</strong> - Subtraktion. <code>(val1)(val2) =&gt; (val1-val2)</code>;</li> <li><strong>cmdMul</strong> - Multiplikation. <code>(val1)(val2) =&gt; (val1 * val2)</code>;</li> <li><strong>cmdDiv</strong> - Division. <code>(val1)(val2) =&gt; (val1 / val2)</code>;</li> <li><strong>cmdAnd</strong> - logisches UND. <code>(val1)(val2) =&gt; (valueToBool(val1) &amp;&amp; valueToBool(val2))</code>;</li> <li><strong>cmdOr</strong> - logisches ODER. <code>(val1)(val2) =&gt; (valueToBool(val1) || valueToBool(val2))</code>;</li> <li><strong>cmdEqual</strong> - Gleichheitsvergleich, bool wird zurÃ¼ckgegeben. <code>(val1)(val2) =&gt; (val1 == val2)</code>;</li> <li><strong>cmdNotEq</strong> - Ungleichheitsvergleich, bool wird zurÃ¼ckgegeben. <code>(val1)(val2) =&gt; (val1 != val2)</code>;</li> <li><strong>cmdLess</strong> - Kleiner-als-Vergleich, bool wird zurÃ¼ckgegeben. <code>(val1)(val2) =&gt; (val1 &lt;val2)</code>;</li> <li><strong>cmdNotLess</strong> - GrÃ¶Ãer-gleich-Vergleich, bool wird zurÃ¼ckgegeben. <code>(val1)(val2) =&gt; (val1 &gt;= val2)</code>;</li> <li><strong>cmdGreat</strong> - GrÃ¶Ãer-als-Vergleich, bool wird zurÃ¼ckgegeben. <code>(val1)(val2) =&gt; (val1&gt; val2)</code>;</li> <li><strong>cmdNotGreat</strong> - Kleiner-gleich-Vergleich, bool wird zurÃ¼ckgegeben. <code>(val1)(val2) =&gt; (val1 &lt;= val2)</code>.</li></ul> <h3 id="laufzeitstruktur"><a href="#laufzeitstruktur" class="header-anchor">#</a> Laufzeitstruktur</h3> <p>Die AusfÃ¼hrung von Bytecodes wirkt sich nicht auf die virtuelle Maschine aus. Beispielsweise kÃ¶nnen verschiedene Funktionen und VertrÃ¤ge gleichzeitig in einer einzigen virtuellen Maschine ausgefÃ¼hrt werden. Die Runtime-Struktur wird verwendet, um Funktionen und VertrÃ¤ge sowie beliebige AusdrÃ¼cke und Bytecode auszufÃ¼hren.</p> <div class="language- extra-class"><pre class="language-text"><code>type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}
</code></pre></div><ul><li><strong>stack</strong> - der Stack zum AusfÃ¼hren des Bytecodes;</li> <li><strong>blocks</strong> - Stack fÃ¼r Blockaufrufe;</li> <li><strong>vars</strong> - Stapel von Variablen. Seine Variable wird dem Stapel von Variablen hinzugefÃ¼gt, wenn der Bytecode im Block aufgerufen wird. Nach dem Verlassen des Blocks kehrt die GrÃ¶Ãe des Variablenstapels zum vorherigen Wert zurÃ¼ck;</li> <li><strong>extend</strong> - ein Zeiger zum Abbilden mit Werten externer Variablen (<code>$name</code>);</li> <li><strong>vm</strong> - ein Zeiger einer virtuellen Maschine;</li> <li><strong>cost</strong> - Kraftstoffeinheit der resultierenden AusfÃ¼hrungskosten;</li> <li><strong>err</strong> - Fehler wÃ¤hrend der AusfÃ¼hrung aufgetreten.</li></ul> <h4 id="blockstack-struktur"><a href="#blockstack-struktur" class="header-anchor">#</a> blockStack-Struktur</h4> <p>Die blockStack-Struktur wird in der Runtime-Struktur verwendet.</p> <div class="language- extra-class"><pre class="language-text"><code>type blockStack struct {
   Block *Block
   Offset int
}
</code></pre></div><ul><li><strong>Block</strong> â ein Zeiger auf den ausgefÃ¼hrten Block;</li> <li><strong>Offset</strong> â der Offset des letzten ausgefÃ¼hrten Befehls im Bytecode des angegebenen Blocks.</li></ul> <h3 id="runcode-funktion"><a href="#runcode-funktion" class="header-anchor">#</a> RunCode-Funktion</h3> <p>Bytecodes werden in der Funktion <strong>RunCode</strong> ausgefÃ¼hrt. Es enthÃ¤lt eine Schleife, die die entsprechende Operation fÃ¼r jeden Bytecode-Befehl durchfÃ¼hrt. Vor der Verarbeitung eines Bytecodes mÃ¼ssen die erforderlichen Daten initialisiert werden.</p> <p>Neue BlÃ¶cke werden zu anderen BlÃ¶cken hinzugefÃ¼gt.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = append(rt.blocks, &amp;blockStack{block, len(rt.vars)})
</code></pre></div><p>Rufen Sie als NÃ¤chstes die Informationen zu den relevanten Parametern der Tail-Funktion ab. Diese Parameter sind im letzten Element des Stapels enthalten.</p> <div class="language- extra-class"><pre class="language-text"><code>var namemap map[string][]interface{}
if block.Type == ObjFunc &amp;&amp; block.Info.(*FuncInfo).Names != nil {
   if rt.stack[len(rt.stack)-1] != nil {
      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
   }
   rt.stack = rt.stack[:len(rt.stack)-1]
}
</code></pre></div><p>AnschlieÃend mÃ¼ssen alle im aktuellen Block definierten Variablen mit ihren Anfangswerten initialisiert werden.</p> <div class="language- extra-class"><pre class="language-text"><code>start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
   rt.cost--
   var value interface{}
</code></pre></div><p>Da Variablen in der Funktion auch Variablen sind, mÃ¼ssen wir sie vom letzten Element des Stacks in der von der Funktion selbst beschriebenen Reihenfolge abrufen.</p> <div class="language- extra-class"><pre class="language-text"><code>   if block.Type == ObjFunc &amp;&amp; vkey &lt;len(block.Info.(*FuncInfo).Params) {
      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
   } else {
</code></pre></div><p>Lokale Variablen mit ihren Anfangswerten initialisieren.</p> <div class="language- extra-class"><pre class="language-text"><code>      value = reflect.New(vpar).Elem().Interface()

      if vpar == reflect.TypeOf(map[string]interface{}{}) {

         value = make(map[string]interface{})
      } else if vpar == reflect.TypeOf([]interface{}{}) {
         value = make([]interface{}, 0, len(rt.vars)+1)
      }
   }
   rt.vars = append(rt.vars, value)
}
</code></pre></div><p>Aktualisieren Sie als NÃ¤chstes die Werte der variablen Parameter, die in der Tail-Funktion Ã¼bergeben werden.</p> <div class="language- extra-class"><pre class="language-text"><code>if namemap != nil {
   for key, item := range namemap {
      params := (*block.Info.(*FuncInfo).Names)[key]
      for i, value := range item {
         if params.Variadic &amp;&amp; i &gt;= len(params.Params)-1 {
</code></pre></div><p>Wenn Ã¼bergebene variable Parameter zu einer variablen Anzahl von Parametern gehÃ¶ren, werden diese Parameter zu einem Array von Variablen kombiniert.</p> <div class="language- extra-class"><pre class="language-text"><code>            off := varoff + params.Offset[len(params.Params)-1]
            rt.vars[off] = append(rt.vars[off].([]interface{}), value)
         } else {
            rt.vars[varoff+params.Offset[i]] = value
         }
      }
   }
}
</code></pre></div><p>Danach mÃ¼ssen wir nur noch Werte lÃ¶schen, die von der Spitze des Stacks als Funktionsparameter Ã¼bergeben wurden, wodurch der Stack verschoben wird. Wir haben ihre Werte in ein Variablenarray kopiert.</p> <div class="language- extra-class"><pre class="language-text"><code>if block.Type == ObjFunc {
   start -= len(block.Info.(*FuncInfo).Params)
}
</code></pre></div><p>Wenn eine Bytecode-Befehlsschleife beendet ist, mÃ¼ssen wir den Stack korrekt leeren.</p> <div class="language- extra-class"><pre class="language-text"><code>last := rt.blocks[len(rt.blocks)-1]
</code></pre></div><p>LÃ¶schen Sie den aktuellen Block aus dem Blockstapel.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
</code></pre></div><p>Wenn eine bereits ausgefÃ¼hrte Funktion erfolgreich beendet wird, fÃ¼gen wir den RÃ¼ckgabewert am Ende des vorherigen Stacks hinzu.```
if last.Block.Type == ObjFunc {
for count := len(last.Block.Info.(*FuncInfo).Results); count &gt; 0; count-- {
rt.stack[start] = rt.stack[len(rt.stack)-count]
start++
}
status = statusNormal
} else {</p> <div class="language- extra-class"><pre class="language-text"><code>Wie Sie sehen kÃ¶nnen, stellen wir den Stack-Status nicht wieder her und beenden die Funktion unverÃ¤ndert, wenn wir die Funktion nicht ausfÃ¼hren. Der Grund ist, dass Schleifen und bedingte Strukturen, die in der Funktion ausgefÃ¼hrt wurden, ebenfalls Bytecode-BlÃ¶cke sind.
</code></pre></div><p>return</p> <p>}
}</p> <p>rt.stack = rt.stack[:start]</p> <div class="language- extra-class"><pre class="language-text"><code>
### Weitere Funktionen fÃ¼r Operationen mit VM

Mit der Funktion **NewVM** kÃ¶nnen Sie eine virtuelle Maschine erstellen. Jeder virtuellen Maschine werden Ã¼ber die Funktion **Extend** vier Funktionen hinzugefÃ¼gt, z. B. **ExecContract**, **MemoryUsage**, **CallContract** und **Settings**.

</code></pre></div><p>for key, item := range ext.Objects {
fobj := reflect.ValueOf(item).Type()</p> <div class="language- extra-class"><pre class="language-text"><code>
Wir durchlaufen alle Ã¼bergebenen Objekte und betrachten nur die Funktionen.

</code></pre></div><p>switch fobj.Kind() {
case reflect.Func:</p> <div class="language- extra-class"><pre class="language-text"><code>
Wir fÃ¼llen die **ExtFuncInfo**-Struktur gemÃ¤Ã den Ã¼ber die Funktion erhaltenen Informationen und fÃ¼gen ihre Struktur namentlich der Top-Level-Map **Objects** hinzu.

</code></pre></div><p>data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),
make([]string, fobj.NumIn()), fobj.IsVariadic(), item}
for i := 0; i &lt;fobj.NumIn(); i++ {</p> <div class="language- extra-class"><pre class="language-text"><code>Die **ExtFuncInfo**-Struktur hat ein **Auto**-Parameter-Array. Normalerweise ist der erste Parameter `sc *SmartContract` oder `rt *Runtime`, wir kÃ¶nnen sie nicht von der Sprache Needle Ã¼bergeben, da sie fÃ¼r uns notwendig sind, um einige Golang-Funktionen auszufÃ¼hren. Daher legen wir fest, dass diese Variablen automatisch verwendet werden, wenn diese Funktionen aufgerufen werden. In diesem Fall ist der erste Parameter der obigen vier Funktionen `rt *Runtime`.

</code></pre></div><p>if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
data.Auto[i] = isauto
}</p> <div class="language- extra-class"><pre class="language-text"><code>
Informationen zur Parametrierung.
</code></pre></div><div class="language- extra-class"><pre><code>  data.Params[i] = fobj.In(i)
</code></pre></div><p>}</p> <div class="language- extra-class"><pre class="language-text"><code>
Und die Typen der RÃ¼ckgabewerte.
</code></pre></div><p>for i := 0; i &lt;fobj.NumOut(); i++ {
data.Results[i] = fobj.Out(i)
}</p> <div class="language- extra-class"><pre class="language-text"><code>FÃ¼gt eine Funktion zu den **Objekten** des Stammverzeichnisses hinzu, damit der Compiler sie spÃ¤ter finden kann, wenn er den Vertrag verwendet.
</code></pre></div><div class="language- extra-class"><pre><code>  vm.Objects[key] = &amp;ObjInfo{ObjExtFunc, data}
</code></pre></div><p>}</p> <p>}</p> <div class="language- extra-class"><pre class="language-text"><code>
## Compiler

Funktionen in der Datei compile.go sind fÃ¼r das Kompilieren des Token-Arrays verantwortlich, das vom lexikalischen Analysator erhalten wird. Die Zusammenstellung kann bedingt in zwei Ebenen unterteilt werden. Auf der obersten Ebene beschÃ¤ftigen wir uns mit Funktionen, VertrÃ¤gen, CodeblÃ¶cken, Bedingungs- und Schleifenanweisungen, Variablendefinitionen und so weiter. Auf der unteren Ebene kompilieren wir AusdrÃ¼cke in CodeblÃ¶cke oder Bedingungen in Schleifen und bedingte Anweisungen.

ZunÃ¤chst beginnen wir mit der einfachen unteren Ebene. In der Funktion **compileEval** kÃ¶nnen AusdrÃ¼cke in Bytecode umgewandelt werden. Da wir eine virtuelle Maschine mit einem Stack verwenden, ist es notwendig, gewÃ¶hnliche Infix-Record-AusdrÃ¼cke in Postfix-Notation oder umgekehrte polnische Notation umzuwandeln. Zum Beispiel wandeln wir â1+2â in â12+â um und legen â1â und â2â auf den Stack. Dann wenden wir die Additionsoperation auf die letzten beiden Elemente im Stack an und schreiben das Ergebnis in den Stack. Sie finden diesen [Konvertierungs-](https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/) Algorithmus im Internet.

Die globale Variable âopers = map [uint32] operPriorâ enthÃ¤lt die PrioritÃ¤t der Operationen, die fÃ¼r die Konvertierung in die inverse polnische Notation erforderlich sind.

Die folgenden Variablen werden am Anfang der Funktion **compileEval** definiert:
* **Puffer** - temporÃ¤rer Puffer fÃ¼r Bytecode-Befehle;
* **Bytecode** - letzter Puffer von Bytecode-Befehlen;
* **parcount** - temporÃ¤rer Puffer, der zum Berechnen von Parametern beim Aufrufen einer Funktion verwendet wird;
* **setIndex** - Variablen im Arbeitsprozess werden auf true gesetzt, wenn wir Map- oder Array-Elemente zuweisen. Beispiel: `a[&quot;my&quot;] = 10`. In diesem Fall mÃ¼ssen wir den angegebenen Befehl **cmdSetIndex** verwenden.

Wir erhalten ein Token in einer Schleife und verarbeiten es entsprechend. Beispielsweise wird die Ausdruckstrennung gestoppt, wenn geschweiften Klammern gefunden werden. Beim Verschieben der Zeichenfolge prÃ¼fen wir, ob die vorherige Anweisung eine Operation ist und ob sie innerhalb der Klammern steht, andernfalls wird der Ausdruck beendet und analysiert.

</code></pre></div><p>case isRCurly, isLCurly:
i--
if prevLex == isComma || prevLex == lexOper {
return errEndExp
}
break main
case lexNewLine:
if i &gt; 0 &amp;&amp; ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {
continue main
}
for k := len(buffer) - 1; k &gt;= 0; k-- {
if buffer[k].Cmd == cmdSys {
continue main
}
}
break main</p> <div class="language- extra-class"><pre class="language-text"><code>Im Allgemeinen entspricht der Algorithmus selbst einem Algorithmus zum Umwandeln in die inverse polnische Notation. Unter BerÃ¼cksichtigung des Aufrufs notwendiger VertrÃ¤ge, Funktionen und Indizes sowie anderer Dinge, die beim Parsing nicht vorkommen, und Optionen zum Parsing von Token vom Typ lexIdent werden dann Variablen, Funktionen oder VertrÃ¤ge mit diesem Namen Ã¼berprÃ¼ft. Wenn nichts gefunden wird und es sich nicht um einen Funktions- oder Vertragsaufruf handelt, wird ein Fehler angezeigt.

</code></pre></div><p>objInfo, tobj := vm.findObj(lexem.Value.(string), block)
if objInfo == nil &amp;&amp; (!vm.Extern || i&gt; *ind || i &gt;= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {
return fmt.Errorf(<code>unknown identifier %s</code>, lexem.Value.(string))
}</p> <div class="language- extra-class"><pre class="language-text"><code>
Wir kÃ¶nnen auf eine solche Situation stoÃen, und der Vertragsaufruf wird spÃ¤ter beschrieben. Wenn in diesem Beispiel keine Funktionen oder Variablen mit demselben Namen gefunden werden, halten wir es fÃ¼r notwendig, einen Vertrag aufzurufen. In dieser kompilierten Sprache gibt es keinen Unterschied zwischen VertrÃ¤gen und Funktionsaufrufen. Aber wir mÃ¼ssen den Vertrag Ã¼ber die Funktion **ExecContract** aufrufen, die im Bytecode verwendet wird.
</code></pre></div><p>if objInfo.Type == ObjContract {
if objInfo.Value != nil {
objContract = objInfo.Value.(*Block)
}
objInfo, tobj = vm.findObj(<code>ExecContract</code>, block)
isContract = true
}</p> <div class="language- extra-class"><pre class="language-text"><code>Die Anzahl der bisherigen Variablen erfassen wir in `count`, die zusammen mit der Anzahl der Funktionsparameter auch auf den Stack geschrieben werden. Bei jeder weiteren Erkennung von Parametern mÃ¼ssen wir diese Zahl nur am letzten Element des Stapels um eine Einheit erhÃ¶hen.


</code></pre></div><p>count := 0
if (*lexems)[i+2].Type != isRPar {
count++
}</p> <div class="language- extra-class"><pre class="language-text"><code>Wir haben eine Liste mit aufgerufenen Parametern fÃ¼r VertrÃ¤ge verwendet, dann mÃ¼ssen wir den Fall markieren, in dem der Vertrag aufgerufen wird. Wenn der Vertrag ohne Parameter aufgerufen wird, mÃ¼ssen wir zwei leere Parameter hinzufÃ¼gen, um **ExecContract** aufzurufen, um mindestens zwei Parameter zu erhalten.
</code></pre></div><p>if isContract {
name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))
for j := len(*block) - 1; j &gt;= 0; j-- {
topblock := (*block)[j]
if topblock.Type == ObjContract {
if topblock.Info.(*ContractInfo).Used == nil {
topblock.Info.(*ContractInfo).Used = make(map[string]bool)
}
topblock.Info.(*ContractInfo).Used[name] = true
}
}
bytecode = append(bytecode, &amp;ByteCode{cmdPush, name})
if count == 0 {
count = 2
bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
}
count++
}</p> <div class="language- extra-class"><pre class="language-text"><code>
Wenn wir sehen, dass als nÃ¤chstes eine eckige Klammer steht, fÃ¼gen wir den Befehl **cmdIndex** hinzu, um den Wert durch den Index zu erhalten.
</code></pre></div><p>if (*lexems)[i+1].Type == isLBrack {
if objInfo == nil || objInfo.Type != ObjVar {
return fmt.Errorf(<code>unknown variable %s</code>, lexem.Value.(string))
}
buffer = append(buffer, &amp;ByteCode{cmdIndex, 0})
}</p> <div class="language- extra-class"><pre class="language-text"><code>Die Funktion **CompileBlock** kann ObjektbÃ¤ume und ausdrucksunabhÃ¤ngige Bytecodes generieren. Der Kompilierungsprozess basiert auf einer endlichen Zustandsmaschine, genau wie ein lexikalischer Analysator, aber mit den folgenden Unterschieden. Erstens verwenden wir keine Symbole, sondern Tokens; zweitens werden wir gleich die *states*-Variablen in allen ZustÃ¤nden und ÃbergÃ¤ngen beschreiben. Es stellt ein Array von Objekten dar, die nach Tokentyp indiziert sind. Jedes Token hat eine Struktur von *compileState*, und ein neuer Status wird in *NewState* angegeben. Wenn klar ist, welche Struktur wir aufgelÃ¶st haben, kÃ¶nnen wir die Funktion des Handlers im Feld *Func* angeben.

Betrachten wir den Hauptzustand als Beispiel.

Wenn wir auf einen Zeilenumbruch oder einen Kommentar stoÃen, bleiben wir im selben Zustand. Wenn wir auf das SchlÃ¼sselwort **contract** stoÃen, Ã¤ndern wir den Status in *stateContract* und beginnen mit dem Parsen der Struktur. Wenn wir auf das SchlÃ¼sselwort **func** stoÃen, Ã¤ndern wir den Status in *stateFunc*. Wenn andere Token empfangen werden, wird die Funktion, die einen Fehler generiert, aufgerufen.

</code></pre></div><p>{// stateRoot
lexNewLine: {stateRoot, 0},
lexKeyword | (keyContract &lt;&lt; 8): {stateContract | statePush, 0},
lexKeyword | (keyFunc &lt;&lt; 8): {stateFunc | statePush, 0},
lexComment: {stateRoot, 0},
0: {errUnknownCmd, cfError},
},</p> <div class="language- extra-class"><pre class="language-text"><code>Angenommen, wir sind auf das SchlÃ¼sselwort **func** gestoÃen und haben den Status in *stateFunc* geÃ¤ndert. Da der Funktionsname auf das SchlÃ¼sselwort **func** folgen muss, behalten wir denselben Zustand bei, wenn wir den Funktionsnamen Ã¤ndern. FÃ¼r alle anderen Token werden wir entsprechende Fehler generieren. Wenn wir den Funktionsnamen in der Token-ID erhalten, gehen wir zum *stateFParams*-Zustand, wo wir die Parameter der Funktion erhalten kÃ¶nnen.
</code></pre></div><p>{// stateFunc
lexNewLine: {stateFunc, 0},
lexIdent: {stateFParams, cfNameBlock},
0: {errMustName, cfError},
},</p> <div class="language- extra-class"><pre class="language-text"><code>Gleichzeitig mit den obigen Operationen rufen wir die Funktion **fNameBlock** auf. Es sollte beachtet werden, dass die Blockstruktur mit der statePush-Markierung erstellt wird, wo wir sie aus dem Puffer holen und mit den Daten fÃ¼llen, die wir benÃ¶tigen. Die **fNameBlock**-Funktion eignet sich fÃ¼r VertrÃ¤ge und Funktionen (einschlieÃlich der darin verschachtelten). Er fÃ¼llt das *Info*-Feld mit der entsprechenden Struktur und schreibt sich in die *Objects* des Ã¼bergeordneten Blocks. Auf diese Weise kÃ¶nnen wir die Funktion oder den Vertrag mit dem angegebenen Namen aufrufen. Ebenso erstellen wir entsprechende Funktionen fÃ¼r alle ZustÃ¤nde und Variablen. Diese Funktionen sind normalerweise sehr klein und fÃ¼hren einige Aufgaben beim Erstellen des Baums der virtuellen Maschine aus.
</code></pre></div><p>func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {
var itype int
prev := (*buf)[len(*buf)-2]
fblock := (*buf)[len(*buf)-1]
name := lexem.Value.(string)
switch state {
case stateBlock:
itype = ObjContract
name = StateName((*buf)[0].Info.(uint32), name)
fblock.Info = &amp;ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,
Owner: (*buf)[0].Owner}
default:
itype = ObjFunc
fblock.Info = &amp;FuncInfo{}
}
fblock.Type = itype
prev.Objects[name] = &amp;ObjInfo{Type: itype, Value: fblock}
return nil
}</p> <div class="language- extra-class"><pre class="language-text"><code>FÃ¼r die Funktion **CompileBlock** durchlÃ¤uft sie einfach alle Tokens und wechselt die ZustÃ¤nde gemÃ¤Ã den in den ZustÃ¤nden beschriebenen Tokens. Fast alle zusÃ¤tzlichen Token entsprechen zusÃ¤tzlichen Programmcodes.

* **statePush** â fÃ¼gt das Objekt **Block** zum Objektbaum hinzu;
* **statePop** - wird verwendet, wenn der Block mit einer schlieÃenden geschweiften Klammer endet;
* **stateStay** - Sie mÃ¼ssen die aktuelle Markierung beibehalten, wenn Sie in einen neuen Status wechseln;
* **stateToBlock** - Ãbergang in den Zustand **stateBlock** zur Verarbeitung von *while* und *if*. Nach der Verarbeitung von AusdrÃ¼cken mÃ¼ssen Sie BlÃ¶cke innerhalb der geschweiften Klammern verarbeiten;
* **stateToBody** - Ãbergang in den Zustand **stateBody**;
* **stateFork** - speichert die markierte Position. Wenn der Ausdruck mit einem Bezeichner oder einem Namen mit `$` beginnt, kÃ¶nnen wir Funktionsaufrufe oder Zuweisungen vornehmen;
* **stateToFork** â wird verwendet, um das in **stateFork** gespeicherte Token abzurufen, das an die Prozessfunktion Ã¼bergeben wird;
* **stateLabel** â wird zum EinfÃ¼gen von **cmdLabel**-Befehlen verwendet. *wÃ¤hrend* die Struktur dieses Flag erfordert;
* **stateMustEval** â prÃ¼ft die VerfÃ¼gbarkeit von bedingten AusdrÃ¼cken am Anfang von *if*- und *while*-Strukturen.

Neben der Funktion **CompileBlock** ist auch die Funktion **FlushBlock** zu nennen. Das Problem besteht jedoch darin, dass der Blockbaum unabhÃ¤ngig von vorhandenen virtuellen Maschinen erstellt wird. Genauer gesagt erhalten wir Informationen Ã¼ber Funktionen und VertrÃ¤ge, die in einer virtuellen Maschine vorhanden sind, aber wir sammeln die kompilierten BlÃ¶cke in einem separaten Baum. Andernfalls, wenn wÃ¤hrend der Kompilierung ein Fehler auftritt, mÃ¼ssen wir die virtuelle Maschine auf den vorherigen Zustand zurÃ¼cksetzen. Daher gehen wir separat zum Kompilierungsbaum, aber nachdem die Kompilierung erfolgreich ist, muss die Funktion **FlushContract** aufgerufen werden. Diese Funktion fÃ¼gt den fertigen Blockbaum zur aktuellen virtuellen Maschine hinzu. Die Kompilierungsphase ist nun abgeschlossen.

## Lexikalischer Analysator
Der lexikalische Analysator verarbeitet eingehende Zeichenfolgen und bildet eine Folge von Token der folgenden Typen:
* **lexSys** - Systemtoken, zum Beispiel: `{}, [], (), ,, .` usw.;
* **lexOper** - Vorgangstoken, zum Beispiel: `+, -, /, \, *`;
* **lexNumber** - Zahl;
* **lexident** - Kennung;
* **lexNewline** - Zeilenumbruchzeichen;
* **lexString** - Zeichenkette;
* **lexComment** - Kommentar;
* **lexKeyword** - SchlÃ¼sselwort;
* **lexType** - Typ;
* **lexExtend** - Verweis auf externe Variablen oder Funktionen, zum Beispiel: `$myname`.

In der aktuellen Version wird zunÃ¤chst mit Hilfe der Datei [script/lextable/lextable.go](#lextablelextablego) eine Konvertierungstabelle (finite state machine) zum Parsen der Tokens aufgebaut, die in die Datei lex_table.go geschrieben wird. Im Allgemeinen kÃ¶nnen Sie die ursprÃ¼nglich von der Datei generierte Konvertierungstabelle loswerden und direkt beim Start eine Konvertierungstabelle im Speicher erstellen (`init()`). Die lexikalische Analyse selbst findet in der lexParser-Funktion in der Datei [lex.go](#lex-go) statt.

### &lt;span id = &quot;lextable-lextable-go&quot;&gt;lextable/lextable.go&lt;/span&gt;

Hier definieren wir das zu betreibende Alphabet und beschreiben, wie die endliche Zustandsmaschine basierend auf dem nÃ¤chsten empfangenen Symbol von einem Zustand in einen anderen wechselt.

*states* ist ein JSON-Objekt, das eine Liste von ZustÃ¤nden enthÃ¤lt.
Mit Ausnahme bestimmter Symbole steht âdâ fÃ¼r alle Symbole, die nicht im Staat angegeben sind.
ânâ steht fÃ¼r 0x0a, âsâ steht fÃ¼r Leerzeichen, âqâ steht fÃ¼r Backquote, âQâ steht fÃ¼r doppeltes AnfÃ¼hrungszeichen, ârâ steht fÃ¼r Zeichen &gt;= 128, âaâ steht fÃ¼r AZ und az und â 1` steht fÃ¼r 1-9.

Die Namen dieser ZustÃ¤nde sind SchlÃ¼ssel, und die mÃ¶glichen Werte sind im Wertobjekt aufgelistet. Dann gibt es einen neuen Zustand, um ÃbergÃ¤nge fÃ¼r jede Gruppe vorzunehmen. Dann gibt es noch den Namen des Tokens. Wenn wir zum Anfangszustand zurÃ¼ckkehren mÃ¼ssen, ist der dritte Parameter das Service-Token, das angibt, wie mit dem aktuellen Symbol umgegangen werden soll.

Zum Beispiel haben wir den Hauptzustand und die eingehenden Zeichen `/`, `&quot;/&quot;: [&quot;solidus&quot;, &quot;&quot;, &quot;push next&quot;]`,

* **push** - gibt den Befehl, sich daran zu erinnern, dass es sich in einem separaten Stack befindet ;
* **nÃ¤chster** - geht zum nÃ¤chsten Zeichen, und gleichzeitig Ã¤ndern wir den Status auf **solidus**. Ruft danach das nÃ¤chste Zeichen ab und Ã¼berprÃ¼ft den Status von **solidus**.

Wenn das nÃ¤chste Zeichen `/` oder `/*` hat, gehen wir zum Kommentarstatus **Kommentar**, weil sie mit `//` oder `/*` beginnen. Offensichtlich hat jeder Kommentar danach einen anderen Zustand, weil sie mit einem anderen Symbol enden.

Wenn das nÃ¤chste Zeichen nicht `/` und `*` ist, dann zeichnen wir alles im Stack als Tags vom Typ **lexOper** auf, leeren den Stack und kehren zum Hauptzustand zurÃ¼ck.
Das folgende Modul konvertiert den Zustandsbaum in ein numerisches Array und schreibt es in die Datei *lex_table.go*.

In der ersten Schleife:

Wir bilden ein Alphabet gÃ¼ltiger Symbole.

</code></pre></div><p>for ind, ch := range alphabet {
i := byte(ind)</p> <div class="language- extra-class"><pre class="language-text"><code>DarÃ¼ber hinaus versehen wir in **state2int** jeden Zustand mit einer eigenen Sequenzkennung.

</code></pre></div><p>state2int := map[string]uint{<code>main</code>: 0}
if err := json.Unmarshal([]byte(states), &amp;data); err == nil {
for key := range data {
if key != <code>main</code> {
state2int[key] = uint(len(state2int))</p> <div class="language- extra-class"><pre class="language-text"><code>Wenn wir alle ZustÃ¤nde und jede Menge in einem Zustand und jedes Symbol in einer Menge durchlaufen, schreiben wir eine Drei-Byte-Zahl [neue Zustandskennung (0 = Haupt)] + [Tokentyp (0-kein Token)] + [Token] .
Die ZweidimensionalitÃ¤t des Arrays *table* besteht darin, dass es in ZustÃ¤nde und 34 Eingabesymbole aus dem Array *alphabet* unterteilt ist, die in derselben Reihenfolge angeordnet sind.
Wir befinden uns im *Hauptzustand* in der Nullzeile der *Tabelle*. Nehmen Sie das erste Zeichen, finden Sie seinen Index im Array *alphabet* und erhalten Sie den Wert aus der Spalte mit dem angegebenen Index. Ausgehend vom empfangenen Wert erhalten wir den Token im Low-Byte. Wenn die Analyse abgeschlossen ist, zeigt das zweite Byte den Typ des empfangenen Tokens an. Im dritten Byte erhalten wir den Index des nÃ¤chsten neuen Zustands.
All dies wird ausfÃ¼hrlicher in der Funktion **lexParser** in *lex.go* beschrieben.
Wenn Sie einige neue Zeichen hinzufÃ¼gen mÃ¶chten, mÃ¼ssen Sie sie dem Array *alphabet* hinzufÃ¼gen und die Menge der Konstante *AlphaSize* erhÃ¶hen. Wenn Sie eine neue Symbolkombination hinzufÃ¼gen mÃ¶chten, sollte diese Ã¤hnlich wie bei den bestehenden Optionen im Status beschrieben werden. FÃ¼hren Sie nach dem obigen Vorgang die Datei *lextable.go* aus, um die Datei *lex_table.go* zu aktualisieren.

### &lt;span id = &quot;lex-go&quot;&gt;lex.go&lt;/span&gt;
Die **lexParser**-Funktion generiert direkt eine lexikalische Analyse und gibt basierend auf eingehenden Zeichenfolgen ein Array empfangener Tags zurÃ¼ck. Lassen Sie uns die Struktur von Token analysieren.

</code></pre></div><p>type Lexem struct {
Type  uint32 // Type of the lexem
Value interface{} // Value of lexem
Line  uint32 // Line of the lexem
Column uint32 // Position inside the line
}</p> <div class="language- extra-class"><pre class="language-text"><code>* **Typ** - Token-Typ. Es hat einen der folgenden Werte: `lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend`;
* **value** â Wert des Tokens. Die Art des Werts hÃ¤ngt vom Token-Typ ab. Lassen Sie uns das genauer analysieren:
   * **lexSys** - enthÃ¤lt Klammern, Kommas usw. In diesem Fall `Type = ch &lt;&lt; 8 | lexSysâ, beziehen Sie sich bitte auf die Konstante âisLPar ... isRBrackâ, und ihr Wert ist uint32 Bits;
   * **lexOper** - der Wert stellt eine Ã¤quivalente Zeichenfolge in Form von uint32 dar. Siehe die `isNot ... isOr`-Konstanten;
   * **lexNumber** - Zahlen werden als int64 oder float64 gespeichert. Wenn die Zahl einen Dezimalpunkt hat, ist sie Float64;
   * **lexIdent** - Identifikatoren werden als String gespeichert;
   * **lexNewLine** - Zeilenumbruchzeichen. Wird auch zur Berechnung der Reihen- und Tokenposition verwendet;
   * **lexString** - Zeilen werden als String gespeichert;
   * **lexComment** - Kommentare werden als String gespeichert;
   * **lexKeyword** - fÃ¼r SchlÃ¼sselwÃ¶rter werden nur die entsprechenden Indizes gespeichert, siehe `keyContract ... keyTail`-Konstante. In diesem Fall `Type = KeyID &lt;&lt; 8 | lexKeyword`. AuÃerdem ist zu beachten, dass die SchlÃ¼sselwÃ¶rter âtrue, false, nilâ sofort in Token vom Typ âlexNumberâ umgewandelt und die entsprechenden Typen âboolâ und âinterface {}â verwendet werden;
   * **lexType** â dieser Wert enthÃ¤lt den entsprechenden âreflect.Typeâ-Typwert;
   * **lexExtend** â Bezeichner, die mit einem `$` beginnen. Diese Variablen und Funktionen werden von auÃen Ã¼bergeben und sind daher speziellen Arten von Token zugeordnet. Dieser Wert enthÃ¤lt den Namen als String ohne $ am Anfang.
* **Line** - die Zeile, in der das Token gefunden wird;
* **Column** - Inline-Position des Tokens.
Lassen Sie uns die Funktion **lexParser** im Detail analysieren. Die **todo**-Funktion schlÃ¤gt den Symbolindex im Alphabet basierend auf dem aktuellen Status und dem eingehenden Symbol nach und erhÃ¤lt einen neuen Status, Token-Identifikator (falls vorhanden) und andere Token aus der Umwandlungstabelle. Das Parsing selbst beinhaltet das Aufrufen der **todo**-Funktion der Reihe nach fÃ¼r jedes nÃ¤chste Zeichen und das Wechseln in einen neuen Zustand. Sobald das Tag empfangen wurde, erstellen wir das entsprechende Token in den Ausgabekriterien und setzen den Parsing-Prozess fort. Es sollte beachtet werden, dass wir wÃ¤hrend des Parsing-Prozesses die Token-Symbole nicht in einem separaten Stack oder Array akkumulieren, weil wir nur den Offset des Starts des Tokens speichern. Nachdem wir das Token erhalten haben, verschieben wir den Offset des nÃ¤chsten Tokens an die aktuelle Parsing-Position.

Es bleibt nur noch, die beim Parsing verwendeten lexikalischen Status-Token zu Ã¼berprÃ¼fen:
* **lexfPush** - dieses Token bedeutet, dass wir beginnen, Symbole in einem neuen Token zu sammeln;
* **lexfNext** - das Zeichen muss dem aktuellen Token hinzugefÃ¼gt werden;
* **lexfPop** - Der Empfang des Tokens ist abgeschlossen. Normalerweise haben wir mit diesem Flag den Bezeichnertyp des geparsten Tokens;
* **lexfSkip** - Dieses Token wird verwendet, um Zeichen vom Parsen auszuschlieÃen. Beispielsweise sind die KontrollschrÃ¤gstriche in der Zeichenfolge \n \r \&quot;. Sie werden wÃ¤hrend der lexikalischen Analysephase automatisch ersetzt.

## Needle Sprache
### Lexemes
Der Quellcode eines Programms muss in UTF-8-Kodierung vorliegen.

Die folgenden lexikalischen Typen werden verarbeitet:

* **SchlÃ¼sselwÃ¶rter** - ```action, break, conditions, Continue, Contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while``` ;
* **Zahl** - nur Dezimalzahlen werden akzeptiert. Es gibt zwei Grundtypen: **int** und **float**. Wenn die Zahl einen Dezimalpunkt hat, wird sie zu einem Float **float**. Der Typ **int** entspricht in Golang **int64**, wÃ¤hrend der Typ **float** in Golang **float64** entspricht.
* **String** - Der String kann in doppelte AnfÃ¼hrungszeichen ```(&quot;ein String&quot;)``` oder Backquotes ```(\`ein String\`)``` eingeschlossen werden. Beide Arten von Zeichenfolgen kÃ¶nnen Zeilenumbruchzeichen enthalten. Zeichenfolgen in doppelten AnfÃ¼hrungszeichen kÃ¶nnen doppelte AnfÃ¼hrungszeichen, Zeilenumbruchzeichen und mit SchrÃ¤gstrichen maskierte WagenrÃ¼cklÃ¤ufe enthalten. Beispiel: ```&quot;Dies ist eine \&quot;erste Zeichenfolge\&quot;.\r\nDies ist eine zweite Zeichenfolge.&quot;```.
* **Kommentar** - Es gibt zwei Arten von Kommentaren. Einzeilige Kommentare verwenden zwei SchrÃ¤gstriche (//). Beispiel: // Dies ist ein einzeiliger Kommentar. Mehrzeilige Kommentare verwenden SchrÃ¤gstriche und Sternchen und kÃ¶nnen sich Ã¼ber mehrere Zeilen erstrecken. Beispiel: ```/* Dies ist ein mehrzeiliger Kommentar */```.
* **Bezeichner** - die Namen von Variablen und Funktionen, die aus Buchstaben a-z und A-Z, UTF-8-Symbolen, Zahlen und Unterstrichen bestehen. Der Name kann mit einem Buchstaben, Unterstrich, ```@``` oder ```$``` beginnen. Der Name, der mit ```$``` beginnt, ist der Name der Variablen, die im **Datenabschnitt** definiert ist. Der mit ```$``` beginnende Name kann auch verwendet werden, um globale Variablen im Bereich von **Bedingungen** und **Aktionsabschnitten** zu definieren. ÃkosystemvertrÃ¤ge kÃ¶nnen Ã¼ber das Symbol ```@``` aufgerufen werden. Zum Beispiel: ```@1NewTable(...)```.

### Typen

Neben den Nadeltypen sind entsprechende Golang-Typen angegeben.
* **bool** - bool, standardmÃ¤Ãig **false**;
* **bytes** - []byte{}, standardmÃ¤Ãig ein leeres Byte-Array;
* **int** - standardmÃ¤Ãig int64, **0**;
* **Address** - uint64, standardmÃ¤Ãig **0**;
* **Array** - []interface{}, standardmÃ¤Ãig ein leeres Array;
* **map** - map[string]interface{}, standardmÃ¤Ãig ein leeres Objekt-Array;
* **money** - Dezimalzahl. Dezimal, standardmÃ¤Ãig **0**;
* **float** - float64, standardmÃ¤Ãig **0**;
* **String** - String, standardmÃ¤Ãig ein leerer String;
* **file** - map[string]interface{}, standardmÃ¤Ãig ein leeres Objekt-Array.
Diese Variablentypen werden mit dem SchlÃ¼sselwort ```var``` definiert. Beispiel: ```var var1, var2 int```. Bei dieser Definition wird einer Variablen ein Standardwert nach Typ zugewiesen.

Alle Variablenwerte sind vom Typ interface{} und werden dann den erforderlichen Golang-Typen zugewiesen. Daher sind beispielsweise Array- und Map-Typen Golang-Typen []interface{} und map[string]interface{}. Beide Arten von Arrays kÃ¶nnen Elemente beliebigen Typs enthalten.

### AusdrÃ¼cke

Ein Ausdruck kann arithmetische Operationen, logische Operationen und Funktionsaufrufe enthalten. Alle AusdrÃ¼cke werden von links nach rechts nach PrioritÃ¤t der Operatoren ausgewertet. Bei gleicher PrioritÃ¤t werden Operatoren von links nach rechts ausgewertet.

PrioritÃ¤t der Operationen von hoch nach niedrig:
* **Funktionsaufruf und Klammern** - Beim Aufruf einer Funktion werden Ã¼bergebene Parameter von links nach rechts berechnet;
* **UnÃ¤re Operation** - logische Negation ```!``` und arithmetischer Vorzeichenwechsel ```-```;
* **Multiplikation und Division** - arithmetische Multiplikation ```*``` und Division ```/```;
* **Addition und Subtraktion** - arithmetische Addition ```+``` und Subtraktion ```-```;
* **Logischer Vergleich** - ```&gt;=&gt;&gt; &gt;=```;
* **Logische Gleichheit und Ungleichheit** - ```== !=```;
* **Logisches UND** - ```&amp;&amp;```;
* **Logisches ODER** - ```||```.

Bei der Auswertung von logischem AND und OR werden in jedem Fall beide Seiten des Ausdrucks ausgewertet.

Needle hat keine TypprÃ¼fung wÃ¤hrend der Kompilierung. Beim Auswerten von Operanden wird versucht, den Typ in einen komplexeren Typ umzuwandeln. Die Art der KomplexitÃ¤tsreihenfolge kann wie folgt sein: ```string, int, float, money```. Nur ein Teil der Typkonvertierungen ist implementiert. Der Zeichenfolgentyp unterstÃ¼tzt Additionsoperationen, und das Ergebnis ist eine Zeichenfolgenverkettung. Beispiel: ```string + string = string, money-int = money, int * float = float```.

Bei Funktionen wird wÃ¤hrend der AusfÃ¼hrung eine TypprÃ¼fung fÃ¼r die Typen ```string``` und ```int``` durchgefÃ¼hrt.
Die Typen **array** und **map** kÃ¶nnen per Index adressiert werden. Beim Typ **array** muss als Index der Wert **int** angegeben werden. FÃ¼r den Typ **Map** muss eine Variable oder ein **String**-Wert angegeben werden. Wenn Sie einem **Array**-Element einen Wert zuweisen, dessen Index grÃ¶Ãer als der aktuelle maximale Index ist, wird dem Array ein leeres Element hinzugefÃ¼gt. Der Anfangswert dieser Elemente ist **nil**. Zum Beispiel: .. Code:
</code></pre></div><p>var my array
my[5] = 0
var mymap map
mymap[&quot;index&quot;] = my[3]</p> <div class="language- extra-class"><pre class="language-text"><code>In AusdrÃ¼cken mit bedingten logischen Werten (z. B. `if, while, &amp;&amp;, ||, !`) wird der Typ automatisch in einen logischen Wert konvertiert. Wenn der Typ nicht der Standardwert ist, ist er wahr.
</code></pre></div><p>var mymap map
var val string
if mymap &amp;&amp; val {
...
}</p> <div class="language- extra-class"><pre class="language-text"><code>### Zielfernrohr

Klammern geben einen Block an, der lokale Bereichsvariablen enthalten kann. StandardmÃ¤Ãig erstreckt sich der Geltungsbereich einer Variablen auf ihre eigenen BlÃ¶cke und alle verschachtelten BlÃ¶cke. In einem Block kÃ¶nnen Sie eine neue Variable mit dem Namen einer vorhandenen Variablen definieren. In diesem Fall sind jedoch externe Variablen mit demselben Namen nicht mehr verfÃ¼gbar.
</code></pre></div><p>var a int
a = 3
{
var a int
a = 4
Println(a) // 4
}
Println(a) // 3</p> <div class="language- extra-class"><pre class="language-text"><code>### Vertragsabwicklung

Beim Aufruf eines Contracts mÃ¼ssen ihm in **data** definierte Parameter Ã¼bergeben werden. Vor AusfÃ¼hrung eines Auftrags erhÃ¤lt die virtuelle Maschine diese Parameter und weist sie den entsprechenden Variablen ($Param) zu. Dann werden die vordefinierten Funktionen **conditions** und **action** aufgerufen.

Fehler, die wÃ¤hrend der VertragsausfÃ¼hrung auftreten, kÃ¶nnen in zwei Arten unterteilt werden: Formularfehler und Umgebungsfehler. Formularfehler werden mit speziellen Befehlen generiert: `error, warning, info` und wenn die eingebaute Funktion `err` ungleich *nil* zurÃ¼ckgibt.

Die Needle-Sprache behandelt keine Ausnahmen. Jeder Fehler wird die AusfÃ¼hrung von VertrÃ¤gen beenden. Da ein separater Stack und eine separate Struktur zum Speichern von Variablenwerten erstellt werden, wenn ein Vertrag ausgefÃ¼hrt wird, lÃ¶scht der Golang-Garbage-Collection-Mechanismus diese Daten automatisch, wenn ein Vertrag ausgefÃ¼hrt wird.

### &lt;span id = &quot;backus-naur-form-bnf&quot;&gt;BackusâNaur Form (BNF)&lt;/span&gt;
In der Informatik ist BNF eine Notationstechnik fÃ¼r kontextfreie Syntax und wird normalerweise verwendet, um die Syntax der beim Rechnen verwendeten Sprache zu beschreiben.

* &amp;lt;decimal digit&amp;gt;
</code></pre></div><p>'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'</p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;decimal number&amp;gt;
</code></pre></div><p><decimal digit=""> {<decimal digit="">}</decimal></decimal></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;symbol code&amp;gt;
</code></pre></div><p>'''<any symbol="">'''</any></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;real number&amp;gt;
</code></pre></div><p>['-'] &lt;decimal number'.'[<decimal number="">]</decimal></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;integer number&amp;gt;
</code></pre></div><p>['-'] <decimal number=""> | <symbol code=""></symbol></decimal></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;number&amp;gt;
</code></pre></div><p>'<integer number=""> | <real number="">'</real></integer></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;letter&amp;gt;
</code></pre></div><p>'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF</p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;space&amp;gt;
</code></pre></div><p>'0x20'</p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;tabulation&amp;gt;
</code></pre></div><p>'0x09'</p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;newline&amp;gt;
</code></pre></div><p>'0x0D 0x0A'</p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;special symbol&amp;gt;
</code></pre></div><p>'!' |'&quot;' |'$' |''' |'(' |')' |'*' |'+' |',' |'-' |'.' |'/ '|'&lt;' |'=' |'&gt;' |'[' |'\' |']' |'_' |'|' |'}' | '{' | <tabulation> | <space> | <newline></newline></space></tabulation></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;symbol&amp;gt;
</code></pre></div><p><decimal digit=""> | <letter> | <special symbol=""></special></letter></decimal></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;name&amp;gt;
</code></pre></div><p>(<letter> |'<em>') {<letter> |'</letter></em>' | <decimal digit="">}</decimal></letter></p> <div class="language- extra-class"><pre class="language-text"><code>
* &amp;lt;function name&amp;gt;
</code></pre></div><name>
```
<ul><li>&lt;variable name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;type name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;string symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;tabulation&gt; | &lt;space&gt; |'!' |'#' | ... |'[' |']' | ...
</code></pre></div><ul><li>&lt;string element&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{&lt;string symbol&gt; |'\&quot;' |'\n' |'\r'}
</code></pre></div><ul><li>&lt;string&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'&quot;' {&lt;string element&gt;}'&quot;' |'\`' {&lt;string element&gt;}'\`'
</code></pre></div><ul><li>&lt;assignment operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'='
</code></pre></div><ul><li>&lt;unary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'-'
</code></pre></div><ul><li>&lt;binary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'==' |'!=' |'&gt;' |'&lt;' |'&lt;=' |'&gt;=' |'&amp;&amp;' |'||' |'\*' |'/' |'+ '|'-'
</code></pre></div><ul><li>&lt;operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;assignment operator&gt; | &lt;unary operator&gt; | &lt;binary operator&gt;
</code></pre></div><ul><li>&lt;parameters&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;expression&gt; {','&lt;expression&gt;}
</code></pre></div><ul><li>&lt;contract call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract name&gt;'(' [&lt;parameters&gt;]')'
</code></pre></div><ul><li>&lt;function call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract call&gt; [{'.' &lt;name&gt;'(' [&lt;parameters&gt;]')'}]
</code></pre></div><ul><li>&lt;block contents&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;block command&gt; {&lt;newline&gt;&lt;block command&gt;}
</code></pre></div><ul><li>&lt;block&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'{'&lt;block contents&gt;'}'
</code></pre></div><ul><li>&lt;block command&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(&lt;block&gt; | &lt;expression&gt; | &lt;variables definition&gt; | &lt;if&gt; | &lt;while&gt; | break | continue | return)
</code></pre></div><ul><li>&lt;if&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'if &lt;expression&gt;&lt;block&gt; [else &lt;block&gt;]'
</code></pre></div><ul><li>&lt;while&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'while &lt;expression&gt;&lt;block&gt;'
</code></pre></div><ul><li>&lt;contract&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'contract &lt;name&gt; '{'[&lt;data section&gt;] {&lt;function&gt;} [&lt;conditions&gt;] [&lt;action&gt;]'}''
</code></pre></div><ul><li>&lt;data section&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'data '{' {&lt;data parameter&gt;&lt;newline&gt;} '}''
</code></pre></div><ul><li>&lt;data parameter&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; &lt;type name&gt;'&quot;'{&lt;tag&gt;}'&quot;'
</code></pre></div><ul><li>&lt;tag&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'optional | image | file | hidden | text | polymap | map | address | signature:&lt;name&gt;'
</code></pre></div><ul><li>&lt;conditions&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'conditions &lt;block&gt;'
</code></pre></div><ul><li>&lt;action&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'action &lt;block&gt;'
</code></pre></div><ul><li>&lt;function&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'func &lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'[{&lt;tail&gt;}] [&lt;type name&gt;] &lt;block&gt;'
</code></pre></div><ul><li>&lt;variable description&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; {',' &lt;variable name&gt;} &lt;type name&gt;
</code></pre></div><ul><li>&lt;tail&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'.'&lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'
</code></pre></div><ul><li>&lt;variables definition&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'var &lt;variable description&gt;{','&lt;variable description&gt;}'
</code></pre></div></name></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/IBAX-io/documentation/edit/master/docs/de/topics/vm.md" target="_blank" rel="noopener noreferrer">Bearbeiten Sie diese Seite auf GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Letzte Aktualisierung:</span> <span class="time">20.4.2022, 05:12:55</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      â
      <a href="/de/topics/templates2.html" class="prev">
        Vorlagensprache
      </a></span> <span class="next"><a href="/de/topics/script.html">
        Intelligente VertrÃ¤ge
      </a>
      â
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1fdb8a3a.js" defer></script><script src="/assets/js/2.14a295a1.js" defer></script><script src="/assets/js/28.7895237d.js" defer></script>
  </body>
</html>
