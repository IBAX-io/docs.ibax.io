<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>编译器和虚拟机 </a></li><li><a href="/zh-CN/topics/templates2.html" class="sidebar-link">模版语言 </a></li><li><a href="/zh-CN/topics/vm.html" aria-current="page" class="active sidebar-link">编译器和虚拟机 </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#source-code-storage-and-compilation" class="sidebar-link">源代码存储和编译 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#virtual-machine-structures" class="sidebar-link">虚拟机结构  </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#vm-structure" class="sidebar-link">VM结构 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#block-structure" class="sidebar-link">块结构 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#objinfo-structure" class="sidebar-link">ObjInfo结构 </a></li></ul></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#virtual-machine-commands" class="sidebar-link">虚拟机指令 </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#bytecode-structure" class="sidebar-link">ByteCode结构 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#command-identifiers" class="sidebar-link">指令标识符 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#stack-operation-commands" class="sidebar-link">堆栈操作指令 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#runtime-structure" class="sidebar-link">Runtime结构 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#runcode-function" class="sidebar-link">RunCode函数 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#other-functions-for-operations-with-vm" class="sidebar-link">VM的其他函数操作 </a></li></ul></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#compiler" class="sidebar-link">编译器 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#lexical-analyzer" class="sidebar-link">词法分析器 </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#lextable-lextable-go" class="sidebar-link">lextable/lextable.go </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#lex-go" class="sidebar-link">lex.go </a></li></ul></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#needle-language" class="sidebar-link">needle 语言 </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#lexemes" class="sidebar-link">词法 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#types" class="sidebar-link">类型 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#expressions" class="sidebar-link">表达式 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#scope" class="sidebar-link">范围 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#contract-execution" class="sidebar-link">智能合约执行 </a></li><li class="sidebar-sub-header"><a href="/zh-CN/topics/vm.html#backus-naur-form-bnf" class="sidebar-link">巴科斯范式Backus--Naur Form (BNF) </a></li></ul></li></ul></li><li><a href="/zh-CN/topics/daemons.html" class="sidebar-link">守护进程 </a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="compiler-and-virtual-machine"><a href="#compiler-and-virtual-machine" class="header-anchor">#</a> 编译器和虚拟机 </h1> <ul><li><a href="#source-code-storage-and-compilation">源代码存储和编译</a></li> <li><a href="#virtual-machine-structures">虚拟机结构</a> <ul><li><a href="#vm-structure">VM结构</a></li> <li><a href="#block-structure">块结构</a></li> <li><a href="#objinfo-structure">ObjInfo结构</a> <ul><li><a href="#contractinfo-structure">ContractInfo结构</a> <ul><li><a href="#fieldinfo-structure">FieldInfo结构</a></li></ul></li> <li><a href="#funcinfo-structure">FuncInfo结构</a> <ul><li><a href="#funcname-structure">FuncName结构</a></li></ul></li> <li><a href="#extfuncinfo-structure">ExtFuncInfo结构</a></li> <li><a href="#varinfo-structure">VarInfo结构</a></li> <li><a href="#objextend-value">ObjExtend值</a></li></ul></li></ul></li> <li><a href="#virtual-machine-commands">虚拟机指令</a> <ul><li><a href="#bytecode-structure">ByteCode结构</a></li> <li><a href="#command-identifiers">指令标识符</a></li> <li><a href="#stack-operation-commands">堆栈操作指令</a></li> <li><a href="#runtime-structure">Runtime结构</a> <ul><li><a href="#blockstack-structure">blockStack结构</a></li></ul></li> <li><a href="#runcode-function">RunCode函数</a></li> <li><a href="#other-functions-for-operations-with-vm">VM的其他函数操作</a></li></ul></li> <li><a href="#compiler">编译器</a></li> <li><a href="#lexical-analyzer">词法分析器</a> <ul><li><a href="#lextable-lextable-go">lextable/lextable.go</a></li> <li><a href="#lex-go">lex.go</a></li></ul></li> <li><a href="#needle-language">needle 语言</a> <ul><li><a href="#lexemes">词法</a></li> <li><a href="#types">类型</a></li> <li><a href="#expressions">表达式</a></li> <li><a href="#scope">范围</a></li> <li><a href="#contract-execution">智能合约执行</a></li> <li><a href="#backus-naur-form-bnf">巴科斯范式Backus--Naur Form (BNF)</a></li></ul></li></ul> <p>本节涉及程序编译和虚拟机中 needle 语言的操作。</p> <h2 id="source-code-storage-and-compilation"><a href="#source-code-storage-and-compilation" class="header-anchor">#</a> 源代码存储和编译 </h2> <p>智能合约和功能用Golang语言编写，并存储在生态系统的智能合约表。</p> <p>执行智能合约时，将从数据库中读取其源代码并将其编译为字节码。</p> <p>智能合约更改后，其源代码将更新并保存在数据库中。然后编译该源代码，导致相应的虚拟机字节码也被改变。</p> <p>字节码在任何地方都没有物理保存，因此当再次执行程序时，会重新编译源代码。</p> <p>所有生态系统的智能合约表中描述的整个源代码都严格按顺序编译到一个虚拟机中，虚拟机的状态在所有节点上都相同。</p> <p>调用智能合约时，虚拟机不会以任何方式更改其状态。执行任何智能合约或调用函数都发生在每个外部调用时创建的单独运行堆栈上。</p> <p>每个生态系统都可以拥有一个所谓的虚拟生态系统，可以在一个节点内与区块链外的数据表一起使用，并且不能直接影响区块链或其他虚拟生态系统。在这种情况下，托管这样虚拟生态系统的节点会编译其智能合约并创建自己的虚拟机。</p> <h2 id="virtual-machine-structures"><a href="#virtual-machine-structures" class="header-anchor">#</a> 虚拟机结构  </h2> <h3 id="vm-structure"><a href="#vm-structure" class="header-anchor">#</a> VM结构 </h3> <p>虚拟机按如下结构定义在内存中。</p> <div class="language- extra-class"><pre class="language-text"><code>type VM struct {
    Block
    ExtCost       func(string) int64
    FuncCallsDB   map[string]struct{}
    Extern        bool
    ShiftContract int64
    logger        *log.Entry
}
</code></pre></div><p>VM结构具有以下元素：</p> <blockquote><ul><li><strong>Block</strong> - 包含一个 <a href="#%E5%9D%97%E7%BB%93%E6%9E%84">块结构</a>；</li> <li><strong>ExtCost</strong> - 一个函数，该函数返回执行外部golang函数的费用；</li> <li><strong>FuncCallsDB</strong> - golang函数名称集合，该函数名返回执行成本作为第一个参数。这些函数使用 <strong>EXPLAIN</strong> 计算处理数据库的成本；</li> <li><strong>Extern</strong> - 一个表示智能合约是否为外部智能合约的布尔标识，创建VM时，它设置为true，编译代码时不需要显示调用的智能合约。也就是说，它允许调用将来确定的智能合约代码；</li> <li><strong>ShiftContract</strong> VM中第一个智能合约的ID；</li> <li><strong>logger</strong> VM的错误日志输出。</li></ul></blockquote> <h3 id="block-structure"><a href="#block-structure" class="header-anchor">#</a> 块结构 </h3> <p>虚拟机是由 <strong>块Block</strong> 对象类型组成的树。</p> <p>块是包含一些字节码的独立单元。简单地说，您在语言的大括号(<code>{}</code>)中放入的所有内容都是一个块。</p> <p>例如，下面的代码创建一个带有函数的块。该块又包含一个带有 <em>if</em> 语句的块，该语句又包含一个带有 <em>while</em> 语句的块。</p> <div class="language- extra-class"><pre class="language-text"><code>func my() {
     if true {
          while false {
               ...
           }
     }
} 
</code></pre></div><p>块按如下结构定义在内存中。</p> <div class="language- extra-class"><pre class="language-text"><code>type Block struct {
    Objects  map[string]*ObjInfo
    Type     int
    Owner    *OwnerInfo
    Info     interface{}
    Parent   *Block
    Vars     []reflect.Type
    Code     ByteCodes
    Children Blocks
}
</code></pre></div><p>块结构具有以下元素：</p> <blockquote><ul><li><strong>Objects</strong> - 一个 <a href="#objinfo-structure">ObjInfo</a> 指针类型的内部对象的映射。例如，如果块中有一个变量，那么可以通过它的名称获得关于它的信息；</li> <li><strong>Type</strong> - 块的类型。块为函数时，类型为 <strong>ObjFunc</strong>。块为智能合约时，类型为 <strong>ObjContract</strong>；</li> <li><strong>Owner</strong> - 一个 <strong>OwnerInfo</strong> 指针类型的结构。该结构包含有关已编译智能合约所有者的信息。它在智能合约编译期间指定或从 <strong>contracts</strong> 表中获取；</li> <li><strong>Info</strong> - 包含有关对象的信息，这取决于块类型；</li> <li><strong>Parent</strong> - 指向父块的指针；</li> <li><strong>Vars</strong> - 一个包含当前块变量类型的数组；</li> <li><strong>Code</strong> - 块本身字节码，当控制权传递给该块时会执行该块字节码，例如，函数调用或者循环体；</li> <li><strong>Children</strong> - 一个包含子块的数组，例如，函数嵌套、循环、条件操作符。</li></ul></blockquote> <h3 id="objinfo-structure"><a href="#objinfo-structure" class="header-anchor">#</a> ObjInfo结构 </h3> <p><strong>ObjInfo</strong> 结构包含有关内部对象的信息。</p> <div class="language- extra-class"><pre class="language-text"><code>type ObjInfo struct {
   Type int
   Value interface{}
}
</code></pre></div><p>ObjInfo结构具有以下元素：</p> <blockquote><ul><li><strong>Type</strong> 是对象类型。它可以是以下值之一：
<ul><li><strong>ObjContract</strong> --<a href="#contractinfo-structure">智能合约</a>；</li> <li><strong>ObjFunc</strong> -- 函数；</li> <li><strong>ObjExtFunc</strong> -- 外部golang函数；</li> <li><strong>ObjVar</strong> -- 变量；</li> <li><strong>ObjExtend</strong> -- $name 变量。</li></ul></li> <li><strong>Value</strong> -- 包含每种类型的结构。</li></ul></blockquote> <h4 id="contractinfo-structure"><a href="#contractinfo-structure" class="header-anchor">#</a> ContractInfo结构 </h4> <p>指向 <strong>ObjContract</strong> 类型，<strong>Value</strong> 字段包含 <strong>ContractInfo</strong> 结构。</p> <div class="language- extra-class"><pre class="language-text"><code>type ContractInfo struct {
    ID uint32
    Name string
    Owner *OwnerInfo
    Used map[string]bool
    Tx *[]*FieldInfo
}
</code></pre></div><p>ContractInfo结构具有以下元素：</p> <blockquote><ul><li><strong>ID</strong> -- 智能合约ID。调用智能合约时，该值在区块链中显示；</li> <li><strong>Name</strong> -- 智能合约名称；</li> <li><strong>Owner</strong> -- 关于智能合约的其他信息；</li> <li><strong>Used</strong> -- 已被调用的智能合约名称的映射；</li> <li><strong>Tx</strong> -- 智能合约 <a href="/zh-CN/topics/script.html#data-section">数据部分</a> 描述的数据数组。</li></ul></blockquote> <h4 id="fieldinfo-structure"><a href="#fieldinfo-structure" class="header-anchor">#</a> FieldInfo结构 </h4> <p>FieldInfo结构用于 <strong>ContractInfo</strong> 结构并描述智能合约<a href="/zh-CN/topics/script.html#data-section">数据部分</a> 的元素。</p> <div class="language- extra-class"><pre class="language-text"><code>type FieldInfo struct {
      Name string
      Type reflect.Type
      Original uint32
      Tags string
}
</code></pre></div><p>FieldInfo结构具有以下元素：</p> <blockquote><ul><li><strong>Name</strong> - 字段名称；</li> <li><strong>Type</strong> - 字段类型；</li> <li><strong>Original</strong> - 可选项字段；</li> <li><strong>Tags</strong> -- 该字段的附加标签。</li></ul></blockquote> <h4 id="funcinfo-structure"><a href="#funcinfo-structure" class="header-anchor">#</a> FuncInfo结构 </h4> <p>指向 <strong>ObjFunc</strong> 类型，<strong>Value</strong> 字段包含 <strong>FuncInfo</strong> 结构。</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncInfo struct {
    Params []reflect.Type
    Results []reflect.Type
    Names *map[string]FuncName
    Variadic bool
    ID uint32
}
</code></pre></div><p>FuncInfo结构具有以下元素：</p> <blockquote><ul><li><strong>Params</strong> -- 参数类型数组；</li> <li><strong>Results</strong> -- 返回结果类型数组；</li> <li><strong>Names</strong> -- 尾部函数的数据映射，例如，<code>DBFind().Columns ()</code>；</li> <li><strong>Variadic</strong> -- 如果函数可以具有可变数量的参数，则为true；</li> <li><strong>ID</strong> -- 函数ID。</li></ul></blockquote> <h4 id="funcname-structure"><a href="#funcname-structure" class="header-anchor">#</a> FuncName结构 </h4> <p>FuncName结构用于 <strong>FuncInfo</strong> 并描述尾部函数的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
</code></pre></div><p>FuncName结构具有以下元素：</p> <blockquote><ul><li><strong>Params</strong> -- 参数类型数组；</li> <li><strong>Offset</strong> -- 这些变量的偏移量数组。实际上，所有参数在函数中都可以使用点 <code>.</code> 来初始化值；</li> <li><strong>Variadic</strong> -- 如果尾部函数可以具有可变数量的参数。则为true。</li></ul></blockquote> <h4 id="extfuncinfo-structure"><a href="#extfuncinfo-structure" class="header-anchor">#</a> ExtFuncInfo结构 </h4> <p>指向 <strong>ObjExtFunc</strong> 类型，<strong>Value</strong> 字段包含 <strong>ExtFuncInfo</strong>结构。用于描述golang函数。</p> <div class="language- extra-class"><pre class="language-text"><code>type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
</code></pre></div><p>ExtFuncInfo结构具有以下元素：</p> <blockquote><ul><li><strong>Name</strong>、<strong>Params、Results</strong> 参数和<a href="#funcinfo-structure">FuncInfo</a> 结构相同；</li> <li><strong>Auto</strong> -- 一个变量数组，如果有，则作为附加参数传递给函数，例如，<em>SmartContract</em> 类型的变量 <em>sc</em>；</li> <li><strong>Func</strong> -- golang函数。</li></ul></blockquote> <h4 id="varinfo-structure"><a href="#varinfo-structure" class="header-anchor">#</a> VarInfo结构 </h4> <p>指向 <strong>ObjVar</strong> 类型，<strong>Value</strong> 字段包含一个 <strong>VarInfo</strong> 结构。</p> <div class="language- extra-class"><pre class="language-text"><code>type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
</code></pre></div><p>VarInfo结构具有以下元素：</p> <blockquote><ul><li><strong>Obj</strong> -- 关于变量类型和变量值的信息；</li> <li><strong>Owner</strong> -- 指向所属块的指针。</li></ul></blockquote> <h4 id="objextend-value"><a href="#objextend-value" class="header-anchor">#</a> ObjExtend值 </h4> <p>指向 <strong>ObjExtend</strong> 类型，<strong>Value</strong> 字段包含一个字符串，其中包含变量或函数的名称。</p> <h2 id="virtual-machine-commands"><a href="#virtual-machine-commands" class="header-anchor">#</a> 虚拟机指令 </h2> <h3 id="bytecode-structure"><a href="#bytecode-structure" class="header-anchor">#</a> ByteCode结构 </h3> <p>字节码是 <strong>ByteCode</strong> 类型结构的序列。</p> <div class="language- extra-class"><pre class="language-text"><code>type ByteCode struct {
   Cmd uint16
   Value interface{}
}
</code></pre></div><p>该结构具有以下字段：</p> <blockquote><ul><li><strong>Cmd</strong> - 存储指令的标识符；</li> <li><strong>Value</strong> - 包含操作数（值）。</li></ul></blockquote> <p>通常情况，指令对堆栈的顶部元素执行操作，并在必要时将结果值写入其中。</p> <h3 id="command-identifiers"><a href="#command-identifiers" class="header-anchor">#</a> 指令标识符 </h3> <p><em>vm/cmds_list.go</em> 文件描述了虚拟机指令的标识符。</p> <blockquote><ul><li><strong>cmdPush</strong> -- 将 <em>Value</em> 字段的值放到堆栈。例如，将数字和行放入堆栈；</li> <li><strong>cmdVar</strong> -- 将变量的值放入堆栈。*Value* 包含一个指向 <em>VarInfo</em> 结构的指针以及关于该变量的信息；</li> <li><strong>cmdExtend</strong> -- 将外部变量的值放入堆栈。*Value* 包含一个带有变量名称的字符串（以 <code>$</code> 开头）；</li> <li><strong>cmdCallExtend</strong> -- 调用外部函数（名称以 <code>$</code> 开头）。函数的参数从堆栈中获取，函数的结果被放入堆栈。*Value* 包含一个函数名称（以 <code>$</code> 开头）；</li> <li><strong>cmdPushStr</strong> -- 将 <em>Value</em> 中的字符串放入堆栈；</li> <li><strong>cmdCall</strong> -- 调用虚拟机函数，*Value* 包含 <strong>ObjInfo</strong> 结构。该指令适用于 <strong>ObjExtFunc</strong> golang函数和 <strong>ObjFunc</strong> needle 函数。调用函数时，将从堆栈中获取其参数，并将结果值放入堆栈；</li> <li><strong>cmdCallVari</strong> -- 类似于 <strong>cmdCall</strong> 指令，调用虚拟机函数。该指令用于调用具有可变数量参数的函数；</li> <li><strong>cmdReturn</strong> -- 用于退出函数，返回值将放入到堆栈，不使用 <em>Value</em> 字段；</li> <li><strong>cmdIf</strong> -- 将控制权转移到 <strong>块</strong> 结构中的字节码，该指令在 <em>Value</em> 字段中传递。仅当 <em>valueToBool</em> 函数调用堆栈顶部元素返回 <code>true</code> 时才会将控制权转移到堆栈。否则控制权转移到下一个指令；</li> <li><strong>cmdElse</strong> -- 该指令的工作方式与 <strong>cmdIf</strong> 指令相同，但仅当 <em>valueToBool</em> 函数调用堆栈顶部元素返回 <code>false</code> 时控制权才会转移到指定的块；</li> <li><strong>cmdAssignVar</strong> -- 从 <em>Value</em> 获取 <strong>VarInfo</strong> 类型的变量列表。这些变量使用 <strong>cmdAssign</strong> 指令获取值；</li> <li><strong>cmdAssign</strong> -- 将堆栈中的值赋给 <strong>cmdAssignVar</strong> 指令获得的变量；</li> <li><strong>cmdLabel</strong> -- 控制权在while循环期间被返回时定义一个标记；</li> <li><strong>cmdContinue</strong> -- 该指令将控制权传递给 <strong>cmdLabel</strong> 标记。执行循环的新迭代时，不使用 <em>Value</em> ；</li> <li><strong>cmdWhile</strong> -- 使用 <em>valueToBool</em> 检查堆栈的顶部元素。如果该值为 <code>true</code>，则从 <em>value</em> 字段调用 <strong>块</strong> 结构；</li> <li><strong>cmdBreak</strong> -- 退出循环；</li> <li><strong>cmdIndex</strong> -- 通过索引将 <em>map</em> 或 <em>array</em> 中的值放入堆栈，不使用 <em>Value</em>。例如：<code>(map | array) (index value) =&gt; (map | array [index value])</code>；</li> <li><strong>cmdSetIndex</strong> -- 将堆栈顶部元素的值分配给 <em>map</em> 或 <em>array</em> 的元素，不使用 <em>Value</em>。例如：<code>(map | array) (index value) (value) =&gt; (map | array)</code>；</li> <li><strong>cmdFuncName</strong> -- 添加的参数通过用点 <code>.</code> 划分顺序来描述。例如：<code>func name =&gt; Func (...) .Name (...)</code>；</li> <li><strong>cmdUnwrapArr</strong> -- 如果堆栈顶部元素为数组，则定义一个布尔标记；</li> <li><strong>cmdMapInit</strong> -- 初始化 <em>map</em> 的值；</li> <li><strong>cmdArrayInit</strong> -- 初始化 <em>array</em> 的值；</li> <li><strong>cmdError</strong> -- 当智能合约或者函数以某个指定的 <code>error, warning, info</code> 错误终止时，该指令创建。</li></ul></blockquote> <h3 id="stack-operation-commands"><a href="#stack-operation-commands" class="header-anchor">#</a> 堆栈操作指令 </h3> <div class="language-text extra-class"><pre class="language-text"><code>在当前版本中，这些指令是不完全的自动类型转换。例如:
`string + float | int | decimal =&gt; float | int | decimal`，`float + int | str =&gt; float`，但是
`int + string =&gt; runtime error`。
</code></pre></div><p>下面是直接处理堆栈的指令。这些指令中不使用 <em>Value</em> 字段。</p> <ul><li><strong>cmdNot</strong> -- 逻辑否定。<code>(val) =&gt; (!ValueToBool(val))</code>；</li> <li><strong>cmdSign</strong> -- 符号变化。<code>(val) =&gt; (-val)</code>；</li> <li><strong>cmdAdd</strong> -- 加法。<code>(val1)(val2) =&gt; (val1 + val2)</code>；</li> <li><strong>cmdSub</strong> -- 减法。<code>(val1)(val2) =&gt; (val1 - val2)</code>；</li> <li><strong>cmdMul</strong> -- 乘法。<code>(val1)(val2) =&gt; (val1 * val2)</code>；</li> <li><strong>cmdDiv</strong> -- 除法。<code>(val1)(val2) =&gt; (val1 / val2)</code>；</li> <li><strong>cmdAnd</strong> -- 逻辑与。<code>(val1)(val2) =&gt; (valueToBool(val1) &amp;&amp; valueToBool(val2))</code>；</li> <li><strong>cmdOr</strong> -- 逻辑或。<code>(val1)(val2) =&gt; (valueToBool(val1) || valueToBool(val2))</code>；</li> <li><strong>cmdEqual</strong> -- 等式比较，返回bool。<code>(val1)(val2) =&gt; (val1 == val2)</code>；</li> <li><strong>cmdNotEq</strong> -- 不等式比较，返回bool。<code>(val1)(val2) =&gt; (val1 != val2)</code>；</li> <li><strong>cmdLess</strong> -- 小于式比较，返回bool。<code>(val1)(val2) =&gt; (val1 &lt; val2)</code>；</li> <li><strong>cmdNotLess</strong> -- 大于等于式比较，返回bool。<code>(val1)(val2) =&gt; (val1 &gt;= val2)</code>；</li> <li><strong>cmdGreat</strong> -- 大于式比较，返回bool。<code>(val1)(val2) =&gt; (val1 &gt; val2)</code>；</li> <li><strong>cmdNotGreat</strong> -- 小于等于式比较，返回bool。<code>(val1)(val2) =&gt; (val1 &lt;= val2)</code>。</li></ul> <h3 id="runtime-structure"><a href="#runtime-structure" class="header-anchor">#</a> Runtime结构 </h3> <p>执行字节码不会影响虚拟机。例如，它允许在单个虚拟机中同时运行各种函数和智能合约。<strong>Runtime</strong> 结构用于运行函数和智能合约，以及任何表达式和字节码。</p> <div class="language- extra-class"><pre class="language-text"><code>type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}
</code></pre></div><ul><li><strong>stack</strong> -- 执行字节码的堆栈；</li> <li><strong>blocks</strong> -- 块调用堆栈；</li> <li><strong>vars</strong> -- 变量堆栈。在块中调用字节码时，其变量将添加到该变量堆栈中。退出块后，变量堆栈的大小将返回到先前的值；</li> <li><strong>extend</strong> -- 指向外部变量值（<code>$name</code>）映射指针；</li> <li><strong>vm</strong> -- 虚拟机指针；</li> <li><strong>cost</strong> -- 执行结果的燃料单位；</li> <li><strong>err</strong> -- 执行时的错误。</li></ul> <h4 id="blockstack-structure"><a href="#blockstack-structure" class="header-anchor">#</a> blockStack结构 </h4> <p>blockStack结构用于 <strong>Runtime</strong> 结构。</p> <div class="language- extra-class"><pre class="language-text"><code>type blockStack struct {
     Block *Block
     Offset int
}
</code></pre></div><ul><li><strong>Block</strong> -- 正在执行的块的指针；</li> <li><strong>Offset</strong> -- 在指定块的字节码中执行的最后一个指令的偏移量。</li></ul> <h3 id="runcode-function"><a href="#runcode-function" class="header-anchor">#</a> RunCode函数 </h3> <p>字节码在 <strong>RunCode</strong>函数中执行。它包含一个循环，为每个字节码指令执行相应的操作。在处理字节码之前，必须初始化必要的数据。</p> <p>在这里新块被添加到其他块中。</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = append(rt.blocks, &amp;blockStack{block, len(rt.vars)})
</code></pre></div><p>接下来，获得尾部函数的相关参数信息。这些参数包含在堆栈的最后一个元素中。</p> <div class="language- extra-class"><pre class="language-text"><code>var namemap map[string][]interface{}
if block.Type == ObjFunc &amp;&amp; block.Info.(*FuncInfo).Names != nil {
    if rt.stack[len(rt.stack)-1] != nil {
        namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
    }
    rt.stack = rt.stack[:len(rt.stack)-1]
}
</code></pre></div><p>然后，必须使用初始值初始化当前块中定义的所有变量。</p> <div class="language- extra-class"><pre class="language-text"><code>start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
   rt.cost--
   var value interface{}
</code></pre></div><p>由于函数中的变量也是变量，所以我们需要按照函数本身所描述的顺序从堆栈的最后一个元素中取出它们。</p> <div class="language- extra-class"><pre class="language-text"><code>    if block.Type == ObjFunc &amp;&amp; vkey &lt; len(block.Info.(*FuncInfo).Params) {
      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
    } else {
</code></pre></div><p>在此使用初始值初始化局部变量。</p> <div class="language- extra-class"><pre class="language-text"><code>        value = reflect.New(vpar).Elem().Interface()
        if vpar == reflect.TypeOf(map[string]interface{}{}) {
           value = make(map[string]interface{})
        } else if vpar == reflect.TypeOf([]interface{}{}) {
           value = make([]interface{}, 0, len(rt.vars)+1)
        }
    }
rt.vars = append(rt.vars, value)
}
</code></pre></div><p>接下来，更新在尾部函数中传递的变量参数的值。</p> <div class="language- extra-class"><pre class="language-text"><code>if namemap != nil {
  for key, item := range namemap {
    params := (*block.Info.(*FuncInfo).Names)[key]
    for i, value := range item {
       if params.Variadic &amp;&amp; i &gt;= len(params.Params)-1 {
</code></pre></div><p>如果传递的变量参数为可变数量的参数，那么将它们组合成一个变量数组。</p> <div class="language- extra-class"><pre class="language-text"><code>                off := varoff + params.Offset[len(params.Params)-1]
                rt.vars[off] = append(rt.vars[off].([]interface{}), value)
            } else {
                rt.vars[varoff+params.Offset[i]] = value
            }
        }
    }
}
</code></pre></div><p>之后，我们要做的就是删除作为函数参数从堆栈顶部传递的值，从而移动堆栈。我们已经将它们的值复制到一个变量数组中。</p> <div class="language- extra-class"><pre class="language-text"><code>if block.Type == ObjFunc {
     start -= len(block.Info.(*FuncInfo).Params)
}
</code></pre></div><p>字节码指令循环执行结束后，我们必须正确地清除堆栈。</p> <div class="language- extra-class"><pre class="language-text"><code>last := rt.blocks[len(rt.blocks)-1]
</code></pre></div><p>将当前块从块堆栈中删除。</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
</code></pre></div><p>如果成功退出已执行的函数，我们将返回值添加到上一个堆栈的尾部。</p> <div class="language- extra-class"><pre class="language-text"><code>if last.Block.Type == ObjFunc {
   for count := len(last.Block.Info.(*FuncInfo).Results); count &gt; 0; count-- {
     rt.stack[start] = rt.stack[len(rt.stack)-count]
     start++
   }
   status = statusNormal
 } else {
</code></pre></div><p>如您所见，如果我们不执行函数，那么我们就不会恢复堆栈状态并按原样退出函数。原因是函数中已经执行的循环和条件结构也是字节码块。</p> <div class="language- extra-class"><pre class="language-text"><code>return
    }
}
rt.stack = rt.stack[:start]
</code></pre></div><h3 id="other-functions-for-operations-with-vm"><a href="#other-functions-for-operations-with-vm" class="header-anchor">#</a> VM的其他函数操作 </h3> <p>使用 <strong>NewVM</strong> 函数创建虚拟机。每个虚拟机都 <strong>Extend</strong> 函数添加了四个函数：<strong>ExecContract、MemoryUsage、CallContract</strong> 和 <strong>Settings</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>for key, item := range ext.Objects {
    fobj := reflect.ValueOf(item).Type()
</code></pre></div><p>我们遍历所有传递的对象，只查看函数。</p> <div class="language- extra-class"><pre class="language-text"><code>switch fobj.Kind() {
case reflect.Func:
</code></pre></div><p>根据接收到的相关该函数的信息填充 <strong>ExtFuncInfo</strong> 结构，并按名称将其结构添加到顶层的 <strong>Objects</strong> 映射。</p> <div class="language- extra-class"><pre class="language-text"><code>data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()), 
   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}
for i := 0; i &lt; fobj.NumIn(); i++ {
</code></pre></div><p><strong>ExtFuncInfo</strong> 结构有一个 <strong>Auto</strong> 参数数组。通常第一个参数为 <code>sc *SmartContract</code> 或 <code>rt *Runtime</code>，我们不能从 needle 语言中传递它们，因为在执行一些golang函数时它们对我们来说是必需的。因此，我们指定在调用函数时将自动使用这些变量。在这种情况下，上述四个函数的第一个参数为<code>rt *Runtime</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
  data.Auto[i] = isauto
}
</code></pre></div><p>赋值有关参数的信息。</p> <div class="language- extra-class"><pre class="language-text"><code>data.Params[i] = fobj.In(i)
}
</code></pre></div><p>以及返回值的类型。</p> <div class="language- extra-class"><pre class="language-text"><code>for i := 0; i &lt; fobj.NumOut(); i++ {
   data.Results[i] = fobj.Out(i)
}
</code></pre></div><p>向根 <strong>Objects</strong> 添加一个函数，这样编译器可以稍后在使用智能合约时找到它们。</p> <div class="language- extra-class"><pre class="language-text"><code>vm.Objects[key] = &amp;ObjInfo{ObjExtFunc, data}
    }
}
</code></pre></div><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> 编译器 </h2> <p><em>compile.go</em> 文件的函数负责编译从词法分析器获得的标记数组。编译可以有条件地分为两个级别，在高层级别，我们处理函数、智能合约、代码块、条件语句和循环语句、变量定义等等。在底层级别，我们编译循环和条件语句中的代码块或条件内的表达式。</p> <p>首先，让我们描述简单的低层级别。在 <strong>compileEval</strong> 函数可以完成将表达式转换为字节码。由于我们是使用堆栈的虚拟机，因此有必要将普通的中缀记录表达式转换为后缀表示法或逆波兰表示法。例如，<code>1+2</code> 转换为 <code>12+</code>，然后将 <code>1</code> 和 <code>2</code>放入堆栈，然后我们对堆栈中的最后两个元素应用加法运算，并将结果写入堆栈。这种<a href="https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/" target="_blank" rel="noopener noreferrer">转换算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 可以在互联网上找到。</p> <p>全局变量 <code>opers = map [uint32] operPrior</code> 包含转换成逆波兰表示法时所必需的操作的优先级。</p> <p>以下变量在 <strong>compileEval</strong> 函数开头定义：</p> <blockquote><ul><li><strong>buffer</strong> -- 字节码指令的临时缓冲区；</li> <li><strong>bytecode</strong> -- 字节码指令的最终缓冲区；</li> <li><strong>parcount</strong> -- 调用函数时用于计算参数的临时缓冲区；</li> <li><strong>setIndex</strong> -- 当我们分配 <em>map</em> 或 <em>array</em> 元素时，工作过程中的变量被设置为 [true]{.title-ref}。例如，<code>a[&quot;my&quot;] = 10</code>，在这种情况下，我们需要使用指定的 <strong>cmdSetIndex</strong> 指令。</li></ul></blockquote> <p>我们在一个循环体中获得一个标记并作出相应的处理，例如，如果找到大括号，然后停止解析表达式。在移动字符串时，我们会查看前一个语句是否是一个操作符以及是否在括号内，否则我们退出并解析表达式。</p> <div class="language- extra-class"><pre class="language-text"><code>case isRCurly, isLCurly:
     i--
     if prevLex == isComma || prevLex == lexOper {
                return errEndExp
           }
    break main
case lexNewLine:
      if i &gt; 0 &amp;&amp; ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {
           continue main
      }
     for k := len(buffer) - 1; k &gt;= 0; k-- {
          if buffer[k].Cmd == cmdSys {
              continue main
         }
     }
    break main
</code></pre></div><p>通常情况下，该算法本身对应于一种转换为逆波兰表示法的算法。考虑到一些必要的智能合约、函数、索引的调用，以及解析时不会遇到的其他事情和解析 <em>lexIdent</em> 类型标记的选项，我们将检查具有此名称的变量、函数或智能合约。如果没有找到任何相关内容而且这不是函数或智能合约调用，那么我们会指出错误。</p> <div class="language- extra-class"><pre class="language-text"><code>objInfo, tobj := vm.findObj(lexem.Value.(string), block)
if objInfo == nil &amp;&amp; (!vm.Extern || i &gt; *ind || i &gt;= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {
      return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))
}
</code></pre></div><p>我们可能会遇到这样的情况，稍后将描述智能合约调用。在本例中，如果没有找到同名函数和变量，那么我们认为将调用智能合约。在该编译语言中，智能合约和函数调用没有区别。但是我们需要通过在字节码中使用的<strong>ExecContract</strong> 函数来调用智能合约。</p> <blockquote><div class="language- extra-class"><pre class="language-text"><code>if objInfo.Type == ObjContract {
    if objInfo.Value != nil {
              objContract = objInfo.Value.(*Block)
            }
    objInfo, tobj = vm.findObj(`ExecContract`, block)
    isContract = true
}
</code></pre></div></blockquote> <p>我们将到目前为止的变量数量记录在 <code>count</code>中，该值也会随着函数参数数量一起写入堆栈。在每次后续检测参数时，我们只需在堆栈的最后一个元素中将该数量增加一个单位。</p> <div class="language- extra-class"><pre class="language-text"><code>count := 0
if (*lexems)[i+2].Type != isRPar {
    count++
}
</code></pre></div><p>我们有已调用智能合约的列表参数 <em>Used</em>，因此我们需要为智能合约被调用的情况做标记。如果在没有参数的情况下调用智能合约，我们必须添加两个空参数去调用 <strong>ExecContract</strong>，以获得最少两个参数。</p> <div class="language- extra-class"><pre class="language-text"><code>if isContract {
   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))
   for j := len(*block) - 1; j &gt;= 0; j-- {
      topblock := (*block)[j]
      if topblock.Type == ObjContract {
            if topblock.Info.(*ContractInfo).Used == nil {
                 topblock.Info.(*ContractInfo).Used = make(map[string]bool)
            }
           topblock.Info.(*ContractInfo).Used[name] = true
       }
    }
    bytecode = append(bytecode, &amp;ByteCode{cmdPush, name})
    if count == 0 {
       count = 2
       bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
       bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
     }
    count++

}
</code></pre></div><p>If we see that there is a square bracket next, then we add the <strong>cmdIndex</strong> command to get the value by the index.</p> <div class="language- extra-class"><pre class="language-text"><code>if (*lexems)[i+1].Type == isLBrack {
     if objInfo == nil || objInfo.Type != ObjVar {
         return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))
     }
    buffer = append(buffer, &amp;ByteCode{cmdIndex, 0})
}
</code></pre></div><p><strong>CompileBlock</strong> 函数可以生成对象树和与表达式无关的字节码。编译过程基于有限状态机，就像词法分析器一样，但是有以下不同之处。第一，我们不使用符号但使用标记；第二，我们会立即描述所有状态和转换中的 <em>states</em> 变量。它表示一个按标记类型索引的对象数组，每个标记都具有 <em>compileState</em> 的结构，并在 <em>NewState</em> 中指定一个新状态。如果我们已经解析清楚这是什么结构，那么就可以指定 <em>Func</em> 字段中处理程序的函数。</p> <p>让我们以主状态为例回顾一下。</p> <p>如果我们遇到换行符或注释，那么我们会保持相同的状态。如果我们遇到 <strong>contract</strong> 关键字，那么我们将状态更改为 <em>stateContract</em> 并开始解析该结构。如果我们遇到 <strong>func</strong> 关键字，那么我们将状态更改为 <em>stateFunc</em>。如果接收到其他标记，那么将调用生成错误的函数。</p> <div class="language- extra-class"><pre class="language-text"><code>{ // stateRoot
   lexNewLine: {stateRoot, 0},
   lexKeyword | (keyContract &lt;&lt; 8): {stateContract | statePush, 0},
   lexKeyword | (keyFunc &lt;&lt; 8): {stateFunc | statePush, 0},
   lexComment: {stateRoot, 0},
   0: {errUnknownCmd, cfError},
},
</code></pre></div><p>假设我们遇到了 <strong>func</strong> 关键字，并且我们已将状态更改为 <em>stateFunc</em>。由于函数名必须跟在 <strong>func</strong> 关键字后面，因此在更改该函数名时，我们将保持相同的状态。对于所有其他标记，我们生成相应的错误。如果我们在标记标识符中获取了函数名称，那么我们转到 <em>stateFParams</em> 状态，其中我们可以获取函数的参数。</p> <div class="language- extra-class"><pre class="language-text"><code>{ // stateFunc
    lexNewLine: {stateFunc, 0},
    lexIdent: {stateFParams, cfNameBlock},
    0: {errMustName, cfError},
},
</code></pre></div><p>上述操作的同时，我们将调用 <strong>fNameBlock</strong> 函数。应该注意的是，<em>块Block</em> 结构是使用 <em>statePush</em> 标记创建的，在这里我们从缓冲区中获取它并填充我们需要的数据。<strong>fNameBlock</strong> 函数适用于智能合约和函数(包括嵌套在其中的函数和智能合约)。它使用相应的结构填充 <em>Info</em> 字段，并将其自身写入父块的 <em>Objects</em> 中。这样以便我们可以通过指定的名称调用该函数或智能合约。同样，我们为所有状态和变量创建对应的函数。这些函数通常非常小，并且在构造虚拟机树时执行一些工作。</p> <div class="language- extra-class"><pre class="language-text"><code>func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {
    var itype int

    prev := (*buf)[len(*buf)-2]
    fblock := (*buf)[len(*buf)-1]
   name := lexem.Value.(string)
   switch state {
     case stateBlock:
        itype = ObjContract
       name = StateName((*buf)[0].Info.(uint32), name)
       fblock.Info = &amp;ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,
           Owner: (*buf)[0].Owner}
    default:
       itype = ObjFunc
       fblock.Info = &amp;FuncInfo{}
     }
     fblock.Type = itype
    prev.Objects[name] = &amp;ObjInfo{Type: itype, Value: fblock}
    return nil
}
</code></pre></div><p>对于 <strong>CompileBlock</strong> 函数，它只是遍历所有标记并根据 <em>states</em> 中描述的标记切换状态。几乎所有附加标记对应附加程序代码。</p> <blockquote><ul><li><strong>statePush</strong> -- 将 <strong>块Block</strong> 对象添加到对象树中；</li> <li><strong>statePop</strong> -- 当块以结束花括号结束时使用；</li> <li><strong>stateStay</strong> -- 当更改为新状态时，您需要保留当前标记；</li> <li><strong>stateToBlock</strong> -- 转换到 <strong>stateBlock</strong> 状态，用于处理 <em>while</em> 和 <em>if</em>。当处理完表达式后，需要在大括号内处理块使用；</li> <li><strong>stateToBody</strong> -- 转换到 <strong>stateBody</strong> 状态；</li> <li><strong>stateFork</strong> -- 保存标记的位置。当表达式以标识符或带有 <code>$</code> 名称开头时使用，我们可以进行函数调用或赋值；</li> <li><strong>stateToFork</strong> -- 用于获取存储在 <strong>stateFork</strong> 中的标记。该标记将传递给进程函数；</li> <li><strong>stateLabel</strong> -- 用于插入 <strong>cmdLabel</strong> 指令。*while* 结构需要这个标记；</li> <li><strong>stateMustEval</strong> -- 在 <em>if</em> 和 <em>while</em> 结构的开头检查条件表达式的可用性。</li></ul></blockquote> <p>除了 <strong>CompileBlock</strong> 函数，还应该提到 <strong>FlushBlock</strong> 函数。但问题是块树是独立于现有虚拟机构建的，更准确地说，我们获取有关虚拟机中存在的函数和智能合约的信息，但我们将已编译的块收集到一个单独的树中。否则，如果在编译期间发生错误，我们必须将虚拟机的状态回滚到以前的状态。因此，我们单独去编译树，但编译成功后必须调用<strong>FlushContract</strong>函数。这个函数将完成的块树添加到当前虚拟机中。此时编译阶段就完成了。</p> <h2 id="lexical-analyzer"><a href="#lexical-analyzer" class="header-anchor">#</a> 词法分析器 </h2> <p>词法分析器将传入的字符串处理并形成以下类型的标记序列：</p> <blockquote><ul><li><strong>lexSys</strong> - 系统标记，例如：<code>{}</code>，<code>[]</code>，<code>()</code>，<code>,</code>，<code>.</code> 等；</li> <li><strong>lexOper</strong> -- 操作标记，例如：<code>+</code>，<code>-</code>，<code>/</code>，<code>\</code>，<code>*</code>；</li> <li><strong>lexNumber</strong> -- 数字；</li> <li><strong>lexident</strong> -- 标识符；</li> <li><strong>lexNewline</strong> -- 换行符；</li> <li><strong>lexString</strong> -- 字符串；</li> <li><strong>lexComment</strong> -- 注释；</li> <li><strong>lexKeyword</strong> -- 关键字；</li> <li><strong>lexType</strong> -- 类型；</li> <li><strong>lexExtend</strong> -- 引用外部变量或函数，例如：<code>$myname</code>。</li></ul></blockquote> <p>在当前版本中，初步借助于 <a href="#lextable-lextable-go">script/lextable/lextable.go</a> 文件构造了一个转换表(有限状态机)来解析标记，并将其写入 <em>lex_table.go</em> 文件。通常情况下，您可以脱离该文件初始生成的转换表，可以在启动时立即在内存(<code>init()</code>)中创建一个转换表。词法分析本身发生在<a href="#lex-go">lex.go</a> 文件中的 <strong>lexParser</strong>函数中。</p> <h3 id="lextable-lextable-go"><a href="#lextable-lextable-go" class="header-anchor">#</a> lextable/lextable.go </h3> <p>在这里我们定义了我们的语言用于操作的字母表，并描述有限状态机根据下一个接收到的符号从一种状态变化到另一种状态。</p> <p><em>states</em> 包含一个状态列表的JSON对象。</p> <p>除特定符号外，<code>d</code> 用于表示状态中未指明的所有符号。</p> <p><code>n</code> 代表0x0a，<code>s</code> 代表空格，<code>q</code> 代表反引号，<code>Q</code> 代表双引号，<code>r</code> 代表字符 &gt;= 128，<code>a</code> 代表AZ和az，<code>1</code> 代表1-9。</p> <p>状态的名称是键，值对象中列出了可能的值。然后，对于每一组，都有一种新的状态需要转换。然后是标记的名称，如果我们需要返回到初始状态，第三个参数是服务标志，它指示了如何处理当前符号。</p> <p>例如，我们有主状态和传入字符 <code>/</code>，<code>&quot;/&quot;: [&quot;solidus&quot;, &quot;&quot;, &quot;push next&quot;],</code></p> <blockquote><ul><li><strong>push</strong> - 给指令记住它在一个单独的堆栈；</li> <li><strong>next</strong> - 转到下一个字符，同时我们将状态更改为
<strong>solidus</strong>，之后，获取下一个角色并查看 <strong>solidus</strong> 的状态。</li></ul></blockquote> <p>如果下一字符有 <code>/</code> 或 <code>/*</code>，那么我们转到注释 <strong>comment</strong> 状态，因为它们以 <code>//</code> 或 <code>/*</code>开头。显然，每个注释后续都有不同的状态，因为它们以不同的符号结束。</p> <p>如果下一字符不是 <code>/</code> 和 <code>*</code>，那么我们将堆栈中的所有内容记录为 <strong>lexOper</strong> 类型的标记，清除堆栈并返回主状态。</p> <p>以下模块将状态树转换为一个数值数组，并将其写入 <em>lex_table.go</em> 文件。</p> <p>在第一个循环体中：</p> <p>我们形成有效符号的字母表。</p> <div class="language- extra-class"><pre class="language-text"><code>for ind, ch := range alphabet {
i := byte(ind)
</code></pre></div><p>此外，在 <strong>state2int</strong> 中，我们为每个状态提供了自己的序列标识符。</p> <div class="language- extra-class"><pre class="language-text"><code>state2int := map[string]uint{`main`: 0}
if err := json.Unmarshal([]byte(states), &amp;data); err == nil {
for key := range data {
if key != `main` {
state2int[key] = uint(len(state2int))
</code></pre></div><p>当我们遍历所有状态和状态中的每个集合以及该集合中的每个符号时，我们写入一个三字节的数字[新状态标识符（0= main）] + [标记类型（0-没有标记）] + [标记]。</p> <p><em>table</em> 数组的二维性在于它分为状态和来自 <em>alphabet</em> 数组的34个输入符号，它们以相同的顺序排列。</p> <p>我们处于 <em>table</em> 零行上的 <em>main</em> 状态。取第一个字符，在 <em>alphabet</em> 数组中查找其索引，并从给定索引的列中获取值。从接收到的值开始，我们在低位字节接收标记。如果解析完成，第二个字节表示接收到的标记类型。在第三个字节中，我们接收下一个新状态的索引。</p> <p>所有这些在 <em>lex.go</em> 中的 <strong>lexParser</strong> 函数中有更详细的描述。</p> <p>如果想要添加一些新字符，则需要将它们添加到 <em>alphabet</em> 数组并增加 <em>AlphaSize</em> 常量。如果要添加新的符号组合，则应在状态中对其进行描述，类似于现有选项。在此之后，运行 <em>lextable.go</em> 文件来更新 <em>lex_table.go</em> 文件。</p> <h3 id="lex-go"><a href="#lex-go" class="header-anchor">#</a> lex.go </h3> <p><strong>lexParser</strong>
函数直接生成词法分析，并根据传入的字符串返回一个已接收标记的数组。让我们分析标记的结构。</p> <div class="language- extra-class"><pre class="language-text"><code>type Lexem struct {
   Type uint32 // Type of the lexem
   Value interface{} // Value of lexem
   Line uint32 // Line of the lexem
   Column uint32 // Position inside the line
}
</code></pre></div><ul><li><strong>Type</strong> -- 标记类型。它有以下值之一：<code>lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend</code>；</li> <li><strong>Value</strong> -- 标记的值。值的类型取决于标记类型，让我们更详细地分析一下：
<ul><li><strong>lexSys</strong> -- 包括括号，逗号等。在这种情况下，<code>Type = ch &lt;&lt; 8 | lexSys</code>，请参阅 <code>isLPar ... isRBrack</code> 常量，该值为uint32位；</li> <li><strong>lexOper</strong> -- 值以uint32的形式表示等价的字符序列。请参阅 <code>isNot ... isOr</code> 常量；</li> <li><strong>lexNumber</strong> -- 数字存储为 <em>int64</em> 或 <em>float64</em>。如果数字有一个小数点，那么为 <em>float64</em>；</li> <li><strong>lexIdent</strong> -- 标识符存储为 <em>字符串string</em>；</li> <li><strong>lexNewLine</strong> -- 换行符。还用于计算行和标记位置；</li> <li><strong>lexString</strong> -- 行存储为 <em>字符串string</em>；</li> <li><strong>lexComment</strong> -- 注释存储为 <em>字符串string</em>；</li> <li><strong>lexKeyword</strong> -- 关键字仅存储相应的索引，请参阅 <code>keyContract ... keyTail</code> 常量。在这种情况下 <code>Type = KeyID &lt;&lt; 8 | lexKeyword</code>。另外，应该注意的是，<code>true,false,nil</code> 关键字会立即转换为 <strong>lexNumber</strong> 类型的标记，并使用相应的 <code>bool</code> 和 <code>intreface {}</code> 类型；</li> <li><strong>lexType</strong> -- 该值包含相应的 <code>reflect.Type</code> 类型值；</li> <li><strong>lexExtend</strong> -- 以美元符号 <code>$</code> 开头的标识符。这些变量和函数从外部传递，因此分配给特殊类型的标记。该值包含字符串形式的名称，开头没有美元符号。</li></ul></li> <li><strong>Line</strong> -- 标记所在行；</li> <li><strong>Column</strong> -- 标记的行内位置。</li></ul> <p>让我们详细分析 <strong>lexParser</strong> 函数。<strong>todo</strong> 函数根据当前状态和传入符号，查找字母表中的符号索引，并从转换表中获取一个新状态、标记标识符(如果有的话)和其他标记。解析本身包括对每下一个字符依次调用 <strong>todo</strong> 函数，并切换到新的状态。一旦接收到标记，我们就在输出准则中创建相应的标记并继续解析。应该注意的是，在解析过程中，我们不将标记符号累积到单独的堆栈或数组中，因为我们只是保存标记开始的偏移量。获得标记之后，我们将下一个标记的偏移量移动到当前解析位置。</p> <p>剩下的就是检查解析中使用的词法状态标志：</p> <blockquote><ul><li><strong>lexfPush</strong> -- 该标志意味着我们开始在一个新的标记中累积符号；</li> <li><strong>lexfNext</strong> -- 必须将该字符添加到当前标记；</li> <li><strong>lexfPop</strong> -- 接收标记完成，通常，使用该标志我们有解析标记的标识符类型；</li> <li><strong>lexfSkip</strong> -- 该标志用于从解析中排除字符，例如，字符串中的控件斜线为 <code>\n \r \&quot;</code>。它们会在该词法分析阶段自动替换。</li></ul></blockquote> <h2 id="needle-language"><a href="#needle-language" class="header-anchor">#</a> needle 语言 </h2> <h3 id="lexemes"><a href="#lexemes" class="header-anchor">#</a> 词法 </h3> <p>程序的源代码必须采用UTF-8编码。</p> <p>以下词法类型:</p> <blockquote><ul><li><strong>关键字</strong> - <code>action</code>, <code>break</code>, <code>conditions</code>, <code>continue</code>,<code>contract</code>, <code>data</code>, <code>else</code>, <code>error</code>, <code>false</code>, <code>func</code>, <code>if</code>,<code>info</code>, <code>nil</code>, <code>return</code>, <code>settings</code>, <code>true</code>, <code>var</code>, <code>warning</code>,<code>while</code>；</li> <li><strong>数字</strong> - 只接收十进制数字。有两种基本类型: <strong>int</strong> 和 <strong>float</strong>。 如果数字有一个小数点，它就变成了浮点数。
<strong>float</strong>。*<em>int</em>* 类型等价于golang中的 <strong>int64</strong>。*<em>float</em>*
类型等价于golang中的 <strong>float64</strong>。</li> <li><strong>字符串</strong> - 字符串可以用双引号 (<code>&quot;a string&quot;</code>) 或反引号(`a string`)。这两种类型的字符串都可以包含换行符。双引号中的字符串可以包含双引号、换行符和用斜杠转义的回车符。例如，[&quot;This is a &quot;first string&quot;.rnThis is a second string.&quot;]{.title-ref}。</li> <li><strong>注释</strong> - 有两种类型的评论。单行注释使用两个斜杠符号(<code>//</code>)。例如，<code>// 这是单行注释</code>。多行注释使用斜杠和星号符号，可以跨越多行。例如，<code>/* 这是多行注释 */</code>.</li> <li><strong>标识符</strong> - 由a-z和A-Z字母、UTF-8符号、数字和下划线组成的变量和函数的名称。名称可以以字母、下划线、<code>@</code> 或 <code>$</code> 符号开头。以 <code>$</code> 开头的名称为在 <strong>数据部分</strong>中定义的变量的名称。以 <code>$</code> 开头的名称还可以用于定义 <strong>条件部分</strong>和 <strong>操作部分</strong> 范围内的全局变量。生态系统的智能合约可以使用 <code>@</code>符号来调用。例如: <code>@1NewTable(...)</code>。</li></ul></blockquote> <h3 id="types"><a href="#types" class="header-anchor">#</a> 类型 </h3> <p>在 needle 类型旁边指定了相应的golang类型。</p> <ul><li><strong>bool</strong> - bool，默认值为 <strong>false</strong>；</li> <li><strong>bytes</strong> - []byte{}，默认值为空字节数组；</li> <li><strong>int</strong> - int64，默认值为 <strong>0</strong>；</li> <li><strong>address</strong> - uint64，默认值为 <strong>0</strong>；</li> <li><strong>array</strong> - []interface{}，默认值为空数组；</li> <li><strong>map</strong> - map[string]interface{}，默认值为空对象数组；</li> <li><strong>money</strong> - decimal.Decimal，默认值为 <strong>0</strong>；</li> <li><strong>float</strong> - float64，默认值为 <strong>0</strong>；</li> <li><strong>string</strong> - string，默认值为空字符串；</li> <li><strong>file</strong> - map[string]interface{}，默认值为空对象数组。</li></ul> <p>这些类型的变量用 <code>var</code> 关键字定义。例如，<code>var var1, var2 int</code>。当这样定义一个变量时，它将获得其类型的默认值。</p> <p>所有变量值都具有 <em>interface{}</em> 类型，然后将它们分配给所需的golang类型。因此，例如 <em>array</em> 和 <em>map</em> 类型是golang类型 <em>[]interface{}</em> 和 <em>map[string]interface{}</em>。这两种类型的数组都可以包含任何类型的元素。</p> <h3 id="expressions"><a href="#expressions" class="header-anchor">#</a> 表达式 </h3> <p>表达式可以包含算术运算、逻辑运算和函数调用。根据操作优先级从左到右计算所有表达式。如果操作优先级相同，评估也从左到右。</p> <p>从最高优先级到最低优先级的操作列表:</p> <ul><li><strong>函数调用和圆括号</strong> - 调用函数时，将从左到右计算传递的参数；</li> <li><strong>一元运算</strong> - 逻辑否定 <code>!</code> 和算术符号变化 <code>-</code>；</li> <li><strong>乘法和除法</strong> - 算术乘法 <code>*</code> 和除法 <code>/</code>；</li> <li><strong>加法和减法</strong> - 算术加法 <code>+</code> 和减法 <code>-</code>；</li> <li><strong>逻辑比较</strong> - <code>&gt;= &gt; &gt; &gt;=</code>；</li> <li><strong>逻辑相等和不相等</strong> - <code>== !=</code>；</li> <li><strong>逻辑与</strong> - <code>&amp;&amp;</code>；</li> <li><strong>逻辑或</strong> - <code>||</code>。</li></ul> <p>当评估逻辑与和逻辑或时，在任何情况下都会计算表达式的两侧。</p> <p>needle 在编译时没有类型检查。在评估操作数时，会尝试将类型转换为更复杂的类型。复杂度顺序的类型可以按照如下：<code>string, int, float, money</code>，仅实现了部分类型转换。字符串类型支持加法操作，结果会使得字符串连接。例如，<code>string + string = string, money - int = money, int * float = float</code>。</p> <p>对于函数，在执行时会对 <code>string</code> 和 <code>int</code> 类型执行类型检查。</p> <p><strong>array</strong> 和 <strong>map</strong> 类型可以通过索引来寻址。对于 <strong>array</strong> 类型，必须将 <strong>int</strong> 值指定为索引。对于 <strong>map</strong> 类型，必须指定变量或 <strong>string</strong>值。如果将值赋给索引大于当前最大索引的 <strong>array</strong>元素，则将向数组添加空元素。这些元素的初始化值为 <strong>nil</strong> 。例如: .. code:</p> <div class="language- extra-class"><pre><code>var my array
my[5] = 0
var mymap map
mymap[&quot;index&quot;] = my[3]
</code></pre></div><p>在条件逻辑值的表达式中（例如<code>if，while，&amp;&amp;，||，!</code>），类型会自动转换为逻辑值，如果类型不为默认值，则为true。</p> <div class="language- extra-class"><pre class="language-text"><code>var mymap map
var val string
if mymap &amp;&amp; val {
...
}
</code></pre></div><h3 id="scope"><a href="#scope" class="header-anchor">#</a> 范围 </h3> <p>大括号指定一个可以包含局部范围变量的块。默认情况下，变量的范围扩展到它自己的块和所有嵌套的块。在一个块中，可以使用现有变量的名称定义一个新变量。在这种情况下，具有相同名称的外部变量不可用。</p> <div class="language- extra-class"><pre class="language-text"><code>var a int
a = 3
{
   var a int
   a = 4
   Println(a) // 4
}
Println(a) // 3
</code></pre></div><h3 id="contract-execution"><a href="#contract-execution" class="header-anchor">#</a> 智能合约执行 </h3> <p>当调用智能合约时，必须将 <strong>data</strong> 部分中定义的参数传递给它。在执行合约之前，虚拟机接收这些参数并将它们分配给相应的变量($Param)。然后调用预定义的 <strong>conditions</strong> 函数和 <strong>action</strong> 函数。</p> <p>合约执行期间发生的错误可分为两种类型：形式错误和环境错误。形式错误使用特殊命令生成：<code>error, warning, info</code> 以及当内置函数返回 <code>err</code> 不等于 <em>nil</em> 时。</p> <p>needle 语言不处理异常。任何错误都会终止合约的执行。由于在执行合约时创建了用于保存变量值的单独堆栈和结构，所以当合约执行完成时，golang垃圾回收机制将自动删除这些数据。</p> <h3 id="backus-naur-form-bnf"><a href="#backus-naur-form-bnf" class="header-anchor">#</a> 巴科斯范式Backus--Naur Form (BNF) </h3> <p>在计算机科学中，BNF是一种用于无上下文语法的符号技术，通常用于描述计算中使用的语言的语法。</p> <ul><li><p>&lt;decimal digit&gt; :</p> <div class="language- extra-class"><pre><code>'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
</code></pre></div></li> <li><p>&lt;decimal number&gt; :</p> <div class="language- extra-class"><pre><code>&lt;decimal digit&gt; {&lt;decimal digit&gt;}
</code></pre></div></li> <li><p>&lt;symbol code&gt; :</p> <div class="language- extra-class"><pre><code>'''&lt;any symbol&gt;'''
</code></pre></div></li> <li><p>&lt;real number&gt; :</p> <div class="language- extra-class"><pre><code>['-'] &lt;decimal number'.'[&lt;decimal number&gt;]
</code></pre></div></li> <li><p>&lt;integer number&gt; :</p> <div class="language- extra-class"><pre><code>['-'] &lt;decimal number&gt; | &lt;symbol code&gt;
</code></pre></div></li> <li><p>&lt;number&gt; :</p> <div class="language- extra-class"><pre><code>'&lt;integer number&gt; | &lt;real number&gt;'
</code></pre></div></li> <li><p>&lt;letter&gt; :</p> <div class="language- extra-class"><pre><code>'A' | 'B' | ... | 'Z' | 'a' | 'b' | ... | 'z' | 0x80 | 0x81 | ... | 0xFF
</code></pre></div></li> <li><p>&lt;space&gt; :</p> <div class="language- extra-class"><pre><code>'0x20'
</code></pre></div></li> <li><p>&lt;tabulation&gt; :</p> <div class="language- extra-class"><pre><code>'0x09'
</code></pre></div></li> <li><p>&lt;newline&gt; :</p> <div class="language- extra-class"><pre><code>'0x0D 0x0A'
</code></pre></div></li> <li><p>&lt;special symbol&gt; :</p> <div class="language- extra-class"><pre><code>'!' | '&quot;' | '$' | ''' | '(' | ')' | '\*' | '+' | ',' | '-' | '.' | '/' | '&lt;' | '=' | '&gt;' | '[' | '\\' | ']' | '_' | '|' | '}' | '{' | &lt;tabulation&gt; | &lt;space&gt; | &lt;newline&gt;
</code></pre></div></li> <li><p>&lt;symbol&gt; :</p> <div class="language- extra-class"><pre><code>&lt;decimal digit&gt; | &lt;letter&gt; | &lt;special symbol&gt;
</code></pre></div></li> <li><p>&lt;name&gt; :</p> <div class="language- extra-class"><pre><code>(&lt;letter&gt; | '_') {&lt;letter&gt; | '_' | &lt;decimal digit&gt;}
</code></pre></div></li> <li><p>&lt;function name&gt; :</p> <div class="language- extra-class"><pre><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;variable name&gt; :</p> <div class="language- extra-class"><pre><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;type name&gt; :</p> <div class="language- extra-class"><pre><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;string symbol&gt; :</p> <div class="language- extra-class"><pre><code>&lt;tabulation&gt; | &lt;space&gt; | '!' | '#' | ... | '[' | ']' | ... 
</code></pre></div></li> <li><p>&lt;string element&gt; :</p> <div class="language- extra-class"><pre><code>{&lt;string symbol&gt; | '\&quot;' | '\n' | '\r' }
</code></pre></div></li> <li><p>&lt;string&gt; :</p> <div class="language- extra-class"><pre><code>'&quot;' { &lt;string element&gt; } '&quot;' | '\`'  { &lt;string element&gt; } '\`'
</code></pre></div></li> <li><p>&lt;assignment operator&gt; :</p> <div class="language- extra-class"><pre><code>'=' 
</code></pre></div></li> <li><p>&lt;unary operator&gt; :</p> <div class="language- extra-class"><pre><code>'-'
</code></pre></div></li> <li><p>&lt;binary operator&gt; :</p> <div class="language- extra-class"><pre><code>'==' | '!=' | '&gt;' | '&lt;' | '&lt;=' | '&gt;=' | '&amp;&amp;' | '||' | '\*' | '/' | '+' | '-' 
</code></pre></div></li> <li><p>&lt;operator&gt; :</p> <div class="language- extra-class"><pre><code>&lt;assignment operator&gt; | &lt;unary operator&gt; | &lt;binary operator&gt;
</code></pre></div></li> <li><p>&lt;parameters&gt; :</p> <div class="language- extra-class"><pre><code>&lt;expression&gt; {','&lt;expression&gt;}
</code></pre></div></li> <li><p>&lt;contract call&gt; :</p> <div class="language- extra-class"><pre><code>&lt;contract name&gt; '(' [&lt;parameters&gt;] ')'
</code></pre></div></li> <li><p>&lt;function call&gt; :</p> <div class="language- extra-class"><pre><code>&lt;contract call&gt; [{'.' &lt;name&gt; '(' [&lt;parameters&gt;] ')'}]
</code></pre></div></li> <li><p>&lt;block contents&gt; :</p> <div class="language- extra-class"><pre><code>&lt;block command&gt; {&lt;newline&gt;&lt;block command&gt;}
</code></pre></div></li> <li><p>&lt;block&gt; :</p> <div class="language- extra-class"><pre><code>'{'&lt;block contents&gt;'}'
</code></pre></div></li> <li><p>&lt;block command&gt; :</p> <div class="language- extra-class"><pre><code>(&lt;block&gt; | &lt;expression&gt; | &lt;variables definition&gt; | &lt;if&gt; | &lt;while&gt; | break | continue | return)
</code></pre></div></li> <li><p>&lt;if&gt; :</p> <div class="language- extra-class"><pre><code>'if &lt;expression&gt;&lt;block&gt; [else &lt;block&gt;]'
</code></pre></div></li> <li><p>&lt;while&gt; :</p> <div class="language- extra-class"><pre><code>'while &lt;expression&gt;&lt;block&gt;'
</code></pre></div></li> <li><p>&lt;contract&gt; :</p> <div class="language- extra-class"><pre><code>'contract &lt;name&gt; '{'[&lt;data section&gt;] {&lt;function&gt;} [&lt;conditions&gt;] [&lt;action&gt;]'}''
</code></pre></div></li> <li><p>&lt;data section&gt; :</p> <div class="language- extra-class"><pre><code>'data '{' {&lt;data parameter&gt;&lt;newline&gt;} '}''
</code></pre></div></li> <li><p>&lt;data parameter&gt; :</p> <div class="language- extra-class"><pre><code>&lt;variable name&gt; &lt;type name&gt; '&quot;'{&lt;tag&gt;}'&quot;' 
</code></pre></div></li> <li><p>&lt;tag&gt; :</p> <div class="language- extra-class"><pre><code>'optional | image | file | hidden | text | polymap | map | address | signature:&lt;name&gt;'
</code></pre></div></li> <li><p>&lt;conditions&gt; :</p> <div class="language- extra-class"><pre><code>'conditions &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;action&gt; :</p> <div class="language- extra-class"><pre><code>'action &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;function&gt; :</p> <div class="language- extra-class"><pre><code>'func &lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'[{&lt;tail&gt;}] [&lt;type name&gt;] &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;variable description&gt; :</p> <div class="language- extra-class"><pre><code>&lt;variable name&gt; {',' &lt;variable name&gt;} &lt;type name&gt;
</code></pre></div></li> <li><p>&lt;tail&gt; :</p> <div class="language- extra-class"><pre><code>'.'&lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'
</code></pre></div></li> <li><p>&lt;variables definition&gt; :</p> <div class="language- extra-class"><pre><code>'var &lt;variable description&gt;{','&lt;variable description&gt;}'
</code></pre></div></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/IBAX-io/documentation/edit/master/docs/zh-CN/topics/vm.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/7/4 11:08:51</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/zh-CN/topics/templates2.html" class="prev">
        模版语言 
      </a></span> <span class="next"><a href="/zh-CN/topics/daemons.html">
        守护进程 
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d049f7ab.js" defer></script><script src="/assets/js/2.8d94a0db.js" defer></script><script src="/assets/js/166.013113d8.js" defer></script>
  </body>
</html>
