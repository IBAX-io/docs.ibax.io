<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Compilateur et Machine Virtuelle </a></li><li><a href="/fr/topics/templates2.html" class="sidebar-link">Langage de modèle </a></li><li><a href="/fr/topics/vm.html" aria-current="page" class="active sidebar-link">Compilateur et Machine Virtuelle </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#source-code-storage-and-compilation" class="sidebar-link">Stockage et compilation du code source </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#virtual-machine-structures" class="sidebar-link">Structures de machines virtuelles </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#vm-structure" class="sidebar-link">Structure VM </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#block-structure" class="sidebar-link">Structure de bloc </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#objinfo-structure" class="sidebar-link">Structure ObjInfo </a></li></ul></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#virtual-machine-commands" class="sidebar-link">Commandes de machine virtuelle </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#bytecode-structure" class="sidebar-link">Structure du ByteCode </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#command-identifiers" class="sidebar-link">Identifiants de commande </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#stack-operation-commands" class="sidebar-link">Commandes d'opérations de pile </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#runtime-structure" class="sidebar-link">Structure de Runtime </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#runcode-function" class="sidebar-link">Fonction RunCode </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#other-functions-for-operations-with-vm" class="sidebar-link">Autres fonctions pour les opérations avec la VM </a></li></ul></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#compiler" class="sidebar-link">Compilateur </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#lexical-analyzer" class="sidebar-link">Analyseur lexical </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#lextable-lextable-go" class="sidebar-link">lextable/lextable.go </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#lex-go" class="sidebar-link">lex-go </a></li></ul></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#needle-language" class="sidebar-link">Langage Needle </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#lexemes" class="sidebar-link">Lexemes </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#types" class="sidebar-link">Types </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#expressions" class="sidebar-link">Expressions </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#scope" class="sidebar-link">Portée </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#contract-execution" class="sidebar-link">Exécution de contrat intelligent </a></li><li class="sidebar-sub-header"><a href="/fr/topics/vm.html#backus-naur-form-bnf" class="sidebar-link">Forme de Backus-Naur (BNF) </a></li></ul></li></ul></li><li><a href="/fr/topics/daemons.html" class="sidebar-link">Démon </a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="compiler-and-virtual-machine"><a href="#compiler-and-virtual-machine" class="header-anchor">#</a> Compilateur et Machine Virtuelle </h1> <ul><li><a href="#source-code-storage-and-compilation">Stockage et compilation du code source</a></li> <li><a href="#virtual-machine-structures">Structures de la machine virtuelle</a> <ul><li><a href="#vm-structure">Structure VM</a></li> <li><a href="#block-structure">Structure de bloc</a></li> <li><a href="#objinfo-structure">Structure ObjInfo</a> <ul><li><a href="#contractinfo-structure">Structure ContractInfo</a></li> <li><a href="#fieldinfo-structure">Structure FieldInfo</a></li> <li><a href="#funcinfo-structure">Structure FuncInfo</a></li> <li><a href="#funcname-structure">Structure FuncName</a></li> <li><a href="#extfuncinfo-structure">Structure ExtFuncInfo</a></li> <li><a href="#varinfo-structure">Structure VarInfo</a></li> <li><a href="#objextend-value">Valeur ObjExtend</a></li></ul></li></ul></li> <li><a href="#virtual-machine-commands">Commandes de la machine virtuelle</a> <ul><li><a href="#bytecode-structure">Structure ByteCode</a></li> <li><a href="#command-identifiers">Identifiants de commande</a></li> <li><a href="#stack-operation-commands">Commandes d'opérations de la pile</a></li> <li><a href="#runtime-structure">Structure d'exécution</a> <ul><li><a href="#blockstack-structure">Structure blockStack</a></li></ul></li> <li><a href="#runcode-function">Fonction RunCode</a></li> <li><a href="#other-functions-for-operations-with-vm">Autres fonctions pour les opérations avec la VM</a></li></ul></li> <li><a href="#compiler">Compilateur</a></li> <li><a href="#lexical-analyzer">Analyseur lexical</a> <ul><li><a href="#lextable-lextable-go">lextable/lextable.go</a></li> <li><a href="#lex-go">lex.go</a></li></ul></li> <li><a href="#needle-language">Langage Needle</a> <ul><li><a href="#lexemes">Lexèmes</a></li> <li><a href="#types">Types</a></li> <li><a href="#expressions">Expressions</a></li> <li><a href="#scope">Portée</a></li> <li><a href="#contract-execution">Exécution de contrat</a></li> <li><a href="#backus-naur-form-bnf">Forme de Backus-Naur (BNF)</a></li></ul></li></ul> <p>Cette section concerne la compilation du programme et les opérations du langage Needle dans la machine virtuelle (VM).</p> <h2 id="source-code-storage-and-compilation"><a href="#source-code-storage-and-compilation" class="header-anchor">#</a> Stockage et compilation du code source </h2> <p>Les contrats intelligents et les fonctions sont écrits en Golang et stockés dans les tables de contrat des écosystèmes.</p> <p>Lorsqu'un contrat est exécuté, son code source est lu depuis la base de données et compilé en bytecode.</p> <p>Lorsqu'un contrat est modifié, son code source est mis à jour et enregistré dans la base de données. Ensuite, le code source est compilé, mettant à jour le bytecode dans la machine virtuelle correspondante.</p> <p>Comme les bytecodes ne sont pas physiquement enregistrés, ils seront compilés à nouveau lorsque le programme sera exécuté à nouveau.</p> <p>L'ensemble du code source décrit dans la table de contrat de chaque écosystème est compilé dans une machine virtuelle dans un ordre strict, et l'état de la machine virtuelle est le même sur tous les nœuds.</p> <p>Lorsque le contrat est appelé, la machine virtuelle ne change pas son état de quelque manière que ce soit. L'exécution de tout contrat ou l'appel de toute fonction se produit sur une pile d'exécution distincte créée lors de chaque appel externe.</p> <p>Chaque écosystème peut avoir un écosystème virtuel, qui peut être utilisé à l'intérieur d'un nœud en conjonction avec des tables en dehors de la blockchain, sans affecter directement la blockchain ou d'autres écosystèmes virtuels. Dans ce cas, le nœud hébergeant un tel écosystème virtuel compilera son contrat et créera sa propre machine virtuelle.</p> <h2 id="virtual-machine-structures"><a href="#virtual-machine-structures" class="header-anchor">#</a> Structures de machines virtuelles </h2> <h3 id="vm-structure"><a href="#vm-structure" class="header-anchor">#</a> Structure VM </h3> <p>Une machine virtuelle est organisée en mémoire sous la forme d'une structure comme ci-dessous.</p> <div class="language- extra-class"><pre class="language-text"><code>type VM struct {
   Block
   ExtCost func(string) int64
   FuncCallsDB map[string]struct{}
   Extern bool
   ShiftContract int64
   logger *log.Entry
}
</code></pre></div><p>Une structure de VM comprend les éléments suivants :</p> <ul><li>Block - contient une <a href="#block-structure">structure de bloc</a>;</li> <li>ExtCost - une fonction qui retourne le coût d'exécution d'une fonction externe en Golang;</li> <li>FuncCallsDB - une collection de noms de fonctions en Golang. Cette fonction retourne le coût d'exécution en tant que premier paramètre. Ces fonctions utilisent EXPLAIN pour calculer le coût du traitement de la base de données;</li> <li>Extern - un indicateur booléen indiquant si un contrat est un contrat externe. Il est défini sur true lorsqu'une VM est créée. Les contrats appelés ne sont pas affichés lors de la compilation du code. En d'autres termes, cela permet d'appeler le code de contrat déterminé ultérieurement;</li> <li>ShiftContract - ID du premier contrat dans la VM;</li> <li>logger - sortie du journal d'erreurs de la VM.</li></ul> <h3 id="block-structure"><a href="#block-structure" class="header-anchor">#</a> Structure de bloc </h3> <p>A virtual machine is a tree composed of <strong>Block type</strong> objects.</p> <p>A block is an independent unit that contains some bytecodes. In simple terms, everything you put in the braces (<code>{}</code>) in the language is a block.</p> <p>For example, the following code would create a block with functions. This block also contains another block with an if statement, which contains a block with a while statement.</p> <div class="language- extra-class"><pre class="language-text"><code>func my() {
   if true {
      while false {
      ...
      }
   }
}
</code></pre></div><p>The block is organized in the memory as a structure like below.</p> <div class="language- extra-class"><pre class="language-text"><code>type Block struct {
   Objects map[string]*ObjInfo
   Type int
   Owner *OwnerInfo
   Info interface{}
   Parent *Block
   Vars []reflect.Type
   Code ByteCodes
   Children Blocks
}
</code></pre></div><p>Une structure de bloc se compose des éléments suivants :</p> <ul><li><strong>Objects</strong> - une carte d'objets internes de type pointeur <a href="#objinfo-structure">ObjInfo</a>. Par exemple, s'il y a une variable dans le bloc, vous pouvez obtenir des informations à son sujet par son nom ;</li> <li><strong>Type</strong> - le type du bloc. Pour un bloc de fonction, son type est <strong>ObjFunc</strong> ; pour un bloc de contrat, son type est <strong>ObjContract</strong> ;</li> <li><strong>Owner</strong> - une structure de type pointeur <strong>OwnerInfo</strong>. Cette structure contient des informations sur le propriétaire du contrat compilé, qui est spécifié lors de la compilation du contrat ou obtenu à partir de la table <strong>contracts</strong> ;</li> <li><strong>Info</strong> - il contient des informations sur l'objet, qui dépend du type de bloc ;</li> <li><strong>Parent</strong> - un pointeur vers le bloc parent ;</li> <li><strong>Vars</strong> - un tableau contenant les types des variables du bloc actuel ;</li> <li><strong>Code</strong> - le bytecode du bloc lui-même, qui sera exécuté lorsque les droits de contrôle sont transmis au bloc, par exemple, les appels de fonction ou les corps de boucle ;</li> <li><strong>Children</strong> - un tableau contenant des sous-blocs, tels que des fonctions imbriquées, des boucles, des opérateurs conditionnels.</li></ul> <h3 id="objinfo-structure"><a href="#objinfo-structure" class="header-anchor">#</a> Structure ObjInfo </h3> <p>La structure ObjInfo contient des informations sur les objets internes.</p> <div class="language- extra-class"><pre class="language-text"><code>type ObjInfo struct {
   Type int
   Value interface{}
}
</code></pre></div><p>La structure ObjInfo a les éléments suivants:</p> <ul><li><strong>Type</strong> est le type d'objet, qui peut avoir l'une des valeurs suivantes :
<ul><li><strong>ObjContract</strong> - <a href="#structure-du-contrat">contrat</a> ;</li> <li><strong>ObjFunc</strong> - fonction ;</li> <li><strong>ObjExtFunc</strong> - fonction externe golang ;</li> <li><strong>ObjVar</strong> - variable ;</li> <li><strong>ObjExtend</strong> - variable $name.</li></ul></li> <li><strong>Value</strong> - il contient la structure de chaque type.</li></ul> <h4 id="contractinfo-structure"><a href="#contractinfo-structure" class="header-anchor">#</a> Structure ContractInfo </h4> <p>Pointant vers le type <strong>ObjContract</strong>, et le champ <strong>Value</strong> contient une structure <strong>ContractInfo</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type ContractInfo struct {
   ID uint32
   Name string
   Owner *OwnerInfo
   Used map[string]bool
   Tx *[]*FieldInfo
}
</code></pre></div><p>La structure ContractInfo comprend les éléments suivants :</p> <ul><li><strong>ID</strong> - ID du contrat, affiché dans la blockchain lors de l'appel du contrat;</li> <li><strong>Name</strong> - nom du contrat;</li> <li><strong>Owner</strong> - autres informations sur le contrat;</li> <li><strong>Used</strong> - carte des noms de contrats qui ont été appelés;</li> <li><strong>Tx</strong> - un tableau de données décrit dans la section <a href="/fr/topics/script.html#data-section">data section</a> du contrat.</li></ul> <h4 id="fieldinfo-structure"><a href="#fieldinfo-structure" class="header-anchor">#</a> Structure FieldInfo </h4> <p>La structure FieldInfo est utilisée dans la structure <strong>ContractInfo</strong> et décrit les éléments dans <a href="/fr/topics/script.html#data-section">data section</a> d'un contrat.</p> <div class="language- extra-class"><pre class="language-text"><code>type FieldInfo struct {
   Name string
   Type reflect.Type
   Original uint32
   Tags string
}
</code></pre></div><p>La structure FieldInfo a les éléments suivants :</p> <ul><li><strong>Name</strong> - nom du champ;</li> <li><strong>Type</strong> - type de champ;</li> <li><strong>Original</strong> - champ facultatif;</li> <li><strong>Tags</strong> - étiquettes supplémentaires pour ce champ.</li></ul> <h4 id="funcinfo-structure"><a href="#funcinfo-structure" class="header-anchor">#</a> Structure FuncInfo </h4> <p>Pointant vers le type ObjFunc, et le champ Value contient une structure FuncInfo.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncInfo struct {
   Params []reflect.Type
   Results []reflect.Type
   Names *map[string]FuncName
   Variadic bool
   ID uint32
}
</code></pre></div><p>La structure FuncInfo comprend les éléments suivants :</p> <ul><li><strong>Params</strong> - un tableau de types de paramètres;</li> <li><strong>Results</strong> - un tableau de types de retour;</li> <li><strong>Names</strong> - une carte de données pour les fonctions de queue, par exemple, <code>DBFind().Columns()</code>;</li> <li><strong>Variadic</strong> - vrai si la fonction peut avoir un nombre variable de paramètres;</li> <li><strong>ID</strong> - ID de la fonction.</li></ul> <h4 id="funcname-structure"><a href="#funcname-structure" class="header-anchor">#</a> Structure NomFonction </h4> <p>La structure FuncName est utilisée pour FuncInfo et décrit les données d'une fonction de queue.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
</code></pre></div><p>La structure FuncName a les éléments suivants :</p> <ul><li><strong>Params</strong> - un tableau de types de paramètres;</li> <li><strong>Offset</strong> - le tableau des décalages pour ces variables. En fait, les valeurs de tous les paramètres dans une fonction peuvent être initialisées avec le point .;</li> <li><strong>Variadic</strong> - vrai si la fonction de queue peut avoir un nombre variable de paramètres.</li></ul> <h4 id="extfuncinfo-structure"><a href="#extfuncinfo-structure" class="header-anchor">#</a> Structure ExtFuncInfo </h4> <p>Pointant vers le type ObjExtFunc, et le champ Value contient une structure ExtFuncInfo. Il est utilisé pour décrire les fonctions golang.</p> <div class="language- extra-class"><pre class="language-text"><code>type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
</code></pre></div><p>La structure ExtFuncInfo comprend les éléments suivants :</p> <ul><li><strong>Name</strong>, <strong>Params</strong>, <strong>Results</strong> les paramètres ont la même structure que <a href="#structure-funcinfo">FuncInfo</a>;</li> <li><strong>Auto</strong> - un tableau de variables. Si présent, il est transmis à la fonction en tant que paramètre supplémentaire. Par exemple, une variable de type SmartContract sc;</li> <li><strong>Func</strong> - fonctions golang.</li></ul> <h4 id="varinfo-structure"><a href="#varinfo-structure" class="header-anchor">#</a> Structure VarInfo </h4> <p>En pointant vers le type <strong>ObjVar</strong>, et le champ <strong>Value</strong> contient une structure <strong>VarInfo</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
</code></pre></div><p>La structure VarInfo a les éléments suivants :</p> <ul><li><strong>Obj</strong> - informations sur le type et la valeur de la variable;</li> <li><strong>Owner</strong> - Pointeur vers le bloc propriétaire.</li></ul> <h4 id="objextend-value"><a href="#objextend-value" class="header-anchor">#</a> ObjExtend valeur </h4> <p>En pointant vers le type <strong>ObjExtend</strong>, et le champ <strong>Value</strong> contient une chaîne de caractères contenant le nom de la variable ou de la fonction.</p> <h2 id="virtual-machine-commands"><a href="#virtual-machine-commands" class="header-anchor">#</a> Commandes de machine virtuelle </h2> <h3 id="bytecode-structure"><a href="#bytecode-structure" class="header-anchor">#</a> Structure du ByteCode </h3> <p>Un bytecode est une séquence de structures de type <strong>ByteCode</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type ByteCode struct {
   Cmd uint16
   Value interface{}
}
</code></pre></div><p>Cette structure a les champs suivants:</p> <ul><li><strong>Cmd</strong> - l'identifiant des commandes de stockage;</li> <li><strong>Value</strong> - contient l'opérande (valeur).</li></ul> <p>En général, les commandes effectuent une opération sur l'élément supérieur de la pile et écrivent la valeur résultante si nécessaire.</p> <h3 id="command-identifiers"><a href="#command-identifiers" class="header-anchor">#</a> Identifiants de commande </h3> <p>Les identifiants des commandes de la machine virtuelle sont décrits dans le fichier vm/cmds_list.go.</p> <ul><li><strong>cmdPush</strong> - mettre une valeur du champ <code>Value</code> dans la pile. Par exemple, mettre des nombres et des lignes dans la pile;</li> <li><strong>cmdVar</strong> - mettre la valeur d'une variable dans la pile. <code>Value</code> contient un pointeur vers la structure <code>VarInfo</code> et des informations sur la variable;</li> <li><strong>cmdExtend</strong> - mettre la valeur d'une variable externe dans la pile. <code>Value</code> contient une chaîne de caractères avec le nom de la variable (commençant par <code>$</code>);</li> <li><strong>cmdCallExtend</strong> - appeler une fonction externe (commençant par <code>$</code>). Les paramètres de la fonction sont obtenus à partir de la pile et les résultats sont placés dans la pile. <code>Value</code> contient le nom de la fonction (commençant par <code>$</code>);</li> <li><strong>cmdPushStr</strong> - mettre la chaîne de caractères contenue dans <code>Value</code> dans la pile;</li> <li><strong>cmdCall</strong> - appelle la fonction de la machine virtuelle. <code>Value</code> contient une structure <code>ObjInfo</code>. Cette commande s'applique à la fonction golang <code>ObjExtFunc</code> et à la fonction Needle <code>ObjFunc</code>. Si une fonction est appelée, ses paramètres sont obtenus à partir de la pile et les valeurs de résultat sont placées dans la pile;</li> <li><strong>cmdCallVari</strong> - similaire à la commande <strong>cmdCall</strong>, elle appelle la fonction de la machine virtuelle. Cette commande est utilisée pour appeler une fonction avec un nombre variable de paramètres;</li> <li><strong>cmdReturn</strong> - utilisée pour sortir de la fonction. Les valeurs de retour seront placées dans la pile et le champ <code>Value</code> n'est pas utilisé;</li> <li><strong>cmdIf</strong> - transfère le contrôle vers le bytecode dans la structure <code>block</code>, qui est transmis dans le champ <code>Value</code>. Le contrôle sera transféré dans la pile uniquement lorsque l'élément supérieur de la pile est appelé par la fonction <code>valueToBool</code> et retourne <code>true</code>. Sinon, le contrôle sera transféré à la commande suivante;</li> <li><strong>cmdElse</strong> - cette commande fonctionne de la même manière que <strong>cmdIf</strong>, mais seulement lorsque l'élément supérieur de la pile est appelé par la fonction <code>valueToBool</code> et retourne <code>false</code>, le contrôle sera transféré au bloc spécifié;</li> <li><strong>cmdAssignVar</strong> - obtenir une liste de variables de type <code>VarInfo</code> à partir de <code>Value</code>. Ces variables utilisent la commande <strong>cmdAssign</strong> pour obtenir la valeur;</li> <li><strong>cmdAssign</strong> - assigner la valeur de la pile à la variable obtenue par la commande <strong>cmdAssignVar</strong>;</li> <li><strong>cmdLabel</strong> - définit une étiquette lorsque le contrôle est renvoyé pendant la boucle while;</li> <li><strong>cmdContinue</strong> - cette commande transfère le contrôle vers l'étiquette <strong>cmdLabel</strong>. Lors de l'exécution d'une nouvelle itération de la boucle, <code>Value</code> n'est pas utilisé;</li> <li><strong>cmdWhile</strong> - utilise <code>valueToBool</code> pour vérifier l'élément supérieur de la pile. Si cette valeur est <code>true</code>, la structure <code>block</code> sera appelée depuis le champ <code>Value</code>;</li> <li><strong>cmdBreak</strong> - quitte la boucle;</li> <li><strong>cmdIndex</strong> - mettre la valeur de la map ou du tableau dans la pile par index, sans utiliser <code>Value</code>. Par exemple, <code>(map | tableau) (index valeur) =&gt; (map | tableau [index valeur])</code>;</li> <li><strong>cmdSetIndex</strong> - assigne la valeur de l'élément supérieur de la pile aux éléments de la map ou du tableau, sans utiliser <code>Value</code>. Par exemple, <code>(map | tableau) (index valeur) (valeur) =&gt; (map | tableau)</code>;</li> <li><strong>cmdFuncName</strong> - ajoute les paramètres qui sont passés en utilisant des descriptions séquentielles divisées par un point <code>. Par exemple,</code>func name =&gt; Func (...) .Name (...)`;</li> <li><strong>cmdUnwrapArr</strong> - définit un indicateur booléen si l'élément supérieur de la pile est un tableau;</li> <li><strong>cmdMapInit</strong> - initialise la valeur de la map;</li> <li><strong>cmdArrayInit</strong> - initialise la valeur du tableau;</li> <li><strong>cmdError</strong> - cette commande est créée lorsque qu'un contrat ou une fonction se termine avec une erreur, un avertissement ou une information spécifiée.</li></ul> <h3 id="stack-operation-commands"><a href="#stack-operation-commands" class="header-anchor">#</a> Commandes d'opérations de pile </h3> <blockquote><p>Remarque</p></blockquote> <blockquote><p>Dans la version actuelle, la conversion automatique de type n'est pas entièrement applicable pour ces commandes. Par exemple,</p></blockquote> <blockquote><p><code>string + float | int | decimal =&gt; float | int | decimal, float + int | str =&gt; float, mais int + string =&gt; erreur d'exécution</code>.</p></blockquote> <p>Les commandes suivantes sont destinées au traitement direct de la pile. Le champ Valeur n'est pas utilisé dans ces commandes.</p> <ul><li><strong>cmdNot</strong> - logical negation. <code>(val) =&gt; (!ValueToBool(val))</code>;</li> <li><strong>cmdSign</strong> - change of sign. <code>(val) =&gt; (-val)</code>;</li> <li><strong>cmdAdd</strong> - addition. <code>(val1)(val2) =&gt; (val1 + val2)</code>;</li> <li><strong>cmdSub</strong> - subtraction. <code>(val1)(val2) =&gt; (val1 - val2)</code>;</li> <li><strong>cmdMul</strong> - multiplication. <code>(val1)(val2) =&gt; (val1 * val2)</code>;</li> <li><strong>cmdDiv</strong> - division. <code>(val1)(val2) =&gt; (val1 / val2)</code>;</li> <li><strong>cmdAnd</strong> - logical AND. <code>(val1)(val2) =&gt; (valueToBool(val1) &amp;&amp; valueToBool(val2))</code>;</li> <li><strong>cmdOr</strong> - logical OR. <code>(val1)(val2) =&gt; (valueToBool(val1) || valueToBool(val2))</code>;</li> <li><strong>cmdEqual</strong> - equality comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 == val2)</code>;</li> <li><strong>cmdNotEq</strong> - inequality comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 != val2)</code>;</li> <li><strong>cmdLess</strong> - less-than comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 &lt; val2)</code>;</li> <li><strong>cmdNotLess</strong> - greater-than-or-equal comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 &gt;= val2)</code>;</li> <li><strong>cmdGreat</strong> - greater-than comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 &gt; val2)</code>;</li> <li><strong>cmdNotGreat</strong> - less-than-or-equal comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 &lt;= val2)</code>;</li></ul> <h3 id="runtime-structure"><a href="#runtime-structure" class="header-anchor">#</a> Structure de Runtime </h3> <p>L'exécution des octets de code n'affectera pas la machine virtuelle. Par exemple, cela permet à différentes fonctions et contrats de s'exécuter simultanément dans une seule machine virtuelle. La structure Runtime est utilisée pour exécuter des fonctions et des contrats, ainsi que des expressions et des octets de code.</p> <div class="language- extra-class"><pre class="language-text"><code>type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}
</code></pre></div><ul><li><strong>stack</strong> - la pile d'exécution du bytecode;</li> <li><strong>blocks</strong> - la pile des appels de blocs;</li> <li><strong>vars</strong> - la pile des variables. Ses variables seront ajoutées à la pile des variables lors de l'appel du bytecode dans le bloc. Après la sortie du bloc, la taille de la pile des variables reviendra à sa valeur précédente;</li> <li><strong>extend</strong> - un pointeur vers une carte avec les valeurs des variables externes (<code>$name</code>);</li> <li><strong>vm</strong> - un pointeur vers la machine virtuelle;</li> <li><strong>cost</strong> - l'unité de carburant du coût d'exécution résultant;</li> <li><strong>err</strong> - une erreur s'est produite lors de l'exécution.</li></ul> <h4 id="blockstack-structure"><a href="#blockstack-structure" class="header-anchor">#</a> structure de blockStack </h4> <p>La structure blockStack est utilisée dans la structure Runtime.</p> <div class="language- extra-class"><pre class="language-text"><code>type blockStack struct {
   Block *Block
   Offset int
}
</code></pre></div><ul><li><strong>Block</strong> - un pointeur vers le bloc en cours d'exécution;</li> <li><strong>Offset</strong> - le décalage de la dernière commande exécutée dans le bytecode du bloc spécifié.</li></ul> <h3 id="runcode-function"><a href="#runcode-function" class="header-anchor">#</a> Fonction RunCode </h3> <p>Les octets de code sont exécutés dans la fonction <strong>RunCode</strong>. Elle contient une boucle qui effectue l'opération correspondante pour chaque commande d'octet de code. Avant de traiter un octet de code, les données requises doivent être initialisées.</p> <p>De nouveaux blocs sont ajoutés à d'autres blocs.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = append(rt.blocks, &amp;blockStack{block, len(rt.vars)})
</code></pre></div><p>Ensuite, obtenez les informations des paramètres pertinents de la fonction &quot;tail&quot;. Ces paramètres sont contenus dans le dernier élément de la pile.</p> <div class="language- extra-class"><pre class="language-text"><code>var namemap map[string][]interface{}
if block.Type == ObjFunc &amp;&amp; block.Info.(*FuncInfo).Names != nil {
   if rt.stack[len(rt.stack)-1] != nil {
      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
   }
   rt.stack = rt.stack[:len(rt.stack)-1]
}
</code></pre></div><p>Ensuite, toutes les variables définies dans le bloc actuel doivent être initialisées avec leurs valeurs initiales.</p> <div class="language- extra-class"><pre class="language-text"><code>start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
   rt.cost--
   var value interface{}
</code></pre></div><p>Puisque les variables dans la fonction sont également des variables, nous devons les récupérer à partir du dernier élément de la pile dans l'ordre décrit par la fonction elle-même.</p> <div class="language- extra-class"><pre class="language-text"><code>   if block.Type == ObjFunc &amp;&amp; vkey &lt;len(block.Info.(*FuncInfo).Params) {
      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
   } else {
</code></pre></div><p>Initialisez les variables locales avec leurs valeurs initiales.</p> <div class="language- extra-class"><pre class="language-text"><code>      value = reflect.New(vpar).Elem().Interface()

      if vpar == reflect.TypeOf(map[string]interface{}{}) {

         value = make(map[string]interface{})
      } else if vpar == reflect.TypeOf([]interface{}{}) {
         value = make([]interface{}, 0, len(rt.vars)+1)
      }
   }
   rt.vars = append(rt.vars, value)
}
</code></pre></div><p>Ensuite, mettez à jour les valeurs des paramètres variables passés dans la fonction tail.</p> <div class="language- extra-class"><pre class="language-text"><code>if namemap != nil {
   for key, item := range namemap {
      params := (*block.Info.(*FuncInfo).Names)[key]
      for i, value := range item {
         if params.Variadic &amp;&amp; i &gt;= len(params.Params)-1 {
</code></pre></div><p>Si les paramètres de variable passés appartiennent à un nombre variable de paramètres, alors ces paramètres seront combinés dans un tableau de variables.</p> <div class="language- extra-class"><pre class="language-text"><code>            off := varoff + params.Offset[len(params.Params)-1]
            rt.vars[off] = append(rt.vars[off].([]interface{}), value)
         } else {
            rt.vars[varoff+params.Offset[i]] = value
         }
      }
   }
}
</code></pre></div><p>Après cela, tout ce que nous avons à faire est de supprimer les valeurs passées depuis le sommet de la pile en tant que paramètres de fonction, déplaçant ainsi la pile. Nous avons copié leurs valeurs dans un tableau de variables.</p> <div class="language- extra-class"><pre class="language-text"><code>if block.Type == ObjFunc {
   start -= len(block.Info.(*FuncInfo).Params)
}
</code></pre></div><p>Lorsqu'une boucle de commande bytecode est terminée, nous devons vider correctement la pile.</p> <div class="language- extra-class"><pre class="language-text"><code>last := rt.blocks[len(rt.blocks)-1]
</code></pre></div><p>Supprimer le bloc actuel de la pile de blocs.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
</code></pre></div><p>Si la sortie de la fonction s'est effectuée avec succès, nous ajouterons la valeur de retour à la fin de la pile précédente.</p> <div class="language- extra-class"><pre class="language-text"><code>   if last.Block.Type == ObjFunc {
      for count := len(last.Block.Info.(*FuncInfo).Results); count &gt; 0; count-- {
         rt.stack[start] = rt.stack[len(rt.stack)-count]
         start++
      }
      status = statusNormal
   } else {
</code></pre></div><p>Comme vous pouvez le voir, si nous n'exécutons pas la fonction, alors nous ne restaurerons pas l'état de la pile et sortirons de la fonction telle quelle. La raison en est que les boucles et les structures conditionnelles qui ont été exécutées dans la fonction sont également des blocs de code bytecode.</p> <div class="language- extra-class"><pre class="language-text"><code>   return

   }
}

rt.stack = rt.stack[:start]
</code></pre></div><h3 id="other-functions-for-operations-with-vm"><a href="#other-functions-for-operations-with-vm" class="header-anchor">#</a> Autres fonctions pour les opérations avec la VM </h3> <p>Vous pouvez créer une machine virtuelle avec la fonction <strong>NewVM</strong>. Chaque machine virtuelle sera ajoutée avec quatre fonctions, telles que <strong>ExecContract</strong>, <strong>MemoryUsage</strong>, <strong>CallContract</strong> et <strong>Settings</strong>, grâce à la fonction <strong>Extend</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>for key, item := range ext.Objects {
   fobj := reflect.ValueOf(item).Type()
</code></pre></div><p>Nous parcourons tous les objets passés et ne regardons que les fonctions.</p> <div class="language- extra-class"><pre class="language-text"><code>   switch fobj.Kind() {
   case reflect.Func:
</code></pre></div><p>Nous remplissons la structure <strong>ExtFuncInfo</strong> en fonction des informations reçues sur la fonction, et ajoutons sa structure à la carte de niveau supérieur <strong>Objects</strong> par nom.</p> <div class="language- extra-class"><pre class="language-text"><code>   data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),
   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}
   for i := 0; i &lt;fobj.NumIn(); i++ {
</code></pre></div><p>La structure <strong>ExtFuncInfo</strong> a un tableau de paramètres <strong>Auto</strong>. Habituellement, le premier paramètre est <code>sc *SmartContract</code> ou <code>rt *Runtime</code>, nous ne pouvons pas les passer depuis le langage Needle, car ils sont nécessaires pour exécuter certaines fonctions golang. Par conséquent, nous spécifions que ces variables seront utilisées automatiquement lorsque ces fonctions sont appelées. Dans ce cas, le premier paramètre des quatre fonctions ci-dessus est <code>rt *Runtime</code>.</p> <div class="language- extra-class"><pre class="language-text"><code>   if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
      data.Auto[i] = isauto
   }
</code></pre></div><p>Informations sur l'attribution des paramètres.</p> <div class="language- extra-class"><pre class="language-text"><code>      data.Params[i] = fobj.In(i)
   }
</code></pre></div><p>Et les types de valeurs de retour.</p> <div class="language- extra-class"><pre class="language-text"><code>for i := 0; i &lt;fobj.NumOut(); i++ {
   data.Results[i] = fobj.Out(i)
}
</code></pre></div><p>Ajoute une fonction à la racine <strong>Objects</strong> afin que le compilateur puisse les trouver ultérieurement lors de l'utilisation du contrat.</p> <div class="language- extra-class"><pre class="language-text"><code>      vm.Objects[key] = &amp;ObjInfo{ObjExtFunc, data}
   }

}
</code></pre></div><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> Compilateur </h2> <p>Les fonctions dans le fichier compile.go sont responsables de la compilation du tableau de jetons obtenus à partir de l'analyse lexicale. La compilation peut être divisée en deux niveaux de manière conditionnelle. Au niveau supérieur, nous traitons des fonctions, des contrats, des blocs de code, des déclarations conditionnelles et de boucle, des définitions de variables, etc. Au niveau inférieur, nous compilons les expressions dans les blocs de code ou les conditions dans les boucles et les déclarations conditionnelles.</p> <p>Tout d'abord, nous commencerons par le niveau inférieur simple. Dans la fonction <strong>compileEval</strong>, les expressions peuvent être converties en bytecode. Étant donné que nous utilisons une machine virtuelle avec une pile, il est nécessaire de convertir les expressions d'enregistrement infixes ordinaires en notation postfixe ou en notation polonaise inverse. Par exemple, nous convertissons <code>1+2</code> en <code>12+</code> et plaçons <code>1</code> et <code>2</code> dans la pile. Ensuite, nous appliquons l'opération d'addition aux deux derniers éléments de la pile et écrivons le résultat dans la pile. Vous pouvez trouver cet algorithme de <a href="https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/" target="_blank" rel="noopener noreferrer">conversion<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> sur Internet.</p> <p>La variable globale <code>opers = map [uint32] operPrior</code> contient la priorité des opérations nécessaires pour la conversion en notation polonaise inverse.</p> <p>Les variables suivantes sont définies au début de la fonction <strong>compileEval</strong>:</p> <ul><li><strong>buffer</strong> - tampon temporaire pour les commandes de bytecode ;</li> <li><strong>bytecode</strong> - tampon final des commandes de bytecode ;</li> <li><strong>parcount</strong> - tampon temporaire utilisé pour calculer les paramètres lors de l'appel d'une fonction ;</li> <li><strong>setIndex</strong> - les variables dans le processus de travail seront définies sur true lorsque nous attribuons des éléments de carte ou de tableau. Par exemple, <code>a[&quot;my&quot;] = 10</code>. Dans ce cas, nous devons utiliser la commande <strong>cmdSetIndex</strong> spécifiée.</li></ul> <p>Nous obtenons un jeton dans une boucle et le traitons en conséquence. Par exemple, l'appariement des expressions s'arrêtera si des parenthèses sont trouvées. Lors du déplacement de la chaîne, nous vérifions si l'instruction précédente est une opération et si elle se trouve entre parenthèses, sinon elle sortira de l'expression analysée.</p> <div class="language- extra-class"><pre class="language-text"><code>case isRCurly, isLCurly:
   i--
   if prevLex == isComma || prevLex == lexOper {
      return errEndExp
   }
   break main
case lexNewLine:
   if i &gt; 0 &amp;&amp; ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {
      continue main
   }
   for k := len(buffer) - 1; k &gt;= 0; k-- {
   if buffer[k].Cmd == cmdSys {
      continue main
   }
}
break main

</code></pre></div><p>En général, l'algorithme lui-même correspond à un algorithme de conversion en notation polonaise inverse. Avec la prise en compte de l'appel des contrats, fonctions et index nécessaires, ainsi que d'autres éléments non rencontrés lors de l'analyse syntaxique et des options pour l'analyse des jetons de type lexIdent, alors les variables, fonctions ou contrats avec ce nom seront vérifiés. Si rien n'est trouvé et que ce n'est pas un appel de fonction ou de contrat, alors une erreur sera indiquée.</p> <div class="language- extra-class"><pre class="language-text"><code>objInfo, tobj := vm.findObj(lexem.Value.(string), block)
if objInfo == nil &amp;&amp; (!vm.Extern || i&gt; *ind || i &gt;= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {
   return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))
}
</code></pre></div><p>Nous pourrions rencontrer une telle situation, et l'appel de contrat sera décrit ultérieurement. Dans cet exemple, si aucune fonction ou variable avec le même nom n'est trouvée, alors nous pensons qu'il est nécessaire d'appeler un contrat. Dans ce langage compilé, il n'y a pas de différence entre les contrats et les appels de fonction. Mais nous devons appeler le contrat à travers la fonction <strong>ExecContract</strong> utilisée dans le bytecode.</p> <div class="language- extra-class"><pre class="language-text"><code>if objInfo.Type == ObjContract {
   if objInfo.Value != nil {
      objContract = objInfo.Value.(*Block)
   }
   objInfo, tobj = vm.findObj(`ExecContract`, block)
   isContract = true
}
</code></pre></div><p>Nous enregistrons le nombre de variables jusqu'à présent dans <code>count</code>, qui sera également écrit dans la pile avec le nombre de paramètres de la fonction. À chaque détection ultérieure de paramètres, nous devons simplement augmenter ce nombre d'une unité sur le dernier élément de la pile.</p> <div class="language- extra-class"><pre class="language-text"><code>count := 0
if (*lexems)[i+2].Type != isRPar {
   count++
}
</code></pre></div><p>Nous avons une liste appelée &quot;Used&quot; de paramètres pour les contrats, puis nous devons marquer le cas où le contrat est appelé. Si le contrat est appelé sans paramètres, nous devons ajouter deux paramètres vides pour appeler <strong>ExecContract</strong> et obtenir au moins deux paramètres.</p> <div class="language- extra-class"><pre class="language-text"><code>if isContract {
   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))
   for j := len(*block) - 1; j &gt;= 0; j-- {
   topblock := (*block)[j]
      if topblock.Type == ObjContract {
         if topblock.Info.(*ContractInfo).Used == nil {
            topblock.Info.(*ContractInfo).Used = make(map[string]bool)
         }
         topblock.Info.(*ContractInfo).Used[name] = true
      }
   }
   bytecode = append(bytecode, &amp;ByteCode{cmdPush, name})
   if count == 0 {
      count = 2
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
   }
   count++
}
</code></pre></div><p>Si nous voyons qu'il y a une parenthèse carrée à côté, alors nous ajoutons la commande <strong>cmdIndex</strong> pour obtenir la valeur par l'index.</p> <div class="language- extra-class"><pre class="language-text"><code>if (*lexems)[i+1].Type == isLBrack {
   if objInfo == nil || objInfo.Type != ObjVar {
      return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))
   }
   buffer = append(buffer, &amp;ByteCode{cmdIndex, 0})
}
</code></pre></div><p>La fonction <strong>CompileBlock</strong> peut générer des arbres d'objets et des octets de code indépendants de l'expression. Le processus de compilation est basé sur une machine à états finis, tout comme un analyseur lexical, mais avec les différences suivantes. Premièrement, nous n'utilisons pas de symboles mais des jetons ; deuxièmement, nous décrirons immédiatement les variables <em>states</em> dans tous les états et transitions. Il représente un tableau d'objets indexés par type de jeton. Chaque jeton a une structure de <em>compileState</em>, et un nouvel état est spécifié dans <em>NewState</em>. Si la structure que nous avons résolue est claire, nous pouvons spécifier la fonction du gestionnaire dans le champ <em>Func</em>.</p> <p>Prenons l'état principal comme exemple.</p> <p>Si nous rencontrons un saut de ligne ou un commentaire, nous resterons dans le même état. Si nous rencontrons le mot-clé <strong>contract</strong>, alors nous changeons l'état en <em>stateContract</em> et commençons à analyser la structure. Si nous rencontrons le mot-clé <strong>func</strong>, alors nous changeons l'état en <em>stateFunc</em>. Si d'autres jetons sont reçus, la fonction générant une erreur sera appelée.</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateRoot
   lexNewLine: {stateRoot, 0},
   lexKeyword | (keyContract &lt;&lt; 8): {stateContract | statePush, 0},
   lexKeyword | (keyFunc &lt;&lt; 8): {stateFunc | statePush, 0},
   lexComment: {stateRoot, 0},
   0: {errUnknownCmd, cfError},
},
</code></pre></div><p>Supposons que nous rencontrions le mot-clé <strong>func</strong> et que nous ayons changé l'état en <em>stateFunc</em>. Étant donné que le nom de la fonction doit suivre le mot-clé <strong>func</strong>, nous conserverons le même état lors du changement du nom de la fonction. Pour tous les autres jetons, nous générerons des erreurs correspondantes. Si nous obtenons le nom de la fonction dans l'identificateur du jeton, alors nous passons à l'état <em>stateFParams</em>, où nous pouvons obtenir les paramètres de la fonction.</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateFunc
   lexNewLine: {stateFunc, 0},
   lexIdent: {stateFParams, cfNameBlock},
   0: {errMustName, cfError},
},
</code></pre></div><p>En même temps que les opérations ci-dessus, nous appellerons la fonction <strong>fNameBlock</strong>. Il convient de noter que la structure Block est créée avec la marque statePush, où nous l'obtenons à partir du tampon et la remplissons avec les données dont nous avons besoin. La fonction <strong>fNameBlock</strong> convient aux contrats et aux fonctions (y compris celles qui sont imbriquées). Elle remplit le champ <em>Info</em> avec la structure correspondante et s'écrit elle-même dans les <em>Objets</em> du bloc parent. De cette manière, nous pouvons appeler la fonction ou le contrat avec le nom spécifié. De même, nous créons des fonctions correspondantes pour tous les états et variables. Ces fonctions sont généralement très petites et effectuent certaines tâches lors de la construction de l'arbre de la machine virtuelle.</p> <div class="language- extra-class"><pre class="language-text"><code>func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {
   var itype int
   prev := (*buf)[len(*buf)-2]
   fblock := (*buf)[len(*buf)-1]
   name := lexem.Value.(string)
   switch state {
      case stateBlock:
         itype = ObjContract
         name = StateName((*buf)[0].Info.(uint32), name)
         fblock.Info = &amp;ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,
         Owner: (*buf)[0].Owner}
      default:
         itype = ObjFunc
         fblock.Info = &amp;FuncInfo{}
   }
   fblock.Type = itype
   prev.Objects[name] = &amp;ObjInfo{Type: itype, Value: fblock}
   return nil
}
</code></pre></div><p>Pour la fonction <strong>CompileBlock</strong>, elle parcourt simplement tous les jetons et change d'état en fonction des jetons décrits dans les états. Presque tous les jetons supplémentaires correspondent à des codes de programme supplémentaires.</p> <ul><li><strong>statePush</strong> - ajoute l'objet <strong>Block</strong> à l'arbre d'objets;</li> <li><strong>statePop</strong> - utilisé lorsque le bloc se termine par une accolade fermante;</li> <li><strong>stateStay</strong> - vous devez conserver la marque actuelle lors du passage à un nouvel état;</li> <li><strong>stateToBlock</strong> - transition vers l'état <strong>stateBlock</strong> pour traiter les instructions <em>while</em> et <em>if</em>. Après le traitement des expressions, vous devez traiter les blocs à l'intérieur des accolades;</li> <li><strong>stateToBody</strong> - transition vers l'état <strong>stateBody</strong>;</li> <li><strong>stateFork</strong> - enregistre la position marquée. Lorsque l'expression commence par un identifiant ou un nom avec <code>$</code>, nous pouvons effectuer des appels de fonction ou des affectations;</li> <li><strong>stateToFork</strong> - utilisé pour obtenir le jeton stocké dans <strong>stateFork</strong>, qui sera transmis à la fonction de traitement;</li> <li><strong>stateLabel</strong> - utilisé pour insérer des commandes <strong>cmdLabel</strong>. La structure <em>while</em> nécessite ce drapeau;</li> <li><strong>stateMustEval</strong> - vérifie la disponibilité des expressions conditionnelles au début des structures <em>if</em> et <em>while</em>.</li></ul> <p>En plus de la fonction <strong>CompileBlock</strong>, la fonction <strong>FlushBlock</strong> devrait également être mentionnée. Mais le problème est que l'arbre de blocs est construit indépendamment des machines virtuelles existantes. Plus précisément, nous obtenons des informations sur les fonctions et les contrats qui existent dans une machine virtuelle, mais nous collectons les blocs compilés dans un arbre séparé. Sinon, en cas d'erreur lors de la compilation, nous devons revenir à l'état précédent de la machine virtuelle. Par conséquent, nous accédons à l'arbre de compilation séparément, mais après que la compilation a réussi, la fonction <strong>FlushContract</strong> doit être appelée. Cette fonction ajoute l'arbre de blocs terminé à la machine virtuelle actuelle. La phase de compilation est maintenant terminée.</p> <h2 id="lexical-analyzer"><a href="#lexical-analyzer" class="header-anchor">#</a> Analyseur lexical </h2> <p>L'analyseur lexical traite les chaînes entrantes et forme une séquence de jetons des types suivants :</p> <ul><li><strong>lexSys</strong> - jeton système, par exemple : <code>{}, [], (), ,, .</code> etc ;</li> <li><strong>lexOper</strong> - jeton d'opération, par exemple : <code>+, -, /, \, *</code> ;</li> <li><strong>lexNumber</strong> - nombre ;</li> <li><strong>lexident</strong> - identifiant ;</li> <li><strong>lexNewline</strong> - caractère de saut de ligne ;</li> <li><strong>lexString</strong> - chaîne de caractères ;</li> <li><strong>lexComment</strong> - commentaire ;</li> <li><strong>lexKeyword</strong> - mot-clé ;</li> <li><strong>lexType</strong> - type ;</li> <li><strong>lexExtend</strong> - référence à des variables ou fonctions externes, par exemple : <code>$myname</code>.</li></ul> <p>Dans la version actuelle, une table de conversion (machine à états finis) est initialement construite à l'aide du fichier <a href="#lextable-lextable-go">lextable.go</a> pour analyser les jetons, qui est ensuite écrit dans le fichier lex_table.go. En général, vous pouvez vous débarrasser de la table de conversion générée initialement par le fichier et créer une table de conversion en mémoire (<code>init()</code>) immédiatement au démarrage. L'analyse lexicale elle-même se produit dans la fonction lexParser du fichier <a href="#lex-go">lex.go</a>.</p> <h3 id="lextable-lextable-go"><a href="#lextable-lextable-go" class="header-anchor">#</a> lextable/lextable.go </h3> <p>Ici, nous définissons l'alphabet sur lequel nous opérons et décrivons comment la machine à états finis change d'un état à un autre en fonction du symbole suivant reçu.</p> <p><em>states</em> est un objet JSON contenant une liste d'états.</p> <p>Sauf pour des symboles spécifiques, <code>d</code> représente tous les symboles non spécifiés dans l'état.
<code>n</code> représente 0x0a, <code>s</code> représente un espace, <code>q</code> représente une apostrophe inversée, <code>Q</code> représente des guillemets doubles, <code>r</code> représente un caractère &gt;= 128, <code>a</code> représente AZ et az, et <code>1</code> représente les chiffres de 1 à 9.</p> <p>Le nom de ces états est une clé, et les valeurs possibles sont répertoriées dans l'objet valeur. Ensuite, il y a un nouvel état pour effectuer des transitions pour chaque groupe. Ensuite, il y a le nom du jeton. Si nous devons revenir à l'état initial, le troisième paramètre est le jeton de service, qui indique comment traiter le symbole actuel.</p> <p>Par exemple, nous avons l'état principal et les caractères entrants <code>/</code>, <code>&quot;/&quot;: [&quot;solidus&quot;, &quot;&quot;, &quot;push next&quot;]</code>,</p> <ul><li><strong>push</strong> - donne la commande de se souvenir qu'il est dans une pile séparée ;</li> <li><strong>next</strong>* - passe au caractère suivant et en même temps nous changeons le statut en <strong>solidus</strong>. Ensuite, obtient le caractère suivant et vérifie le statut de <strong>solidus</strong>.</li></ul> <p>Si le prochain caractère est <code>/</code> ou <code>/*</code>, alors nous passons à l'état de commentaire <strong>comment</strong> car ils commencent par <code>//</code> ou <code>/*</code>. Évidemment, chaque commentaire a un état différent par la suite, car ils se terminent par un symbole différent.</p> <p>Si le prochain caractère n'est pas <code>/</code> et <code>*</code>, alors nous enregistrons tout dans la pile en tant que balises de type <strong>lexOper</strong>, nous vidons la pile et revenons à l'état principal.</p> <p>Le module suivant convertit l'arbre d'état en un tableau numérique et l'écrit dans le fichier <em>lex_table.go</em>.</p> <p>Dans la première boucle :</p> <p>Nous formons un alphabet de symboles valides.</p> <div class="language- extra-class"><pre class="language-text"><code>for ind, ch := range alphabet {
   i := byte(ind)
</code></pre></div><p>De plus, dans <strong>state2int</strong>, nous attribuons à chaque état un identifiant de séquence propre.</p> <div class="language- extra-class"><pre class="language-text"><code>   state2int := map[string]uint{`main`: 0}
   if err := json.Unmarshal([]byte(states), &amp;data); err == nil {
   for key := range data {
   if key != `main` {
   state2int[key] = uint(len(state2int))
</code></pre></div><p>Lorsque nous parcourons tous les états, chaque ensemble dans un état et chaque symbole dans un ensemble, nous écrivons un nombre de trois octets [identifiant nouvel état (0 = principal)] + [type de jeton (0-pas de jeton)] + [jeton].
La bidimensionnalité du tableau <em>table</em> est qu'il est divisé en états et 34 symboles d'entrée du tableau <em>alphabet</em>, qui sont disposés dans le même ordre.</p> <p>Nous sommes dans l'état <em>principal</em> sur la ligne zéro du tableau <em>table</em>. Prenez le premier caractère, trouvez son index dans le tableau <em>alphabet</em> et obtenez la valeur de la colonne avec l'index donné. À partir de la valeur obtenue, nous recevons le jeton dans le octet de poids faible. Si l'analyse est terminée, le deuxième octet indique le type de jeton reçu. Dans le troisième octet, nous recevons l'index du prochain nouvel état.
Tout cela est décrit plus en détail dans la fonction <strong>lexParser</strong> dans le fichier <em>lex.go</em>.</p> <p>Si vous souhaitez ajouter de nouveaux caractères, vous devez les ajouter au tableau <em>alphabet</em> et augmenter la quantité de la constante <em>AlphaSize</em>. Si vous souhaitez ajouter une nouvelle combinaison de symboles, elle doit être décrite dans l'état, similaire aux options existantes. Après l'opération ci-dessus, exécutez le fichier <em>lextable.go</em> pour mettre à jour le fichier <em>lex_table.go</em>.</p> <h3 id="lex-go"><a href="#lex-go" class="header-anchor">#</a> lex-go </h3> <p>La fonction <strong>lexParser</strong> génère directement une analyse lexicale et renvoie un tableau de balises reçues en fonction des chaînes entrantes. Analysons la structure des jetons.</p> <div class="language- extra-class"><pre class="language-text"><code>type Lexem struct {
   Type  uint32 // Type of the lexem
   Value interface{} // Value of lexem
   Line  uint32 // Line of the lexem
   Column uint32 // Position inside the line
}
</code></pre></div><ul><li><strong>Type</strong> - type de jeton. Il a l'une des valeurs suivantes : <code>lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend</code> ;</li> <li><strong>Value</strong> - valeur du jeton. Le type de valeur dépend du type de jeton. Analysons cela plus en détail :</li> <li><strong>lexSys</strong> - comprend des crochets, des virgules, etc. Dans ce cas, <code>Type = ch &lt;&lt; 8 | lexSys</code>, veuillez vous référer à la constante <code>isLPar ... isRBrack</code>, et sa valeur est un entier non signé de 32 bits ;
<ul><li><strong>lexOper</strong> - la valeur représente une séquence de caractères équivalente sous forme de uint32. Voir les constantes <code>isNot ... isOr</code> ;</li> <li><strong>lexNumber</strong> - les nombres sont stockés en tant que int64 ou float64. S'il y a un point décimal, c'est un float64 ;</li> <li><strong>lexIdent</strong> - les identifiants sont stockés en tant que chaîne de caractères ;</li> <li><strong>lexNewLine</strong> - caractère de saut de ligne. Utilisé également pour calculer la ligne et la position du jeton ;</li> <li><strong>lexString</strong> - les lignes sont stockées en tant que chaîne de caractères ;</li> <li><strong>lexComment</strong> - les commentaires sont stockés en tant que chaîne de caractères ;</li> <li><strong>lexKeyword</strong> - pour les mots-clés, seuls les index correspondants sont stockés, voir la constante <code>keyContract ... keyTail</code>. Dans ce cas, <code>Type = KeyID &lt;&lt; 8 | lexKeyword</code>. De plus, il convient de noter que les mots-clés <code>true, false, nil</code> seront immédiatement convertis en jetons de type lexNumber, et les types correspondants <code>bool</code> et <code>intreface {}</code> seront utilisés ;</li> <li><strong>lexType</strong> - cette valeur contient la valeur de type <code>reflect.Type</code> correspondante ;</li> <li><strong>lexExtend</strong> - identifiants commençant par un <code>$</code>. Ces variables et fonctions sont transmises de l'extérieur et sont donc attribuées à des types de jetons spéciaux. Cette valeur contient le nom en tant que chaîne de caractères sans le $ au début.</li></ul></li> <li><strong>Line</strong> - la ligne où se trouve le jeton ;</li> <li><strong>Column</strong> - la position dans la ligne du jeton.</li></ul> <p>Analysons en détail la fonction <strong>lexParser</strong>. La fonction <strong>todo</strong> recherche l'index du symbole dans l'alphabet en fonction de l'état actuel et du symbole entrant, et obtient un nouvel état, un identifiant de jeton (le cas échéant) et d'autres jetons à partir de la table de conversion. L'analyse elle-même consiste à appeler la fonction <strong>todo</strong> successivement pour chaque caractère suivant et à passer à un nouvel état. Une fois que la balise est reçue, nous créons le jeton correspondant dans le critère de sortie et continuons le processus d'analyse. Il convient de noter que pendant le processus d'analyse, nous n'accumulons pas les symboles de jeton dans une pile ou un tableau séparé, car nous ne sauvegardons que le décalage du début du jeton. Après avoir obtenu le jeton, nous déplaçons le décalage du prochain jeton vers la position d'analyse actuelle.</p> <p>Il ne reste plus qu'à vérifier les jetons d'état lexical utilisés dans l'analyse :</p> <ul><li><strong>lexfPush</strong> - ce jeton signifie que nous commençons à accumuler des symboles dans un nouveau jeton ;</li> <li><strong>lexfNext</strong> - le caractère doit être ajouté au jeton actuel ;</li> <li><strong>lexfPop</strong> - la réception du jeton est terminée. Généralement, avec ce drapeau, nous avons le type d'identifiant du jeton analysé ;</li> <li><strong>lexfSkip</strong> - ce jeton est utilisé pour exclure des caractères de l'analyse. Par exemple, les barres obliques de contrôle dans la chaîne sont \n \r &quot;. Ils seront automatiquement remplacés lors de l'étape d'analyse lexicale.</li></ul> <h2 id="needle-language"><a href="#needle-language" class="header-anchor">#</a> Langage Needle </h2> <h3 id="lexemes"><a href="#lexemes" class="header-anchor">#</a> Lexemes </h3> <p>Le code source d'un programme doit être encodé en UTF-8.</p> <p>Les types lexicaux suivants sont traités :</p> <ul><li><strong>Keywords</strong> - <code>action, break, conditions, continue, contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while</code>;</li> <li><strong>Number</strong> - seuls les nombres décimaux sont acceptés. Il existe deux types de base : <strong>int</strong> et <strong>float</strong>. Si le nombre comporte un point décimal, il devient un <strong>float</strong>. Le type <strong>int</strong> est équivalent à <strong>int64</strong> en golang, tandis que le type <strong>float</strong> est équivalent à <strong>float64</strong> en golang.</li> <li><strong>String</strong> - la chaîne de caractères peut être encadrée par des guillemets doubles <code>(&quot;une chaîne de caractères&quot;)</code> ou des guillemets inversés <code>(\`une chaîne de caractères\`)</code>. Les deux types de chaînes peuvent contenir des caractères de nouvelle ligne. Les chaînes entre guillemets doubles peuvent contenir des guillemets doubles, des caractères de nouvelle ligne et des retours chariot échappés avec des barres obliques inverses. Par exemple, <code>&quot;Ceci est une \&quot;première chaîne\&quot;.\r\nCeci est une deuxième chaîne.&quot;</code>.</li> <li><strong>Comment</strong> - il existe deux types de commentaires. Les commentaires sur une seule ligne utilisent deux barres obliques (//). Par exemple, // Ceci est un commentaire sur une seule ligne. Les commentaires sur plusieurs lignes utilisent le symbole barre oblique et astérisque et peuvent s'étendre sur plusieurs lignes. Par exemple, <code>/* Ceci est un commentaire sur plusieurs lignes */</code>.</li> <li><strong>Identifier</strong> - les noms de variables et de fonctions sont composés de lettres a-z et A-Z, de symboles UTF-8, de chiffres et de traits de soulignement. Le nom peut commencer par une lettre, un trait de soulignement, <code>@</code> ou <code>$</code>. Le nom commençant par <code>$</code> est le nom de la variable définie dans la <strong>section data</strong>. Le nom commençant par <code>$</code> peut également être utilisé pour définir des variables globales dans la portée des <strong>sections conditions</strong> et <strong>action</strong>. Les contrats de l'écosystème peuvent être appelés à l'aide du symbole <code>@</code>. Par exemple : <code>@1NouvelleTable(...)</code>.</li></ul> <h3 id="types"><a href="#types" class="header-anchor">#</a> Types </h3> <p>Les types correspondants en golang sont spécifiés à côté des types Needle.</p> <ul><li><strong>bool</strong> - bool, <strong>false</strong> by default;</li> <li><strong>bytes</strong> - []byte{}, un tableau vide de bytes par défaut;</li> <li><strong>int</strong> - int64, <strong>0</strong> par défaut;</li> <li><strong>address</strong> - uint64, <strong>0</strong> par défaut;</li> <li><strong>array</strong> - []interface{}, un tableau vide par défaut;</li> <li><strong>map</strong> - map[string]interface{}, un objet vide par défaut;</li> <li><strong>money</strong> - decimal. Decimal, <strong>0</strong> par défaut;</li> <li><strong>float</strong> - float64, <strong>0</strong> par défaut;</li> <li><strong>string</strong> - string, une chaîne vide par défaut;</li> <li><strong>file</strong> - map[string]interface{}, un objet vide par défaut.</li></ul> <p>Ces types de variables sont définis avec le mot-clé <code>var</code>. Par exemple, <code>var var1, var2 int</code>. Lorsqu'ils sont définis de cette manière, une variable sera affectée à une valeur par défaut selon son type.</p> <p>Toutes les valeurs des variables sont de type interface{}, puis elles sont affectées aux types golang requis. Par conséquent, par exemple, les types array et map sont les types golang []interface{} et map[string]interface{}. Les deux types de tableaux peuvent contenir des éléments de n'importe quel type.</p> <h3 id="expressions"><a href="#expressions" class="header-anchor">#</a> Expressions </h3> <p>Une expression peut inclure des opérations arithmétiques, des opérations logiques et des appels de fonctions. Toutes les expressions sont évaluées de gauche à droite en fonction de la priorité des opérateurs. En cas de priorité égale, les opérateurs sont évalués de gauche à droite.</p> <p>Priorité des opérations de haut en bas :</p> <ul><li><strong>Appel de fonction et parenthèses</strong> - lorsqu'une fonction est appelée, les paramètres passés sont calculés de gauche à droite ;</li> <li><strong>Opération unaire</strong> - négation logique <code>!</code> et changement de signe arithmétique <code>-</code> ;</li> <li><strong>Multiplication et Division</strong> - multiplication arithmétique <code>*</code> et division <code>/</code> ;</li> <li><strong>Addition et Soustraction</strong> - addition arithmétique <code>+</code> et soustraction <code>-</code> ;</li> <li><strong>Comparaison logique</strong> - <code>&gt;=&gt;&gt; &gt;=</code> ;</li> <li><strong>Égalité et inégalité logiques</strong> - <code>== !=</code> ;</li> <li><strong>ET logique</strong> - <code>&amp;&amp;</code> ;</li> <li><strong>OU logique</strong> - <code>||</code>.</li></ul> <p>Lors de l'évaluation des opérateurs logiques ET et OU, les deux côtés de l'expression sont évalués dans tous les cas.</p> <p>Needle ne vérifie pas les types lors de la compilation. Lors de l'évaluation des opérandes, une tentative est faite pour convertir le type en un type plus complexe. L'ordre de complexité des types peut être le suivant : <code>string, int, float, money</code>. Seules certaines conversions de types sont implémentées. Le type string prend en charge les opérations d'addition, et le résultat sera une concaténation de chaînes de caractères. Par exemple, <code>string + string = string, money-int = money, int * float = float</code>.</p> <p>Pour les fonctions, une vérification des types est effectuée sur les types <code>string</code> et <code>int</code> lors de l'exécution.</p> <p><strong>array</strong> et <strong>map</strong> types peuvent être adressés par index. Pour le type <strong>array</strong>, la valeur <strong>int</strong> doit être spécifiée comme index. Pour le type <strong>map</strong>, une variable ou une valeur <strong>string</strong> doit être spécifiée. Si vous assignez une valeur à un élément de l'<strong>array</strong> dont l'index est supérieur à l'index maximum actuel, un élément vide sera ajouté à l'array. La valeur initiale de ces éléments est <strong>nil</strong>. Par exemple: .. code:</p> <div class="language- extra-class"><pre class="language-text"><code>var my array
my[5] = 0
var mymap map
mymap[&quot;index&quot;] = my[3]
</code></pre></div><p>In expressions of conditional logical values (such as <code>if, while, &amp;&amp;, ||, !</code>), the type is automatically converted to a logical value. If the type is not the default value, it is true.</p> <div class="language- extra-class"><pre class="language-text"><code>var mymap map
var val string
if mymap &amp;&amp; val {
...
}
</code></pre></div><h3 id="scope"><a href="#scope" class="header-anchor">#</a> Portée </h3> <p>Les accolades spécifient un bloc qui peut contenir des variables à portée locale. Par défaut, la portée d'une variable s'étend à ses propres blocs et à tous les blocs imbriqués. Dans un bloc, vous pouvez définir une nouvelle variable en utilisant le nom d'une variable existante. Cependant, dans ce cas, les variables externes portant le même nom deviennent indisponibles.</p> <div class="language- extra-class"><pre class="language-text"><code>var a int
a = 3
{
   var a int
   a = 4
   Println(a) // 4
}
Println(a) // 3
</code></pre></div><h3 id="contract-execution"><a href="#contract-execution" class="header-anchor">#</a> Exécution de contrat intelligent </h3> <p>Lors de l'appel d'un contrat intelligent, les paramètres définis dans <strong>data</strong> doivent lui être transmis. Avant d'exécuter un contrat, la machine virtuelle reçoit ces paramètres et les assigne aux variables correspondantes ($Param). Ensuite, la fonction prédéfinie <strong>conditions</strong> et la fonction <strong>action</strong> sont appelées.</p> <p>Les erreurs survenant lors de l'exécution d'un contrat peuvent être divisées en deux types : les erreurs de formulaire et les erreurs d'environnement. Les erreurs de formulaire sont générées à l'aide de commandes spéciales : <code>error, warning, info</code> et lorsque la fonction intégrée renvoie <code>err</code> différent de <em>nil</em>.</p> <p>Le langage Needle ne gère pas les exceptions. Toute erreur mettra fin à l'exécution des contrats. Étant donné qu'une pile séparée et une structure pour sauvegarder les valeurs des variables sont créées lors de l'exécution d'un contrat, le mécanisme de collecte des déchets de golang supprimera automatiquement ces données lors de l'exécution d'un contrat.</p> <h3 id="backus-naur-form-bnf"><a href="#backus-naur-form-bnf" class="header-anchor">#</a> Forme de Backus-Naur (BNF) </h3> <p>En informatique, BNF est une technique de notation pour la syntaxe sans contexte et est généralement utilisée pour décrire la syntaxe du langage utilisé en informatique.</p> <ul><li>&lt;decimal digit&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
</code></pre></div><ul><li>&lt;decimal number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; {&lt;decimal digit&gt;}
</code></pre></div><ul><li>&lt;symbol code&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'''&lt;any symbol&gt;'''
</code></pre></div><ul><li>&lt;real number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number'.'[&lt;decimal number&gt;]
</code></pre></div><ul><li>&lt;integer number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number&gt; | &lt;symbol code&gt;
</code></pre></div><ul><li>&lt;number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'&lt;integer number&gt; | &lt;real number&gt;'
</code></pre></div><ul><li>&lt;letter&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF
</code></pre></div><ul><li>&lt;space&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x20'
</code></pre></div><ul><li>&lt;tabulation&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x09'
</code></pre></div><ul><li>&lt;newline&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x0D 0x0A'
</code></pre></div><ul><li>&lt;special symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'!' |'&quot;' |'$' |''' |'(' |')' |'\*' |'+' |',' |'-' |'.' |'/ '|'&lt;' |'=' |'&gt;' |'[' |'\\' |']' |'_' |'|' |'}' | '{' | &lt;tabulation&gt; | &lt;space&gt; | &lt;newline&gt;
</code></pre></div><ul><li>&lt;symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; | &lt;letter&gt; | &lt;special symbol&gt;
</code></pre></div><ul><li>&lt;name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(&lt;letter&gt; |'_') {&lt;letter&gt; |'_' | &lt;decimal digit&gt;}
</code></pre></div><ul><li>&lt;function name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;variable name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;type name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;string symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;tabulation&gt; | &lt;space&gt; |'!' |'#' | ... |'[' |']' | ...
</code></pre></div><ul><li>&lt;string element&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{&lt;string symbol&gt; |'\&quot;' |'\n' |'\r'}
</code></pre></div><ul><li>&lt;string&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'&quot;' {&lt;string element&gt;}'&quot;' |'\`' {&lt;string element&gt;}'\`'
</code></pre></div><ul><li>&lt;assignment operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'='
</code></pre></div><ul><li>&lt;unary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'-'
</code></pre></div><ul><li>&lt;binary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'==' |'!=' |'&gt;' |'&lt;' |'&lt;=' |'&gt;=' |'&amp;&amp;' |'||' |'\*' |'/' |'+ '|'-'
</code></pre></div><ul><li>&lt;operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;assignment operator&gt; | &lt;unary operator&gt; | &lt;binary operator&gt;
</code></pre></div><ul><li>&lt;parameters&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;expression&gt; {','&lt;expression&gt;}
</code></pre></div><ul><li>&lt;contract call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract name&gt;'(' [&lt;parameters&gt;]')'
</code></pre></div><ul><li>&lt;function call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract call&gt; [{'.' &lt;name&gt;'(' [&lt;parameters&gt;]')'}]
</code></pre></div><ul><li>&lt;block contents&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;block command&gt; {&lt;newline&gt;&lt;block command&gt;}
</code></pre></div><ul><li>&lt;block&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'{'&lt;block contents&gt;'}'
</code></pre></div><ul><li>&lt;block command&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(&lt;block&gt; | &lt;expression&gt; | &lt;variables definition&gt; | &lt;if&gt; | &lt;while&gt; | break | continue | return)
</code></pre></div><ul><li>&lt;if&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'if &lt;expression&gt;&lt;block&gt; [else &lt;block&gt;]'
</code></pre></div><ul><li>&lt;while&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'while &lt;expression&gt;&lt;block&gt;'
</code></pre></div><ul><li>&lt;contract&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'contract &lt;name&gt; '{'[&lt;data section&gt;] {&lt;function&gt;} [&lt;conditions&gt;] [&lt;action&gt;]'}''
</code></pre></div><ul><li>&lt;data section&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'data '{' {&lt;data parameter&gt;&lt;newline&gt;} '}''
</code></pre></div><ul><li>&lt;data parameter&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; &lt;type name&gt;'&quot;'{&lt;tag&gt;}'&quot;'
</code></pre></div><ul><li>&lt;tag&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'optional | image | file | hidden | text | polymap | map | address | signature:&lt;name&gt;'
</code></pre></div><ul><li>&lt;conditions&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'conditions &lt;block&gt;'
</code></pre></div><ul><li>&lt;action&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'action &lt;block&gt;'
</code></pre></div><ul><li>&lt;function&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'func &lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'[{&lt;tail&gt;}] [&lt;type name&gt;] &lt;block&gt;'
</code></pre></div><ul><li>&lt;variable description&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; {',' &lt;variable name&gt;} &lt;type name&gt;
</code></pre></div><ul><li>&lt;tail&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'.'&lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'
</code></pre></div><ul><li>&lt;variables definition&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'var &lt;variable description&gt;{','&lt;variable description&gt;}'
</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/IBAX-io/documentation/edit/master/docs/fr/topics/vm.md" target="_blank" rel="noopener noreferrer">Modifier cette page sur GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Dernière mise à jour:</span> <span class="time">06/07/2023 18:59:03</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fr/topics/templates2.html" class="prev">
        Langage de modèle 
      </a></span> <span class="next"><a href="/fr/topics/daemons.html">
        Démon 
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d049f7ab.js" defer></script><script src="/assets/js/2.8d94a0db.js" defer></script><script src="/assets/js/64.f749c6d5.js" defer></script>
  </body>
</html>
