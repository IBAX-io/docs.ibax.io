(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{393:function(t,a,e){"use strict";e.r(a);var v=e(14),s=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"compiler-and-virtual-machine"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compiler-and-virtual-machine"}},[t._v("#")]),t._v(" 컴파일러와 가상 머신 ")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#source-code-storage-and-compilation"}},[t._v("소스 코드 저장 및 컴파일")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#virtual-machine-structures"}},[t._v("가상 머신 구조")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#vm-structure"}},[t._v("VM 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#block-structure"}},[t._v("Block 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#objinfo-structure"}},[t._v("ObjInfo 구조")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#contractinfo-structure"}},[t._v("ContractInfo 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#fieldinfo-structure"}},[t._v("FieldInfo 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#funcinfo-structure"}},[t._v("FuncInfo 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#funcname-structure"}},[t._v("FuncName 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#extfuncinfo-structure"}},[t._v("ExtFuncInfo 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#varinfo-structure"}},[t._v("VarInfo 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#objextend-value"}},[t._v("ObjExtend 값")])])])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#virtual-machine-commands"}},[t._v("가상 머신 명령")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#bytecode-structure"}},[t._v("ByteCode 구조")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#command-identifiers"}},[t._v("명령 식별자")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#stack-operation-commands"}},[t._v("스택 연산 명령")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#runtime-structure"}},[t._v("Runtime 구조")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#blockstack-structure"}},[t._v("blockStack 구조")])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#runcode-function"}},[t._v("RunCode 함수")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#other-functions-for-operations-with-vm"}},[t._v("가상 머신과 관련된 기타 함수들")])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#compiler"}},[t._v("컴파일러")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#lexical-analyzer"}},[t._v("어휘 분석기")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#lextable-lextable-go"}},[t._v("lextable/lextable.go")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#lex-go"}},[t._v("lex.go")])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#needle-language"}},[t._v("Needle 언어")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#lexemes"}},[t._v("렉서")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#types"}},[t._v("타입")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#expressions"}},[t._v("표현식")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#scope"}},[t._v("스코프")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#contract-execution"}},[t._v("계약 실행")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#backus-naur-form-bnf"}},[t._v("Backus-Naur Form (BNF)")])])])])]),t._v(" "),a("p",[t._v("이 섹션에서는 프로그램 컴파일과 Needle 언어의 가상 머신(VM) 내에서의 동작에 대해 다룹니다.")]),t._v(" "),a("h2",{attrs:{id:"source-code-storage-and-compilation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#source-code-storage-and-compilation"}},[t._v("#")]),t._v(" 소스 코드 저장 및 컴파일 ")]),t._v(" "),a("p",[t._v("계약과 함수는 Golang로 작성되며, 생태계의 계약 테이블에 저장됩니다.")]),t._v(" "),a("p",[t._v("계약이 실행될 때, 해당 계약의 소스 코드는 데이터베이스에서 읽혀서 바이트코드로 컴파일됩니다.")]),t._v(" "),a("p",[t._v("계약이 변경될 때, 소스 코드는 업데이트되어 데이터베이스에 저장됩니다. 그리고 소스 코드가 컴파일되어 해당 가상 머신의 바이트코드가 업데이트됩니다.")]),t._v(" "),a("p",[t._v("바이트코드는 물리적으로 저장되지 않으며, 프로그램이 다시 실행될 때마다 다시 컴파일됩니다.")]),t._v(" "),a("p",[t._v("각 생태계의 계약 테이블에 기술된 전체 소스 코드는 엄격한 순서로 가상 머신으로 컴파일되며, 가상 머신의 상태는 모든 노드에서 동일합니다.")]),t._v(" "),a("p",[t._v("계약이 호출될 때, 가상 머신은 어떠한 방식으로도 상태를 변경하지 않습니다. 어떠한 계약의 실행 또는 함수의 호출은 각 외부 호출 시 생성된 별도의 실행 스택에서 발생합니다.")]),t._v(" "),a("p",[t._v("각 생태계는 가상 생태계라고 불리는 것을 가질 수 있으며, 이는 블록체인 외부의 테이블과 함께 노드 내에서 사용될 수 있습니다. 이러한 경우, 해당 가상 생태계를 호스트하는 노드는 계약을 컴파일하고 자체 가상 머신을 생성합니다.")]),t._v(" "),a("h2",{attrs:{id:"virtual-machine-structures"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-machine-structures"}},[t._v("#")]),t._v(" 가상 머신 구조 ")]),t._v(" "),a("h3",{attrs:{id:"vm-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vm-structure"}},[t._v("#")]),t._v(" VM 구조 ")]),t._v(" "),a("p",[t._v("가상 머신은 다음과 같이 메모리에 구조화되어 있습니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type VM struct {\n   Block\n   ExtCost func(string) int64\n   FuncCallsDB map[string]struct{}\n   Extern bool\n   ShiftContract int64\n   logger *log.Entry\n}\n")])])]),a("p",[t._v("A VM 구조는 다음과 같은 요소들을 가지고 있습니다:")]),t._v(" "),a("ul",[a("li",[t._v("Block - [block 구조]를 포함합니다.")]),t._v(" "),a("li",[t._v("ExtCost - 외부 Golang 함수를 실행하는 비용을 반환하는 함수입니다.")]),t._v(" "),a("li",[t._v("FuncCallsDB - Golang 함수 이름들의 컬렉션입니다. 이 함수는 첫 번째 매개변수로 실행 비용을 반환합니다. 이러한 함수들은 데이터베이스 처리 비용을 계산하기 위해 EXPLAIN을 사용합니다.")]),t._v(" "),a("li",[t._v("Extern - 계약이 외부 계약인지를 나타내는 부울 플래그입니다. VM이 생성될 때 true로 설정됩니다. 코드가 컴파일될 때 호출된 계약들은 표시되지 않습니다. 즉, 미래에 결정된 계약 코드를 호출할 수 있게 합니다.")]),t._v(" "),a("li",[t._v("ShiftContract - VM에서 첫 번째 계약의 ID입니다.")]),t._v(" "),a("li",[t._v("logger - VM 오류 로그 출력입니다.")])]),t._v(" "),a("h3",{attrs:{id:"block-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block-structure"}},[t._v("#")]),t._v(" Block 구조 ")]),t._v(" "),a("p",[t._v("가상 머신은 "),a("strong",[t._v("Block 타입")]),t._v(" 객체들로 구성된 트리입니다.")]),t._v(" "),a("p",[t._v("블록은 일부 바이트코드를 포함하는 독립적인 단위입니다. 간단히 말해, 언어에서 중괄호("),a("code",[t._v("{}")]),t._v(")로 감싸진 모든 것이 블록입니다.")]),t._v(" "),a("p",[t._v("예를 들어, 다음과 같은 코드는 함수를 가진 블록을 생성합니다. 이 블록은 if 문을 포함하는 또 다른 블록을 포함하고 있으며, 이 if 문은 while 문을 포함하는 블록을 포함합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func my() {\n   if true {\n      while false {\n      ...\n      }\n   }\n}\n")])])]),a("p",[t._v("블록은 아래와 같은 구조로 메모리에 구성되어 있습니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type Block struct {\n   Objects map[string]*ObjInfo\n   Type int\n   Owner *OwnerInfo\n   Info interface{}\n   Parent *Block\n   Vars []reflect.Type\n   Code ByteCodes\n   Children Blocks\n}\n")])])]),a("p",[t._v("블록 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Objects")]),t._v(" - "),a("a",{attrs:{href:"#objinfo-structure"}},[t._v("ObjInfo")]),t._v(" 포인터 타입의 내부 객체 맵입니다. 예를 들어, 블록 내에 변수가 있는 경우, 변수의 이름을 통해 해당 변수에 대한 정보를 얻을 수 있습니다.")]),t._v(" "),a("li",[a("strong",[t._v("Type")]),t._v(" - 블록의 타입입니다. 함수 블록인 경우, 타입은 "),a("strong",[t._v("ObjFunc")]),t._v("이고, 계약 블록인 경우, 타입은 "),a("strong",[t._v("ObjContract")]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Owner")]),t._v(" - "),a("strong",[t._v("OwnerInfo")]),t._v(" 포인터 타입의 구조체입니다. 이 구조체는 컴파일된 계약의 소유자에 대한 정보를 포함하며, 계약 컴파일 시 지정되거나 "),a("strong",[t._v("contracts")]),t._v(" 테이블에서 얻을 수 있습니다.")]),t._v(" "),a("li",[a("strong",[t._v("Info")]),t._v(" - 블록 타입에 따라 객체에 대한 정보를 포함합니다.")]),t._v(" "),a("li",[a("strong",[t._v("Parent")]),t._v(" - 부모 블록을 가리키는 포인터입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Vars")]),t._v(" - 현재 블록 변수들의 타입을 포함하는 배열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Code")]),t._v(" - 블록 자체의 바이트코드입니다. 블록으로 제어 권한이 전달될 때 (예: 함수 호출 또는 루프 본문), 이 바이트코드가 실행됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("Children")]),t._v(" - 함수 중첩, 루프, 조건문 등 하위 블록들을 포함하는 배열입니다.")])]),t._v(" "),a("h3",{attrs:{id:"objinfo-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#objinfo-structure"}},[t._v("#")]),t._v(" ObjInfo 구조 ")]),t._v(" "),a("p",[t._v("ObjInfo 구조체는 내부 객체에 대한 정보를 포함합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type ObjInfo struct {\n   Type int\n   Value interface{}\n}\n")])])]),a("p",[t._v("ObjInfo 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Type")]),t._v("은 객체의 타입으로, 다음 중 하나의 값을 가집니다:\n"),a("ul",[a("li",[a("strong",[t._v("ObjContract")]),t._v(" – "),a("a",{attrs:{href:"#contractinfo-structure"}},[t._v("contract")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("ObjFunc")]),t._v(" - 함수;")]),t._v(" "),a("li",[a("strong",[t._v("ObjExtFunc")]),t._v(" - 외부 Golang 함수;")]),t._v(" "),a("li",[a("strong",[t._v("ObjVar")]),t._v(" - 변수;")]),t._v(" "),a("li",[a("strong",[t._v("ObjExtend")]),t._v(" - $name 변수.")])])]),t._v(" "),a("li",[a("strong",[t._v("Value")]),t._v(" – 각 타입의 구조체를 포함합니다.")])]),t._v(" "),a("h4",{attrs:{id:"contractinfo-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contractinfo-structure"}},[t._v("#")]),t._v(" ContractInfo 구조 ")]),t._v(" "),a("p",[a("strong",[t._v("ObjContract")]),t._v(" 타입을 가리키며, "),a("strong",[t._v("Value")]),t._v(" 필드에는 "),a("strong",[t._v("ContractInfo")]),t._v(" 구조체가 포함됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type ContractInfo struct {\n   ID uint32\n   Name string\n   Owner *OwnerInfo\n   Used map[string]bool\n   Tx *[]*FieldInfo\n}\n")])])]),a("p",[t._v("ContractInfo 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("ID")]),t._v(" - 계약 ID로, 계약을 호출할 때 블록체인에 표시됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("Name")]),t._v(" - 계약 이름입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Owner")]),t._v(" - 계약에 대한 다른 정보입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Used")]),t._v(" - 호출된 계약 이름들의 맵입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Tx")]),t._v(" - 계약의 "),a("RouterLink",{attrs:{to:"/kr/topics/script.html#data-section"}},[t._v("data section")]),t._v(" 에 기술된 데이터 배열입니다.")],1)]),t._v(" "),a("h4",{attrs:{id:"fieldinfo-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fieldinfo-structure"}},[t._v("#")]),t._v(" FieldInfo 구조 ")]),t._v(" "),a("p",[t._v("FieldInfo 구조는 "),a("strong",[t._v("ContractInfo")]),t._v(" 구조에서 사용되며, 계약의 "),a("RouterLink",{attrs:{to:"/kr/topics/script.html#data-section"}},[t._v("data section")]),t._v(" 에 있는 요소들을 설명합니다.")],1),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type FieldInfo struct {\n   Name string\n   Type reflect.Type\n   Original uint32\n   Tags string\n}\n")])])]),a("p",[t._v("FieldInfo 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Name")]),t._v(" - 필드 이름입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Type")]),t._v(" - 필드 타입입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Original")]),t._v(" - 선택적 필드입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Tags")]),t._v(" - 이 필드에 대한 추가적인 라벨입니다.")])]),t._v(" "),a("h4",{attrs:{id:"funcinfo-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#funcinfo-structure"}},[t._v("#")]),t._v(" FuncInfo 구조 ")]),t._v(" "),a("p",[t._v("ObjFunc 타입을 가리키며, Value 필드에는 FuncInfo 구조체가 포함됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type FuncInfo struct {\n   Params []reflect.Type\n   Results []reflect.Type\n   Names *map[string]FuncName\n   Variadic bool\n   ID uint32\n}\n")])])]),a("p",[t._v("FuncInfo 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Params")]),t._v(" - 매개변수 타입의 배열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Results")]),t._v(" - 반환 타입의 배열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Names")]),t._v(" - 테일 함수의 데이터 맵입니다. 예를 들어, "),a("code",[t._v("DBFind().Columns()")]),t._v("과 같은 함수입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Variadic")]),t._v(" - 함수가 가변 개수의 매개변수를 가질 수 있는 경우 true입니다.")]),t._v(" "),a("li",[a("strong",[t._v("ID")]),t._v(" - 함수 ID입니다.")])]),t._v(" "),a("h4",{attrs:{id:"funcname-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#funcname-structure"}},[t._v("#")]),t._v(" FuncName 구조 ")]),t._v(" "),a("p",[t._v("FuncName 구조체는 FuncInfo에 사용되며, 테일 함수의 데이터를 설명합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type FuncName struct {\n   Params []reflect.Type\n   Offset []int\n   Variadic bool\n}\n")])])]),a("p",[t._v("FuncName 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Params")]),t._v(" - 매개변수 타입의 배열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Offset")]),t._v(" - 이러한 변수들에 대한 오프셋 배열입니다. 사실, 함수 내의 모든 매개변수 값은 점(.)으로 초기화될 수 있습니다.")]),t._v(" "),a("li",[a("strong",[t._v("Variadic")]),t._v(" - 테일 함수가 가변 개수의 매개변수를 가질 수 있는 경우 true입니다.")])]),t._v(" "),a("h4",{attrs:{id:"extfuncinfo-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extfuncinfo-structure"}},[t._v("#")]),t._v(" ExtFuncInfo 구조 ")]),t._v(" "),a("p",[t._v("ObjExtFunc 타입을 가리키며, Value 필드에는 ExtFuncInfo 구조체가 포함됩니다. 이는 Golang 함수를 설명하기 위해 사용됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type ExtFuncInfo struct {\n   Name string\n   Params []reflect.Type\n   Results []reflect.Type\n   Auto []string\n   Variadic bool\n   Func interface{}\n}\n")])])]),a("p",[t._v("ExtFuncInfo 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Name")]),t._v(", "),a("strong",[t._v("Params")]),t._v(", "),a("strong",[t._v("Results")]),t._v(" 매개변수는 "),a("a",{attrs:{href:"#funcinfo-structure"}},[t._v("FuncInfo")]),t._v(" 와 동일한 구조를 가지고 있습니다.")]),t._v(" "),a("li",[a("strong",[t._v("Auto")]),t._v(" - 변수의 배열입니다. 함수로 전달되는 추가적인 매개변수입니다. 예를 들어, SmartContract sc 타입의 변수입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Func")]),t._v(" - Golang 함수입니다.")])]),t._v(" "),a("h4",{attrs:{id:"varinfo-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#varinfo-structure"}},[t._v("#")]),t._v(" VarInfo 구조 ")]),t._v(" "),a("p",[t._v("ObjVar 타입을 가리키며, Value 필드에는 VarInfo 구조체가 포함됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type VarInfo struct {\n   Obj *ObjInfo\n   Owner *Block\n}\n")])])]),a("p",[t._v("VarInfo 구조는 다음과 같은 요소들로 구성됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Obj")]),t._v(" - 변수의 타입과 값에 대한 정보입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Owner")]),t._v(" - 소유 블록을 가리키는 포인터입니다.")])]),t._v(" "),a("h4",{attrs:{id:"objextend-value"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#objextend-value"}},[t._v("#")]),t._v(" ObjExtend 값 ")]),t._v(" "),a("p",[t._v("ObjExtend 타입을 가리키며, Value 필드에는 변수 또는 함수의 이름을 포함하는 문자열이 포함됩니다.")]),t._v(" "),a("h2",{attrs:{id:"virtual-machine-commands"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-machine-commands"}},[t._v("#")]),t._v(" 가상 머신 명령 ")]),t._v(" "),a("h3",{attrs:{id:"bytecode-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytecode-structure"}},[t._v("#")]),t._v(" ByteCode 구조 ")]),t._v(" "),a("p",[t._v("바이트코드는 "),a("strong",[t._v("ByteCode")]),t._v(" 타입 구조체의 연속입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type ByteCode struct {\n   Cmd uint16\n   Value interface{}\n}\n")])])]),a("p",[t._v("이 구조체는 다음과 같은 필드들을 가지고 있습니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Cmd")]),t._v(" - 저장 명령의 식별자입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Value")]),t._v(" - 피연산자(값)를 포함합니다.")])]),t._v(" "),a("p",[t._v("일반적으로, 명령은 스택의 최상위 요소에 대한 작업을 수행하고 필요한 경우 결과 값을 스택에 기록합니다.")]),t._v(" "),a("h3",{attrs:{id:"command-identifiers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#command-identifiers"}},[t._v("#")]),t._v(" 명령 식별자 ")]),t._v(" "),a("p",[t._v("가상 머신 명령의 식별자는 vm/cmds_list.go 파일에서 설명됩니다.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("cmdPush")]),t._v(" - Value 필드의 값을 스택에 넣습니다. 예를 들어, 숫자와 문자열을 스택에 넣습니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdVar")]),t._v(" - 변수의 값을 스택에 넣습니다. Value에는 VarInfo 구조체의 포인터와 변수에 대한 정보가 포함됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdExtend")]),t._v(" - 외부 변수의 값을 스택에 넣습니다. Value에는 변수 이름(달러 기호로 시작)을 포함하는 문자열이 있습니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdCallExtend")]),t._v(" - 외부 함수(달러 기호로 시작)를 호출합니다. 함수의 매개변수는 스택에서 가져오고 결과는 스택에 저장됩니다. Value에는 함수 이름(달러 기호로 시작)이 포함됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdPushStr")]),t._v(" - Value에 있는 문자열을 스택에 넣습니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdCall")]),t._v(" - 가상 머신 함수를 호출합니다. Value에는 "),a("strong",[t._v("ObjInfo")]),t._v(" 구조체가 포함됩니다. 이 명령은 "),a("strong",[t._v("ObjExtFunc")]),t._v(" golang 함수와 "),a("strong",[t._v("ObjFunc")]),t._v(" Needle 함수에 적용됩니다. 함수를 호출하는 경우, 매개변수는 스택에서 가져오고 결과 값은 스택에 저장됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdCallVari")]),t._v(" - "),a("strong",[t._v("cmdCall")]),t._v(" 명령과 유사하며, 가변 개수의 매개변수를 가진 함수를 호출합니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdReturn")]),t._v(" - 함수를 종료하는 데 사용됩니다. 반환 값은 스택에 넣으며, Value 필드는 사용되지 않습니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdIf")]),t._v(" - Value 필드에 전달된 "),a("strong",[t._v("block")]),t._v(" 구조체의 바이트코드로 제어를 전달합니다. 스택의 최상위 요소가 "),a("em",[t._v("valueToBool")]),t._v(" 함수에 의해 호출되고 "),a("code",[t._v("true")]),t._v("가 반환될 때만 제어가 전달됩니다. 그렇지 않은 경우, 다음 명령으로 제어가 전달됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdElse")]),t._v(" - 이 명령은 "),a("strong",[t._v("cmdIf")]),t._v("와 동일한 방식으로 작동하지만, 스택의 최상위 요소가 "),a("em",[t._v("valueToBool")]),t._v(" 함수에 의해 호출되고 "),a("code",[t._v("false")]),t._v("가 반환될 때에만 지정된 블록으로 제어가 전달됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdAssignVar")]),t._v(" - Value에서 "),a("strong",[t._v("VarInfo")]),t._v(" 타입의 변수 목록을 가져옵니다. 이러한 변수는 "),a("strong",[t._v("cmdAssign")]),t._v(" 명령을 사용하여 값을 가져옵니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdAssign")]),t._v(" - 스택의 값을 "),a("strong",[t._v("cmdAssignVar")]),t._v(" 명령으로 얻은 변수에 할당합니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdLabel")]),t._v(" - while 루프에서 제어가 반환될 때 레이블을 정의합니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdContinue")]),t._v(" - 이 명령은 "),a("strong",[t._v("cmdLabel")]),t._v(" 레이블로 제어를 전달합니다. 루프의 새로운 반복을 실행할 때 Value는 사용되지 않습니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdWhile")]),t._v(" - 스택의 최상위 요소를 valueToBool로 확인합니다. 이 값이 "),a("code",[t._v("true")]),t._v("인 경우, "),a("strong",[t._v("block")]),t._v(" 구조체가 value 필드로부터 호출됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdBreak")]),t._v(" - 루프를 종료합니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdIndex")]),t._v(" - Value를 사용하지 않고, 맵 또는 배열에서 인덱스로 값을 스택에 넣습니다. 예를 들어, "),a("code",[t._v("(map | array) (index value) => (map | array [index value])")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdSetIndex")]),t._v(" - Value를 사용하지 않고, 맵 또는 배열의 요소에 스택의 최상위 요소의 값을 할당합니다. 예를 들어, "),a("code",[t._v("(map | array) (index value) (value) => (map | array)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdFuncName")]),t._v(" - 점 .으로 구분된 순차적인 설명을 사용하여 전달되는 매개변수를 추가합니다. 예를 들어, "),a("code",[t._v("func name => Func (...) .Name (...)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdUnwrapArr")]),t._v(" - 스택의 최상위 요소가 배열인 경우에 대한 불리언 플래그를 정의합니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdMapInit")]),t._v(" - 맵의 값을 초기화합니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdArrayInit")]),t._v(" - 배열의 값을 초기화합니다.")]),t._v(" "),a("li",[a("strong",[t._v("cmdError")]),t._v(" - 이 명령은 계약 또는 함수가 지정된 "),a("code",[t._v("error, warning, info")]),t._v("로 종료될 때 생성됩니다.")])]),t._v(" "),a("h3",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")]),t._v(" 스택 연산 명령 (#stack-operation-commands)")]),t._v(" "),a("blockquote",[a("p",[t._v("참고")])]),t._v(" "),a("blockquote",[a("p",[t._v("현재 버전에서는 자동 유형 변환이 이러한 명령에 완전히 적용되지 않습니다. 예를 들어,")])]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("string + float | int | decimal => float | int | decimal, float + int | str => float, but int + string => runtime error")]),t._v(".")])]),t._v(" "),a("p",[t._v("다음은 직접 스택 처리를 위한 명령입니다. 값 필드는 이러한 명령에서 사용되지 않습니다.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("cmdNot")]),t._v(" - 논리 부정. "),a("code",[t._v("(val) => (!ValueToBool(val))")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdSign")]),t._v(" - 부호 변경. "),a("code",[t._v("(val) => (-val)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdAdd")]),t._v(" - 덧셈. "),a("code",[t._v("(val1)(val2) => (val1 + val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdSub")]),t._v(" - 뺄셈. "),a("code",[t._v("(val1)(val2) => (val1-val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdMul")]),t._v(" - 곱셈. "),a("code",[t._v("(val1)(val2) => (val1 * val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdDiv")]),t._v(" - 나눗셈. "),a("code",[t._v("(val1)(val2) => (val1 / val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdAnd")]),t._v(" - 논리 AND. "),a("code",[t._v("(val1)(val2) => (valueToBool(val1) && valueToBool(val2))")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdOr")]),t._v(" - 논리 OR. "),a("code",[t._v("(val1)(val2) => (valueToBool(val1) || valueToBool(val2))")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdEqual")]),t._v(" - 동등 비교, bool이 반환됩니다. "),a("code",[t._v("(val1)(val2) => (val1 == val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdNotEq")]),t._v(" - 부등호 비교, bool이 반환됩니다. "),a("code",[t._v("(val1)(val2) => (val1 != val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdLess")]),t._v(" - 작다 비교, bool이 반환됩니다. "),a("code",[t._v("(val1)(val2) => (val1 < val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdNotLess")]),t._v(" - 크거나 같다 비교, bool이 반환됩니다. "),a("code",[t._v("(val1)(val2) => (val1 >= val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdGreat")]),t._v(" - 크다 비교, bool이 반환됩니다. "),a("code",[t._v("(val1)(val2) => (val1 > val2)")]),t._v(";")]),t._v(" "),a("li",[a("strong",[t._v("cmdNotGreat")]),t._v(" - 작거나 같다 비교, bool이 반환됩니다. "),a("code",[t._v("(val1)(val2) => (val1 <= val2)")]),t._v(".")])]),t._v(" "),a("h3",{attrs:{id:"runtime-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runtime-structure"}},[t._v("#")]),t._v(" Runtime 구조 ")]),t._v(" "),a("p",[t._v("바이트코드 실행은 가상 머신에 영향을 미치지 않습니다. 예를 들어 다양한 기능과 계약을 단일 가상 머신에서 동시에 실행할 수 있습니다. 런타임 구조는 함수와 계약은 물론 모든 식과 바이트코드를 실행하는 데 사용됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type RunTime struct {\n   stack []interface{}\n   blocks []*blockStack\n   vars []interface{}\n   extend *map[string]interface{}\n   vm *VM\n   cost int64\n   err error\n}\n")])])]),a("ul",[a("li",[a("strong",[t._v("stack")]),t._v(" - 실행에 사용되는 스택입니다.")]),t._v(" "),a("li",[a("strong",[t._v("blocks")]),t._v(" - 블록 호출 스택입니다.")]),t._v(" "),a("li",[a("strong",[t._v("vars")]),t._v(" - 변수 스택입니다. 블록에서 바이트코드가 호출될 때 변수가 변수 스택에 추가됩니다. 블록을 나갈 때 변수 스택의 크기는 이전 값으로 돌아갑니다.")]),t._v(" "),a("li",[a("strong",[t._v("extend")]),t._v(" - 외부 변수 ("),a("code",[t._v("$name")]),t._v(")의 값이 포함된 맵에 대한 포인터입니다.")]),t._v(" "),a("li",[a("strong",[t._v("vm")]),t._v(" - 가상 머신 포인터입니다.")]),t._v(" "),a("li",[a("strong",[t._v("cost")]),t._v(" - 실행 비용의 연료 단위입니다.")]),t._v(" "),a("li",[a("strong",[t._v("err")]),t._v(" - 실행 중에 발생한 오류입니다.")])]),t._v(" "),a("h4",{attrs:{id:"blockstack-structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blockstack-structure"}},[t._v("#")]),t._v(" blockStack 구조 ")]),t._v(" "),a("p",[t._v("blockStack 구조는 Runtime 구조에서 사용됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type blockStack struct {\n   Block *Block\n   Offset int\n}\n")])])]),a("ul",[a("li",[a("strong",[t._v("Block")]),t._v(" - 실행 중인 블록에 대한 포인터입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Offset")]),t._v(" - 지정된 블록의 바이트코드에서 마지막으로 실행된 명령의 오프셋입니다.")])]),t._v(" "),a("h3",{attrs:{id:"runcode-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runcode-function"}},[t._v("#")]),t._v(" RunCode 함수 ")]),t._v(" "),a("p",[t._v("바이트코드는 "),a("strong",[t._v("RunCode")]),t._v(" 함수에서 실행됩니다. 이 함수에는 각 바이트코드 명령에 대해 해당 작업을 수행하는 루프가 포함되어 있습니다. 바이트코드를 처리하기 전에 필요한 데이터를 초기화해야 합니다.")]),t._v(" "),a("p",[t._v("새로운 블록은 다른 블록에 추가됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("rt.blocks = append(rt.blocks, &blockStack{block, len(rt.vars)})\n")])])]),a("p",[t._v("다음으로 tail 함수의 관련 매개변수 정보를 가져옵니다. 이러한 매개변수는 스택의 마지막 요소에 포함됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var namemap map[string][]interface{}\nif block.Type == ObjFunc && block.Info.(*FuncInfo).Names != nil {\n   if rt.stack[len(rt.stack)-1] != nil {\n      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})\n   }\n   rt.stack = rt.stack[:len(rt.stack)-1]\n}\n")])])]),a("p",[t._v("그런 다음 현재 블록에 정의된 모든 변수를 초기값으로 초기화해야 합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("start := len(rt.stack)\nvaroff := len(rt.vars)\nfor vkey, vpar := range block.Vars {\n   rt.cost--\n   var value interface{}\n")])])]),a("p",[t._v("함수의 변수도 변수이므로 함수 자체에서 설명하는 순서대로 스택의 마지막 요소에서 변수를 검색해야 합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   if block.Type == ObjFunc && vkey <len(block.Info.(*FuncInfo).Params) {\n      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]\n   } else {\n")])])]),a("p",[t._v("지역 변수를 초기 값으로 초기화합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("      value = reflect.New(vpar).Elem().Interface()\n\n      if vpar == reflect.TypeOf(map[string]interface{}{}) {\n\n         value = make(map[string]interface{})\n      } else if vpar == reflect.TypeOf([]interface{}{}) {\n         value = make([]interface{}, 0, len(rt.vars)+1)\n      }\n   }\n   rt.vars = append(rt.vars, value)\n}\n")])])]),a("p",[t._v("다음으로 tail 함수에 전달된 변수 매개변수의 값을 업데이트합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if namemap != nil {\n   for key, item := range namemap {\n      params := (*block.Info.(*FuncInfo).Names)[key]\n      for i, value := range item {\n         if params.Variadic && i >= len(params.Params)-1 {\n")])])]),a("p",[t._v("전달된 가변 매개변수가 가변 개수의 매개변수에 속하는 경우 이러한 매개변수는 변수 배열로 결합됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("            off := varoff + params.Offset[len(params.Params)-1]\n            rt.vars[off] = append(rt.vars[off].([]interface{}), value)\n         } else {\n            rt.vars[varoff+params.Offset[i]] = value\n         }\n      }\n   }\n}\n")])])]),a("p",[t._v("그런 다음 스택의 맨 위에서 함수 매개 변수로 전달된 값을 삭제하여 스택을 이동하기만 하면 됩니다. 값을 변수 배열에 복사했습니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if block.Type == ObjFunc {\n   start -= len(block.Info.(*FuncInfo).Params)\n}\n")])])]),a("p",[t._v("바이트 코드 명령 루프가 완료되면 스택을 올바르게 지워야 합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("last := rt.blocks[len(rt.blocks)-1]\n")])])]),a("p",[t._v("블록 스택에서 현재 블록을 삭제합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("rt.blocks = rt.blocks[:len(rt.blocks)-1]\nif status == statusReturn {\n")])])]),a("p",[t._v("이미 실행된 함수에서 성공적으로 종료되면 이전 스택의 끝에 반환 값을 추가합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   if last.Block.Type == ObjFunc {\n      for count := len(last.Block.Info.(*FuncInfo).Results); count > 0; count-- {\n         rt.stack[start] = rt.stack[len(rt.stack)-count]\n         start++\n      }\n      status = statusNormal\n   } else {\n")])])]),a("p",[t._v("보시다시피 함수를 실행하지 않으면 스택 상태를 복원하지 않고 함수를 그대로 종료합니다. 그 이유는 함수에서 실행된 루프와 조건부 구조도 바이트코드 블록이기 때문입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   return\n\n   }\n}\n\nrt.stack = rt.stack[:start]\n")])])]),a("h3",{attrs:{id:"other-functions-for-operations-with-vm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#other-functions-for-operations-with-vm"}},[t._v("#")]),t._v(" 가상 머신과 관련된 기타 함수들 ")]),t._v(" "),a("p",[a("strong",[t._v("NewVM")]),t._v(" 함수를 사용하여 가상 머신을 생성할 수 있습니다. 각 가상 머신에는 "),a("strong",[t._v("ExecContract")]),t._v(", "),a("strong",[t._v("MemoryUsage")]),t._v(", "),a("strong",[t._v("CallContract")]),t._v(", "),a("strong",[t._v("Settings")]),t._v("와 같은 네 개의 함수가 "),a("strong",[t._v("Extend")]),t._v(" 함수를 통해 추가됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for key, item := range ext.Objects {\n   fobj := reflect.ValueOf(item).Type()\n")])])]),a("p",[t._v("전달된 모든 객체를 순회하고 함수만 봅니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   switch fobj.Kind() {\n   case reflect.Func:\n")])])]),a("p",[t._v("함수에 대해 수신된 정보에 따라 "),a("strong",[t._v("ExtFuncInfo")]),t._v(" 구조를 채우고 해당 구조를 최상위 맵 "),a("strong",[t._v("Objects")]),t._v("에 이름별로 추가합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),\n   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}\n   for i := 0; i <fobj.NumIn(); i++ {\n")])])]),a("p",[a("strong",[t._v("ExtFuncInfo")]),t._v(" 구조에는 "),a("strong",[t._v("Auto")]),t._v(" 매개변수 배열이 있습니다. 일반적으로 첫 번째 매개변수는 "),a("code",[t._v("sc *SmartContract")]),t._v(" 또는 "),a("code",[t._v("rt *Runtime")]),t._v("이며 일부 golang 기능을 실행하는 데 필요하기 때문에 니들 언어에서 전달할 수 없습니다. 따라서 이러한 함수가 호출될 때 이러한 변수가 자동으로 사용되도록 지정합니다. 이 경우 위의 네 가지 함수 중 첫 번째 매개변수는 "),a("code",[t._v("rt *Runtime")]),t._v("입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {\n      data.Auto[i] = isauto\n   }\n")])])]),a("p",[t._v("매개변수 할당에 대한 정보입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("      data.Params[i] = fobj.In(i)\n   }\n")])])]),a("p",[t._v("그리고 반환 값의 유형.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for i := 0; i <fobj.NumOut(); i++ {\n   data.Results[i] = fobj.Out(i)\n}\n")])])]),a("p",[t._v("컴파일러가 나중에 계약을 사용할 때 찾을 수 있도록 루트 "),a("strong",[t._v("Objects")]),t._v(" 에 함수를 추가합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("      vm.Objects[key] = &ObjInfo{ObjExtFunc, data}\n   }\n\n}\n")])])]),a("h2",{attrs:{id:"compiler"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compiler"}},[t._v("#")]),t._v(" 컴파일러 ")]),t._v(" "),a("p",[t._v("compile.go 파일의 함수는 어휘 분석기에서 얻은 토큰 배열을 컴파일하는 역할을 합니다. 컴파일은 조건부로 두 가지 수준으로 나눌 수 있습니다. 최상위 수준에서는 함수, 계약, 코드 블록, 조건문 및 루프 문, 변수 정의 등을 처리합니다. 하위 수준에서는 코드 블록의 식이나 루프 및 조건문의 조건을 컴파일합니다.")]),t._v(" "),a("p",[t._v("먼저 간단한 하위 레벨부터 시작하겠습니다. "),a("strong",[t._v("compileEval")]),t._v(" 함수에서 표현식을 바이트코드로 변환할 수 있습니다. 우리는 스택이 있는 가상 머신을 사용하기 때문에 일반 중위 레코드 표현식을 후위 표기법이나 역폴란드어 표기법으로 변환해야 합니다. 예를 들어 "),a("code",[t._v("1+2")]),t._v("를 "),a("code",[t._v("12+")]),t._v("로 변환하고 "),a("code",[t._v("1")]),t._v("과 "),a("code",[t._v("2")]),t._v("를 스택에 넣습니다. 그런 다음 스택의 마지막 두 요소에 더하기 연산을 적용하고 결과를 스택에 씁니다. 이 "),a("a",{attrs:{href:"https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/",target:"_blank",rel:"noopener noreferrer"}},[t._v("변환"),a("OutboundLink")],1),t._v(" 알고리즘은 인터넷에서 찾을 수 있습니다.")]),t._v(" "),a("p",[t._v("전역 변수 "),a("code",[t._v("opers = map [uint32] operPrior")]),t._v(" 에는 역 폴란드 표기법으로 변환하는 데 필요한 작업의 우선 순위가 포함되어 있습니다.")]),t._v(" "),a("p",[a("strong",[t._v("compileEval")]),t._v(" 함수의 시작 부분에서 다음과 같은 변수들이 정의됩니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("buffer")]),t._v(" - 바이트코드 명령어의 임시 버퍼")]),t._v(" "),a("li",[a("strong",[t._v("bytecode")]),t._v(" - 최종적인 바이트코드 명령어의 버퍼")]),t._v(" "),a("li",[a("strong",[t._v("parcount")]),t._v(" - 함수 호출 시 매개변수를 계산하는 데 사용되는 임시 버퍼")]),t._v(" "),a("li",[a("strong",[t._v("setIndex")]),t._v(" - 작업 프로세스에서 변수가 map이나 array 요소에 할당될 때 true로 설정됩니다. 예를 들어, "),a("code",[t._v('a["my"] = 10')]),t._v("과 같이 사용될 때 특정한 "),a("strong",[t._v("cmdSetIndex")]),t._v(" 명령어를 사용해야 합니다.")])]),t._v(" "),a("p",[t._v("루프에서 토큰을 가져와 해당 토큰을 처리합니다. 예를 들어, 괄호가 발견되면 식 분석을 중단합니다. 문자열을 이동할 때 이전 문장이 연산인지, 괄호 안에 있는지를 확인하고, 그렇지 않은 경우 식 분석이 종료됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("case isRCurly, isLCurly:\n   i--\n   if prevLex == isComma || prevLex == lexOper {\n      return errEndExp\n   }\n   break main\ncase lexNewLine:\n   if i > 0 && ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {\n      continue main\n   }\n   for k := len(buffer) - 1; k >= 0; k-- {\n   if buffer[k].Cmd == cmdSys {\n      continue main\n   }\n}\nbreak main\n\n")])])]),a("p",[t._v("일반적으로 알고리즘 자체는 역 폴란드 표기법으로 변환하는 알고리즘에 해당합니다. 필요한 컨트랙트, 함수, 인덱스 호출, 파싱 중에 만나지 못한 기타 사항, lexIdent 유형 토큰 파싱 옵션 등을 고려하여 이 이름을 가진 변수, 함수 또는 컨트랙트를 확인합니다. 아무 것도 발견되지 않고 이것이 함수 또는 계약 호출이 아닌 경우 오류를 나타냅니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("objInfo, tobj := vm.findObj(lexem.Value.(string), block)\nif objInfo == nil && (!vm.Extern || i> *ind || i >= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {\n   return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))\n}\n")])])]),a("p",[t._v("이러한 상황에 직면할 수 있으며 계약 호출에 대해서는 나중에 설명합니다. 이 예제에서 이름이 같은 함수나 변수가 없으면 계약을 호출해야 한다고 생각합니다. 이 컴파일된 언어에서는 계약과 함수 호출 사이에 차이가 없습니다. 하지만 바이트코드에 사용된 "),a("strong",[t._v("ExecContract")]),t._v(" 함수를 통해 컨트랙트를 호출해야 합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if objInfo.Type == ObjContract {\n   if objInfo.Value != nil {\n      objContract = objInfo.Value.(*Block)\n   }\n   objInfo, tobj = vm.findObj(`ExecContract`, block)\n   isContract = true\n}\n")])])]),a("p",[t._v("우리는 "),a("code",[t._v("count")]),t._v(" 에 지금까지 변수의 수를 기록하고 함수 매개변수의 수와 함께 스택에도 기록됩니다. 각 후속 매개변수 감지에서 스택의 마지막 요소에서 이 숫자를 한 단위씩 늘리면 됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("count := 0\nif (*lexems)[i+2].Type != isRPar {\n   count++\n}\n")])])]),a("p",[t._v("우리는 컨트랙트에 대한 호출된 매개변수 목록을 가지고 있으며, 컨트랙트가 호출된 경우를 표시해야 합니다. 계약이 매개변수 없이 호출되면 "),a("strong",[t._v("ExecContract")]),t._v(" 를 호출하기 위해 두 개의 빈 매개변수를 추가하여 최소 두 개의 매개변수를 가져와야 합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('if isContract {\n   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))\n   for j := len(*block) - 1; j >= 0; j-- {\n   topblock := (*block)[j]\n      if topblock.Type == ObjContract {\n         if topblock.Info.(*ContractInfo).Used == nil {\n            topblock.Info.(*ContractInfo).Used = make(map[string]bool)\n         }\n         topblock.Info.(*ContractInfo).Used[name] = true\n      }\n   }\n   bytecode = append(bytecode, &ByteCode{cmdPush, name})\n   if count == 0 {\n      count = 2\n      bytecode = append(bytecode, &ByteCode{cmdPush, ""})\n      bytecode = append(bytecode, &ByteCode{cmdPush, ""})\n   }\n   count++\n}\n')])])]),a("p",[t._v("다음에 대괄호가 있으면 "),a("strong",[t._v("cmdIndex")]),t._v(" 명령을 추가하여 인덱스로 값을 가져옵니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if (*lexems)[i+1].Type == isLBrack {\n   if objInfo == nil || objInfo.Type != ObjVar {\n      return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))\n   }\n   buffer = append(buffer, &ByteCode{cmdIndex, 0})\n}\n")])])]),a("p",[a("strong",[t._v("CompileBlock")]),t._v(" 함수는 개체 트리와 식 독립적인 바이트코드를 생성할 수 있습니다. 컴파일 프로세스는 어휘 분석기와 마찬가지로 유한 상태 머신을 기반으로 하지만 다음과 같은 차이점이 있습니다. 첫째, 기호가 아닌 토큰을 사용합니다. 둘째, 모든 상태 및 전환에서 "),a("em",[t._v("상태")]),t._v(" 변수를 즉시 설명합니다. 토큰 유형별로 인덱싱된 개체 배열을 나타냅니다. 각 토큰은 "),a("em",[t._v("compileState")]),t._v(" 구조를 가지며 "),a("em",[t._v("NewState")]),t._v(" 에 새로운 상태가 지정됩니다. 해결한 구조가 명확하면 "),a("em",[t._v("Func")]),t._v(" 필드에 핸들러의 기능을 지정할 수 있습니다.")]),t._v(" "),a("p",[t._v("기본 상태를 예로 들어 살펴보겠습니다.")]),t._v(" "),a("p",[t._v("줄바꿈이나 주석을 만나면 동일한 상태를 유지합니다. "),a("strong",[t._v("contract")]),t._v(" 키워드를 만나면 상태를 "),a("em",[t._v("stateContract")]),t._v("로 변경하고 구조 구문 분석을 시작합니다. "),a("strong",[t._v("func")]),t._v(" 키워드를 만나면 상태를 "),a("em",[t._v("stateFunc")]),t._v("로 변경합니다. 다른 토큰이 수신되면 함수 생성 오류가 호출됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{// stateRoot\n   lexNewLine: {stateRoot, 0},\n   lexKeyword | (keyContract << 8): {stateContract | statePush, 0},\n   lexKeyword | (keyFunc << 8): {stateFunc | statePush, 0},\n   lexComment: {stateRoot, 0},\n   0: {errUnknownCmd, cfError},\n},\n")])])]),a("p",[a("strong",[t._v("func")]),t._v(" 키워드를 만났고 상태를 "),a("em",[t._v("stateFunc")]),t._v("로 변경했다고 가정합니다. 함수 이름은 "),a("strong",[t._v("func")]),t._v(" 키워드 뒤에 와야 하므로 함수 이름을 변경해도 동일한 상태를 유지합니다. 다른 모든 토큰의 경우 해당 오류를 생성합니다. 토큰 식별자에서 함수 이름을 얻으면 함수의 매개변수를 얻을 수 있는 "),a("em",[t._v("stateFParams")]),t._v(" 상태로 이동합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{// stateFunc\n   lexNewLine: {stateFunc, 0},\n   lexIdent: {stateFParams, cfNameBlock},\n   0: {errMustName, cfError},\n},\n")])])]),a("p",[t._v("위의 작업과 동시에 "),a("strong",[t._v("fNameBlock")]),t._v(" 함수를 호출합니다. Block 구조는 statePush 표시로 생성되며 버퍼에서 가져와 필요한 데이터로 채웁니다. "),a("strong",[t._v("fNameBlock")]),t._v(" 기능은 계약 및 기능(내포된 기능 포함)에 적합합니다. "),a("em",[t._v("Info")]),t._v(" 필드를 해당 구조로 채우고 부모 블록의 "),a("em",[t._v("Objects")]),t._v("에 자신을 기록합니다. 이런 식으로 지정된 이름으로 함수 또는 계약을 호출할 수 있습니다. 마찬가지로 모든 상태와 변수에 해당하는 함수를 만듭니다. 이러한 기능은 일반적으로 매우 작으며 가상 머신 트리를 구성할 때 일부 임무를 수행합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {\n   var itype int\n   prev := (*buf)[len(*buf)-2]\n   fblock := (*buf)[len(*buf)-1]\n   name := lexem.Value.(string)\n   switch state {\n      case stateBlock:\n         itype = ObjContract\n         name = StateName((*buf)[0].Info.(uint32), name)\n         fblock.Info = &ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,\n         Owner: (*buf)[0].Owner}\n      default:\n         itype = ObjFunc\n         fblock.Info = &FuncInfo{}\n   }\n   fblock.Type = itype\n   prev.Objects[name] = &ObjInfo{Type: itype, Value: fblock}\n   return nil\n}\n")])])]),a("p",[a("strong",[t._v("CompileBlock")]),t._v(" 함수는 모든 토큰을 순회하며 states에 설명된 토큰에 따라 상태를 전환합니다. 거의 모든 추가 토큰은 추가 프로그램 코드와 대응됩니다.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("statePush")]),t._v(" - "),a("strong",[t._v("Block")]),t._v(" 객체를 객체 트리에 추가합니다.")]),t._v(" "),a("li",[a("strong",[t._v("statePop")]),t._v(" - 블록이 닫는 중괄호로 끝나는 경우 사용됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("stateStay")]),t._v(" - 새로운 상태로 전환할 때 현재 마크를 유지해야 합니다.")]),t._v(" "),a("li",[a("strong",[t._v("stateToBlock")]),t._v(" - "),a("em",[t._v("while")]),t._v("과 "),a("em",[t._v("if")]),t._v("를 처리하기 위해 "),a("strong",[t._v("stateBlock")]),t._v(" 상태로 전환합니다. 표현식을 처리한 후 중괄호 내의 블록을 처리해야 합니다.")]),t._v(" "),a("li",[a("strong",[t._v("stateToBody")]),t._v(" - "),a("strong",[t._v("stateBody")]),t._v(" 상태로 전환합니다.")]),t._v(" "),a("li",[a("strong",[t._v("stateFork")]),t._v(" - 마크된 위치를 저장합니다. 식이 식별자로 시작하거나 "),a("code",[t._v("$")]),t._v("가 포함된 이름인 경우 함수 호출이나 할당을 수행할 수 있습니다.")]),t._v(" "),a("li",[a("strong",[t._v("stateToFork")]),t._v(" - "),a("strong",[t._v("stateFork")]),t._v("에 저장된 토큰을 가져옵니다. 이 토큰은 프로세스 함수로 전달될 것입니다.")]),t._v(" "),a("li",[a("strong",[t._v("stateLabel")]),t._v(" - "),a("strong",[t._v("cmdLabel")]),t._v(" 명령어를 삽입하기 위해 사용됩니다. "),a("em",[t._v("while")]),t._v(" 구조에는 이 플래그가 필요합니다.")]),t._v(" "),a("li",[a("strong",[t._v("stateMustEval")]),t._v(" - "),a("em",[t._v("if")]),t._v("와 "),a("em",[t._v("while")]),t._v(" 구조의 시작 부분에서 조건식의 유효성을 확인합니다.")])]),t._v(" "),a("p",[a("strong",[t._v("CompileBlock")]),t._v(" 함수 외에도 "),a("strong",[t._v("FlushBlock")]),t._v(" 함수에 대해 언급해야 합니다. 그러나 문제는 블록 트리가 기존 가상 머신과 독립적으로 구성된다는 점입니다. 보다 정확히 말하면, 가상 머신에 존재하는 함수와 계약에 대한 정보를 얻지만, 컴파일된 블록은 별도의 트리로 수집합니다. 그렇지 않으면 컴파일 중에 오류가 발생하면 가상 머신을 이전 상태로 롤백해야 합니다. 따라서 컴파일 트리로 따로 이동하지만 컴파일이 성공한 후에는 "),a("strong",[t._v("FlushContract")]),t._v(" 함수를 호출해야 합니다. 이 함수는 완성된 블록 트리를 현재 가상 머신에 추가합니다. 컴파일 단계는 이제 완료되었습니다.")]),t._v(" "),a("h2",{attrs:{id:"lexical-analyzer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lexical-analyzer"}},[t._v("#")]),t._v(" 어휘 분석기 ")]),t._v(" "),a("p",[t._v("다음과 같은 유형의 토큰 시퀀스를 형성하기 위해 렉시컬 분석기는 들어오는 문자열을 처리합니다:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("lexSys")]),t._v(" - 시스템 토큰, 예를 들면: "),a("code",[t._v("{}, [], (), ,, .")]),t._v(" 등")]),t._v(" "),a("li",[a("strong",[t._v("lexOper")]),t._v(" - 연산 토큰, 예를 들면: "),a("code",[t._v("+, -, /, \\, *")]),t._v(" 등")]),t._v(" "),a("li",[a("strong",[t._v("lexNumber")]),t._v(" - 숫자")]),t._v(" "),a("li",[a("strong",[t._v("lexident")]),t._v(" - 식별자")]),t._v(" "),a("li",[a("strong",[t._v("lexNewline")]),t._v(" - 개행 문자")]),t._v(" "),a("li",[a("strong",[t._v("lexString")]),t._v(" - 문자열")]),t._v(" "),a("li",[a("strong",[t._v("lexComment")]),t._v(" - 주석")]),t._v(" "),a("li",[a("strong",[t._v("lexKeyword")]),t._v(" - 키워드")]),t._v(" "),a("li",[a("strong",[t._v("lexType")]),t._v(" - 타입")]),t._v(" "),a("li",[a("strong",[t._v("lexExtend")]),t._v(" - 외부 변수나 함수를 참조하는 것, 예를 들면: "),a("code",[t._v("$myname")])])]),t._v(" "),a("p",[t._v("현재 버전에서는 파싱을 위해 초기에 "),a("a",{attrs:{href:"#lextable-lextable-go"}},[t._v("script/lextable/lextable.go")]),t._v(" 파일을 사용하여 변환 표(finite state machine)가 초기에 작성되고 lex_table.go 파일에 작성됩니다. 일반적으로 파일에 의해 초기에 생성된 변환 표를 제거하고 시작할 때 메모리에 변환 표("),a("code",[t._v("init()")]),t._v(")를 생성할 수 있습니다. 렉시컬 분석 자체는 "),a("a",{attrs:{href:"#lex-go"}},[t._v("lex.go")]),t._v(" 파일의 lexParser 함수에서 발생합니다.")]),t._v(" "),a("h3",{attrs:{id:"lextable-lextable-go"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lextable-lextable-go"}},[t._v("#")]),t._v(" lextable/lextable.go ")]),t._v(" "),a("p",[t._v("여기에서는 작업할 알파벳을 정의하고 유한 상태 기계가 다음으로 수신한 기호에 따라 상태가 어떻게 변하는지를 설명합니다.")]),t._v(" "),a("p",[a("em",[t._v("states")]),t._v("는 상태 목록을 포함하는 JSON 객체입니다.")]),t._v(" "),a("p",[t._v("특정 기호를 제외하고 "),a("code",[t._v("d")]),t._v("는 상태에 지정되지 않은 모든 기호를 나타냅니다.\n"),a("code",[t._v("n")]),t._v("은 0x0a를 나타내며, "),a("code",[t._v("s")]),t._v("는 공백을 나타내며, "),a("code",[t._v("q")]),t._v("는 역따옴표를 나타내며, "),a("code",[t._v("Q")]),t._v("는 쌍따옴표를 나타내며, "),a("code",[t._v("r")]),t._v("은 문자 >= 128을 나타내며, "),a("code",[t._v("a")]),t._v("는 AZ와 az를 나타내며, "),a("code",[t._v("1")]),t._v("은 1-9를 나타냅니다.")]),t._v(" "),a("p",[t._v("이러한 상태의 이름은 키이며, 가능한 값은 값 객체에 나열됩니다. 그런 다음 각 그룹에 대한 전이를 수행하기 위해 새로운 상태가 있습니다. 그런 다음 토큰의 이름이 나옵니다. 초기 상태로 돌아가야 하는 경우, 세 번째 매개변수는 현재 기호를 처리하는 방법을 나타내는 서비스 토큰입니다.")]),t._v(" "),a("p",[t._v("예를 들어, main 상태와 수신된 문자 "),a("code",[t._v("/")]),t._v("가 있다면, "),a("code",[t._v('"/": ["solidus", "", "push next"]')]),t._v("입니다.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("push")]),t._v(" - 별도의 스택에 현재 상태를 기억하도록 지시합니다.")]),t._v(" "),a("li",[a("strong",[t._v("next")]),t._v(" - 다음 문자로 이동하면서 동시에 상태를 "),a("strong",[t._v("solidus")]),t._v("로 변경합니다. 그 후에 다음 문자를 가져와 "),a("strong",[t._v("solidus")]),t._v(" 상태를 확인합니다.")])]),t._v(" "),a("p",[t._v("다음 문자가 "),a("code",[t._v("/")]),t._v(" 또는 "),a("code",[t._v("/*")]),t._v("인 경우 "),a("code",[t._v("//")]),t._v(" 또는 "),a("code",[t._v("/*")]),t._v("로 시작하기 때문에 "),a("strong",[t._v("comment")]),t._v(" 상태로 이동합니다. 당연히 각 주석은 다른 상태로 종료하기 때문에 다른 기호로 끝납니다.")]),t._v(" "),a("p",[t._v("다음 문자가 "),a("code",[t._v("/")]),t._v("와 "),a("code",[t._v("*")]),t._v("이 아닌 경우, 스택에 있는 모든 것을 "),a("strong",[t._v("lexOper")]),t._v(" 유형 태그로 기록하고 스택을 지우고 main 상태로 돌아갑니다.")]),t._v(" "),a("p",[t._v("다음 모듈은 상태 트리를 숫자 배열로 변환하여 "),a("em",[t._v("lex_table.go")]),t._v(" 파일에 작성합니다.")]),t._v(" "),a("p",[t._v("첫 번째 루프에서는 유효한 기호들의 알파벳을 형성합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("for ind, ch := range alphabet {\n   i := byte(ind)\n")])])]),a("p",[t._v("또한 "),a("strong",[t._v("state2int")]),t._v("에서는 각 상태에 고유한 시퀀스 식별자를 제공합니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   state2int := map[string]uint{`main`: 0}\n   if err := json.Unmarshal([]byte(states), &data); err == nil {\n   for key := range data {\n   if key != `main` {\n   state2int[key] = uint(len(state2int))\n")])])]),a("p",[t._v("모든 상태와 상태의 각 세트 및 세트의 각 기호를 순회할 때 3바이트 숫자 [new state identifier (0 = main)] + [token type ( 0-no token)] + [token] 을 씁니다. .\n"),a("em",[t._v("table")]),t._v(" 배열의 이차원성은 "),a("em",[t._v("alphabet")]),t._v(" 배열에서 상태와 34개의 입력 기호로 나누어져 동일한 순서로 배열된다는 것입니다.\n우리는 "),a("em",[t._v("table")]),t._v("의 0행에 있는 "),a("em",[t._v("main")]),t._v(" 상태에 있습니다. 첫 번째 문자를 가져와서 "),a("em",[t._v("알파벳")]),t._v(" 배열에서 해당 인덱스를 찾고 주어진 인덱스가 있는 열에서 값을 가져옵니다. 받은 값부터 시작하여 하위 바이트의 토큰을 받습니다. 구문 분석이 완료되면 두 번째 바이트는 수신된 토큰 유형을 나타냅니다. 세 번째 바이트에서는 다음 새 상태의 인덱스를 받습니다.\n이들 모두는 "),a("em",[t._v("lex.go")]),t._v("의 "),a("strong",[t._v("lexParser")]),t._v(" 함수에 자세히 설명되어 있습니다.\n새로운 문자를 추가하려면 "),a("em",[t._v("alphabet")]),t._v(" 배열에 추가하고 "),a("em",[t._v("AlphaSize")]),t._v(" 상수의 양을 늘려야 합니다. 새로운 심볼 조합을 추가하려면 기존 옵션과 마찬가지로 상태에 설명해야 합니다. 위 작업 후 "),a("em",[t._v("lextable.go")]),t._v(" 파일을 실행하여 "),a("em",[t._v("lex_table.go")]),t._v(" 파일을 업데이트합니다.")]),t._v(" "),a("h3",{attrs:{id:"lex-go"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lex-go"}},[t._v("#")]),t._v(" lex.go ")]),t._v(" "),a("p",[a("strong",[t._v("lexParser")]),t._v(" 함수는 어휘 분석을 직접 생성하고 들어오는 문자열을 기반으로 받은 태그 배열을 반환합니다. 토큰의 구조를 분석해 보겠습니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("type Lexem struct {\n   Type  uint32 // Type of the lexem\n   Value interface{} // Value of lexem\n   Line  uint32 // Line of the lexem\n   Column uint32 // Position inside the line\n}\n")])])]),a("ul",[a("li",[a("strong",[t._v("Type")]),t._v(" - 토큰 유형입니다. 다음 값 중 하나를 가집니다: "),a("code",[t._v("lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Value")]),t._v(" - 토큰 값입니다. 값의 유형은 토큰 유형에 따라 다릅니다. 자세히 분석해보겠습니다:\n"),a("ul",[a("li",[a("strong",[t._v("lexSys")]),t._v(" - 괄호, 쉼표 등이 포함됩니다. 이 경우 "),a("code",[t._v("Type = ch << 8 | lexSys")]),t._v("로 표시되며, "),a("code",[t._v("isLPar ... isRBrack")]),t._v(" 상수를 참조하십시오. 값은 uint32 비트입니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexOper")]),t._v(" - 값은 uint32 형식으로 표시되는 동등한 문자열 시퀀스입니다. "),a("code",[t._v("isNot ... isOr")]),t._v(" 상수를 참조하십시오.")]),t._v(" "),a("li",[a("strong",[t._v("lexNumber")]),t._v(" - 숫자는 int64 또는 float64 형식으로 저장됩니다. 소수점이 있는 경우 float64로 처리됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexIdent")]),t._v(" - 식별자는 문자열로 저장됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexNewLine")]),t._v(" - 개행 문자입니다. 행 및 토큰 위치를 계산하는 데 사용됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexString")]),t._v(" - 문자열은 문자열로 저장됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexComment")]),t._v(" - 주석은 문자열로 저장됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexKeyword")]),t._v(" - 키워드의 경우 해당 인덱스만 저장됩니다. "),a("code",[t._v("keyContract ... keyTail")]),t._v(" 상수를 참조하십시오. 이 경우 "),a("code",[t._v("Type = KeyID << 8 | lexKeyword")]),t._v("입니다. 또한, "),a("code",[t._v("true, false, nil")]),t._v(" 키워드는 즉시 lexNumber 유형의 토큰으로 변환되며, 해당하는 "),a("code",[t._v("bool")]),t._v(" 및 "),a("code",[t._v("intreface{}")]),t._v(" 유형이 사용됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexType")]),t._v(" - 해당하는 "),a("code",[t._v("reflect.Type")]),t._v(" 유형 값이 포함됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexExtend")]),t._v(" - "),a("code",[t._v("$")]),t._v("로 시작하는 식별자입니다. 이러한 변수와 함수는 외부에서 전달되므로 특수 유형의 토큰에 할당됩니다. 이 값은 "),a("code",[t._v("$")]),t._v("로 시작하지 않는 이름으로 문자열로 표시됩니다.")])])]),t._v(" "),a("li",[a("strong",[t._v("Line")]),t._v(" - 토큰이 발견된 줄입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Column")]),t._v(" - 줄 내 위치입니다.")])]),t._v(" "),a("p",[a("strong",[t._v("lexParser")]),t._v(" 함수를 자세히 분석해 보겠습니다. "),a("strong",[t._v("todo")]),t._v(" 함수는 현재 상태와 들어오는 심볼을 기반으로 알파벳의 심볼 인덱스를 조회하고 변환 테이블에서 새 상태, 토큰 식별자(있는 경우) 및 기타 토큰을 가져옵니다. 구문 분석 자체에는 각각의 다음 문자에 대해 차례로 "),a("strong",[t._v("todo")]),t._v(" 함수를 호출하고 새로운 상태로 전환하는 작업이 포함됩니다. 태그가 수신되면 출력 기준에 해당 토큰을 생성하고 구문 분석 프로세스를 계속합니다. 구문 분석 프로세스 중에 토큰 시작의 오프셋만 저장하기 때문에 별도의 스택이나 배열에 토큰 기호를 누적하지 않는다는 점에 유의해야 합니다. 토큰을 얻은 후 다음 토큰의 오프셋을 현재 구문 분석 위치로 이동합니다.")]),t._v(" "),a("p",[t._v("남은 것은 구문 분석에 사용된 어휘 상태 토큰을 확인하는 것입니다.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("lexfPush")]),t._v(" - 이 토큰은 새로운 토큰에서 심볼을 누적하기 시작함을 의미합니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexfNext")]),t._v(" - 문자를 현재 토큰에 추가해야 함을 나타냅니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexfPop")]),t._v(" - 토큰 수신이 완료되었습니다. 일반적으로 이 플래그와 함께 구문 분석된 토큰의 식별자 유형이 있습니다.")]),t._v(" "),a("li",[a("strong",[t._v("lexfSkip")]),t._v(' - 이 토큰은 구문 분석에서 문자를 제외하는 데 사용됩니다. 예를 들어, 문자열에서 제어 슬래시는 \\n \\r "입니다. 이들은 구문 분석 단계에서 자동으로 대체됩니다.')])]),t._v(" "),a("h2",{attrs:{id:"needle-language"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#needle-language"}},[t._v("#")]),t._v(" Needle 언어 ")]),t._v(" "),a("h3",{attrs:{id:"lexemes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lexemes"}},[t._v("#")]),t._v(" 렉서 ")]),t._v(" "),a("p",[t._v("프로그램의 소스 코드는 UTF-8 인코딩이어야 합니다.")]),t._v(" "),a("p",[t._v("다음 어휘 유형이 처리됩니다.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Keywords")]),t._v(" - "),a("code",[t._v("action, break, conditions, continue, contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while")])]),t._v(" "),a("li",[a("strong",[t._v("Number")]),t._v(" - 정수와 소수점 숫자만 허용됩니다. 기본적으로 두 가지 유형이 있습니다: "),a("strong",[t._v("int")]),t._v("와 "),a("strong",[t._v("float")]),t._v(". 소수점이 있는 숫자는 "),a("strong",[t._v("float")]),t._v(" 유형이 됩니다. "),a("strong",[t._v("int")]),t._v(" 유형은 golang의 "),a("strong",[t._v("int64")]),t._v("에 해당하며, "),a("strong",[t._v("float")]),t._v(" 유형은 golang의 "),a("strong",[t._v("float64")]),t._v("에 해당합니다.")]),t._v(" "),a("li",[a("strong",[t._v("String")]),t._v(" - 문자열은 이중 따옴표 "),a("code",[t._v('("a string")')]),t._v(" 또는 백틱 "),a("code",[t._v("(`a string`)")]),t._v("으로 묶일 수 있습니다. 두 유형의 문자열 모두 개행 문자를 포함할 수 있습니다. 이중 따옴표로 묶인 문자열은 따옴표, 개행 문자 및 슬래시로 이스케이프된 캐리지 리턴을 포함할 수 있습니다. 예를 들어, "),a("code",[t._v('"This is a \\"first string\\".\\r\\nThis is a second string."')]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Comment")]),t._v(" - 두 가지 유형의 주석이 있습니다. 한 줄 주석은 두 개의 슬래시 (//)를 사용합니다. 예를 들어, // 이것은 한 줄 주석입니다. 여러 줄 주석은 슬래시와 별표 기호를 사용하며 여러 줄에 걸칠 수 있습니다. 예를 들어, "),a("code",[t._v("/* 이것은 여러 줄 주석입니다 */")]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("Identifier")]),t._v(" - 변수와 함수의 이름은 a-z 및 A-Z 문자, UTF-8 기호, 숫자 및 밑줄로 구성됩니다. 이름은 문자, 밑줄, "),a("code",[t._v("@")]),t._v(" 또는 "),a("code",[t._v("$")]),t._v("로 시작할 수 있습니다. "),a("code",[t._v("$")]),t._v("로 시작하는 이름은 "),a("strong",[t._v("data section")]),t._v("에서 정의된 변수의 이름입니다. "),a("code",[t._v("$")]),t._v("로 시작하는 이름은 "),a("strong",[t._v("conditions")]),t._v(" 및 "),a("strong",[t._v("action sections")]),t._v("의 범위 내에서 전역 변수를 정의하는 데에도 사용될 수 있습니다. 생태계 계약은 "),a("code",[t._v("@")]),t._v(" 기호를 사용하여 호출할 수 있습니다. 예를 들어: "),a("code",[t._v("@1NewTable(...)")]),t._v("입니다.")])]),t._v(" "),a("h3",{attrs:{id:"types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#types"}},[t._v("#")]),t._v(" 타입 ")]),t._v(" "),a("p",[t._v("다음은 Needle 유형에 해당하는 golang 유형이 지정된 부분입니다.")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("bool")]),t._v(" - bool, 기본값은 "),a("strong",[t._v("false")]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("bytes")]),t._v(" - []byte{}, 기본값은 빈 바이트 배열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("int")]),t._v(" - int64, 기본값은 "),a("strong",[t._v("0")]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("address")]),t._v(" - uint64, 기본값은 "),a("strong",[t._v("0")]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("array")]),t._v(" - []interface{}, 기본값은 빈 배열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("map")]),t._v(" - map[string]interface{}, 기본값은 빈 객체 배열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("money")]),t._v(" - decimal. Decimal, 기본값은 "),a("strong",[t._v("0")]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("float")]),t._v(" - float64, 기본값은 "),a("strong",[t._v("0")]),t._v("입니다.")]),t._v(" "),a("li",[a("strong",[t._v("string")]),t._v(" - string, 기본값은 빈 문자열입니다.")]),t._v(" "),a("li",[a("strong",[t._v("file")]),t._v(" - map[string]interface{}, 기본값은 빈 객체 배열입니다.")])]),t._v(" "),a("p",[t._v("이러한 유형의 변수는 "),a("code",[t._v("var")]),t._v(" 키워드로 정의됩니다. 예를 들어, "),a("code",[t._v("var var1, var2 int")]),t._v("입니다. 이렇게 정의되면 변수는 유형별로 기본값이 할당됩니다.")]),t._v(" "),a("p",[t._v("모든 변수 값은 interface{} 유형이며, 그런 다음 필요한 golang 유형에 할당됩니다. 따라서 예를 들어, 배열 및 맵 유형은 golang의 []interface{} 및 map[string]interface{} 유형입니다. 두 유형의 배열은 모든 유형의 요소를 포함할 수 있습니다.")]),t._v(" "),a("h3",{attrs:{id:"expressions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expressions"}},[t._v("#")]),t._v(" 표현식 ")]),t._v(" "),a("p",[t._v("식에는 산술 연산, 논리 연산 및 함수 호출이 포함될 수 있습니다. 모든 식은 연산자 우선 순위에 따라 왼쪽에서 오른쪽으로 평가됩니다. 우선 순위가 같은 경우 연산자는 왼쪽에서 오른쪽으로 평가됩니다.")]),t._v(" "),a("p",[t._v("높은 작업에서 낮은 작업 우선순위:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Function call and parentheses")]),t._v(" - 함수 호출 시 전달된 매개변수는 왼쪽에서 오른쪽으로 계산됩니다.")]),t._v(" "),a("li",[a("strong",[t._v("Unary Operation")]),t._v(" - 논리 부정 "),a("code",[t._v("!")]),t._v(" 및 산술 부호 변경 "),a("code",[t._v("-")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Multiplication and Division")]),t._v(" - 산술 곱셈 "),a("code",[t._v("*")]),t._v(" 및 나눗셈 "),a("code",[t._v("/")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Addition and Subtraction")]),t._v(" - 산술 덧셈 "),a("code",[t._v("+")]),t._v(" 및 뺄셈 "),a("code",[t._v("-")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Logical comparison")]),t._v(" - "),a("code",[t._v(">=>> >=")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Logical equality and inequality")]),t._v(" - "),a("code",[t._v("== !=")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Logical AND")]),t._v(" - "),a("code",[t._v("&&")]),t._v(".")]),t._v(" "),a("li",[a("strong",[t._v("Logical OR")]),t._v(" - "),a("code",[t._v("||")]),t._v(".")])]),t._v(" "),a("p",[t._v("논리 AND 및 OR을 평가할 때, 표현식의 양쪽 모두 평가됩니다.")]),t._v(" "),a("p",[t._v("Needle은 컴파일 중에 타입 체크를 수행하지 않습니다. 피연산자를 평가할 때, 타입을 더 복잡한 타입으로 변환하려고 시도합니다. 복잡도 순서에 따른 타입의 복잡성은 다음과 같을 수 있습니다: "),a("code",[t._v("string, int, float, money")]),t._v(". 타입 변환의 일부만 구현되어 있습니다. 문자열 타입은 덧셈 연산을 지원하며, 결과는 문자열 연결이 됩니다. 예를 들어, "),a("code",[t._v("string + string = string, money-int = money, int * float = float")]),t._v("입니다.")]),t._v(" "),a("p",[t._v("함수에 대해서는 실행 중에 "),a("code",[t._v("string")]),t._v("과 "),a("code",[t._v("int")]),t._v(" 타입에 대한 타입 체크가 수행됩니다.")]),t._v(" "),a("p",[a("strong",[t._v("array")]),t._v(" 및 "),a("strong",[t._v("map")]),t._v(" 타입은 인덱스를 통해 접근할 수 있습니다. "),a("strong",[t._v("array")]),t._v(" 타입의 경우, 인덱스로 "),a("strong",[t._v("int")]),t._v(" 값을 지정해야 합니다. "),a("strong",[t._v("map")]),t._v(" 타입의 경우, 변수 또는 "),a("strong",[t._v("string")]),t._v(" 값을 지정해야 합니다. 현재 최대 인덱스보다 큰 인덱스를 갖는 "),a("strong",[t._v("array")]),t._v(" 요소에 값을 할당하면, 배열에 빈 요소가 추가됩니다. 이러한 요소들의 초기값은 "),a("strong",[t._v("nil")]),t._v("입니다. 예를 들어: .. code:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('var my array\nmy[5] = 0\nvar mymap map\nmymap["index"] = my[3]\n')])])]),a("p",[t._v("조건부 논리 값(예: "),a("code",[t._v("if, while, &&, ||, !")]),t._v(")의 식에서 유형은 자동으로 논리 값으로 변환됩니다. 유형이 기본값이 아니면 true입니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var mymap map\nvar val string\nif mymap && val {\n...\n}\n")])])]),a("h3",{attrs:{id:"scope"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scope"}},[t._v("#")]),t._v(" 스코프 ")]),t._v(" "),a("p",[t._v("중괄호는 로컬 범위 변수를 포함할 수 있는 블록을 지정합니다. 기본적으로 변수의 범위는 자체 블록과 모든 중첩 블록으로 확장됩니다. 블록에서 기존 변수의 이름을 사용하여 새 변수를 정의할 수 있습니다. 그러나 이 경우 같은 이름의 외부 변수는 사용할 수 없게 됩니다.")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var a int\na = 3\n{\n   var a int\n   a = 4\n   Println(a) // 4\n}\nPrintln(a) // 3\n")])])]),a("h3",{attrs:{id:"contract-execution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contract-execution"}},[t._v("#")]),t._v(" 계약 실행 ")]),t._v(" "),a("p",[t._v("계약을 호출할 때에는 "),a("strong",[t._v("data")]),t._v("에 정의된 매개변수를 전달해야 합니다. 계약을 실행하기 전에 가상 머신은 이러한 매개변수를 받아서 해당 변수($Param)에 할당합니다. 그런 다음, 미리 정의된 "),a("strong",[t._v("conditions")]),t._v(" 함수와 "),a("strong",[t._v("action")]),t._v(" 함수를 호출합니다.")]),t._v(" "),a("p",[t._v("계약 실행 중 발생하는 오류는 양식 오류와 환경 오류로 구분할 수 있습니다. 양식 오류는 "),a("code",[t._v("error, warning, info")]),t._v("와 같은 특수한 명령을 사용하여 생성되며, 내장 함수가 "),a("code",[t._v("err")]),t._v("을 "),a("em",[t._v("nil")]),t._v(" 이 아닌 값으로 반환할 때 발생합니다.")]),t._v(" "),a("p",[t._v("Needle 언어는 예외 처리를 다루지 않습니다. 어떤 오류든 계약의 실행을 종료시킵니다. 계약을 실행할 때 별도의 스택과 변수 값 저장을 위한 구조가 생성되기 때문에, golang의 가비지 컬렉션 메커니즘은 계약 실행이 완료될 때 이러한 데이터를 자동으로 삭제합니다.")]),t._v(" "),a("h3",{attrs:{id:"backus-naur-form-bnf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backus-naur-form-bnf"}},[t._v("#")]),t._v(" Backus-Naur Form (BNF) ")]),t._v(" "),a("p",[t._v("컴퓨터 과학에서 BNF는 문맥 없는 구문에 대한 표기법이며 일반적으로 컴퓨팅에서 사용되는 언어의 구문을 설명하는 데 사용됩니다.")]),t._v(" "),a("ul",[a("li",[t._v("<decimal digit>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n")])])]),a("ul",[a("li",[t._v("<decimal number>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<decimal digit> {<decimal digit>}\n")])])]),a("ul",[a("li",[t._v("<symbol code>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'''<any symbol>'''\n")])])]),a("ul",[a("li",[t._v("<real number>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("['-'] <decimal number'.'[<decimal number>]\n")])])]),a("ul",[a("li",[t._v("<integer number>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("['-'] <decimal number> | <symbol code>\n")])])]),a("ul",[a("li",[t._v("<number>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'<integer number> | <real number>'\n")])])]),a("ul",[a("li",[t._v("<letter>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF\n")])])]),a("ul",[a("li",[t._v("<space>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'0x20'\n")])])]),a("ul",[a("li",[t._v("<tabulation>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'0x09'\n")])])]),a("ul",[a("li",[t._v("<newline>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'0x0D 0x0A'\n")])])]),a("ul",[a("li",[t._v("<special symbol>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'!' |'\"' |'$' |''' |'(' |')' |'\\*' |'+' |',' |'-' |'.' |'/ '|'<' |'=' |'>' |'[' |'\\\\' |']' |'_' |'|' |'}' | '{' | <tabulation> | <space> | <newline>\n")])])]),a("ul",[a("li",[t._v("<symbol>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<decimal digit> | <letter> | <special symbol>\n")])])]),a("ul",[a("li",[t._v("<name>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(<letter> |'_') {<letter> |'_' | <decimal digit>}\n")])])]),a("ul",[a("li",[t._v("<function name>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<name>\n")])])]),a("ul",[a("li",[t._v("<variable name>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<name>\n")])])]),a("ul",[a("li",[t._v("<type name>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<name>\n")])])]),a("ul",[a("li",[t._v("<string symbol>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<tabulation> | <space> |'!' |'#' | ... |'[' |']' | ...\n")])])]),a("ul",[a("li",[t._v("<string element>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("{<string symbol> |'\\\"' |'\\n' |'\\r'}\n")])])]),a("ul",[a("li",[t._v("<string>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'\"' {<string element>}'\"' |'\\`' {<string element>}'\\`'\n")])])]),a("ul",[a("li",[t._v("<assignment operator>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'='\n")])])]),a("ul",[a("li",[t._v("<unary operator>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'-'\n")])])]),a("ul",[a("li",[t._v("<binary operator>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'==' |'!=' |'>' |'<' |'<=' |'>=' |'&&' |'||' |'\\*' |'/' |'+ '|'-'\n")])])]),a("ul",[a("li",[t._v("<operator>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<assignment operator> | <unary operator> | <binary operator>\n")])])]),a("ul",[a("li",[t._v("<parameters>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<expression> {','<expression>}\n")])])]),a("ul",[a("li",[t._v("<contract call>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<contract name>'(' [<parameters>]')'\n")])])]),a("ul",[a("li",[t._v("<function call>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<contract call> [{'.' <name>'(' [<parameters>]')'}]\n")])])]),a("ul",[a("li",[t._v("<block contents>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<block command> {<newline><block command>}\n")])])]),a("ul",[a("li",[t._v("<block>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'{'<block contents>'}'\n")])])]),a("ul",[a("li",[t._v("<block command>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(<block> | <expression> | <variables definition> | <if> | <while> | break | continue | return)\n")])])]),a("ul",[a("li",[t._v("<if>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'if <expression><block> [else <block>]'\n")])])]),a("ul",[a("li",[t._v("<while>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'while <expression><block>'\n")])])]),a("ul",[a("li",[t._v("<contract>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'contract <name> '{'[<data section>] {<function>} [<conditions>] [<action>]'}''\n")])])]),a("ul",[a("li",[t._v("<data section>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'data '{' {<data parameter><newline>} '}''\n")])])]),a("ul",[a("li",[t._v("<data parameter>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<variable name> <type name>'\"'{<tag>}'\"'\n")])])]),a("ul",[a("li",[t._v("<tag>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'optional | image | file | hidden | text | polymap | map | address | signature:<name>'\n")])])]),a("ul",[a("li",[t._v("<conditions>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'conditions <block>'\n")])])]),a("ul",[a("li",[t._v("<action>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'action <block>'\n")])])]),a("ul",[a("li",[t._v("<function>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'func <function name>'('[<variable description>{','<variable description>}]')'[{<tail>}] [<type name>] <block>'\n")])])]),a("ul",[a("li",[t._v("<variable description>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<variable name> {',' <variable name>} <type name>\n")])])]),a("ul",[a("li",[t._v("<tail>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'.'<function name>'('[<variable description>{','<variable description>}]')'\n")])])]),a("ul",[a("li",[t._v("<variables definition>")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("'var <variable description>{','<variable description>}'\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);