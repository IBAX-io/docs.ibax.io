(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{408:function(e,n,t){"use strict";t.r(n);var r=t(51),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"compiler-und-virtuelle-maschine"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compiler-und-virtuelle-maschine"}},[e._v("#")]),e._v(" Compiler und virtuelle Maschine")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#source-code-storage-and-compilation"}},[e._v("Speicherung und Kompilierung des Quellcodes")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#virtual-machine-structures"}},[e._v("Strukturen virtueller Maschinen")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#vm-Struktur"}},[e._v("VM-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Blockstruktur"}},[e._v("Blockstruktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#objinfo-Struktur"}},[e._v("ObjInfo-Struktur")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#contractinfo-Struktur"}},[e._v("ContractInfo-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#fieldinfo-Struktur"}},[e._v("FieldInfo-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#funcinfo-Struktur"}},[e._v("FuncInfo-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Funktionsname-Struktur"}},[e._v("Funktionsname-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#extfuncinfo-Struktur"}},[e._v("ExtFuncInfo-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#varinfo-Struktur"}},[e._v("VarInfo-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#objextend-Wert"}},[e._v("ObjExtend-Wert")])])])])])]),e._v(" "),t("li",[t("a",{attrs:{href:"#virtual-machine-commands"}},[e._v("Befehle für virtuelle Maschinen")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#Bytecode-Struktur"}},[e._v("ByteCode-Struktur")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Befehlskennungen"}},[e._v("Befehlskennungen")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#stack-operation-commands"}},[e._v("Befehle für Stapeloperationen")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#runtime-structure"}},[e._v("Laufzeitstruktur")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#blockstack-Struktur"}},[e._v("blockStack-Struktur")])])])]),e._v(" "),t("li",[e._v("[RunCode-Funktion] (#runcode-Funktion)")]),e._v(" "),t("li",[t("a",{attrs:{href:"#other-functions-for-operations-with-vm"}},[e._v("Andere Funktionen für Operationen mit VM")])])])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Compiler"}},[e._v("Compiler")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#lexical-analyzer"}},[e._v("Lexikalanalyse")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#lextable-lextable-go"}},[e._v("lextable/lextable.go")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#lex-go"}},[e._v("lex.go")])])])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Nadelsprache"}},[e._v("Nadelsprache")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#lexeme"}},[e._v("Lexeme")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Typen"}},[e._v("Typen")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Ausdr%C3%BCcke"}},[e._v("Ausdrücke")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Bereich"}},[e._v("Bereich")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Vertragsausf%C3%BChrung"}},[e._v("Vertragsausführung")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#backus-naur-Form-bnf"}},[e._v("Backus-Naur-Form (BNF)")])])])])]),e._v(" "),t("p",[e._v("Dieser Abschnitt umfasst Programmkompilierung und Needle-Language-Operationen in der virtuellen Maschine (VM).")]),e._v(" "),t("h2",{attrs:{id:"speicherung-und-kompilierung-des-quellcodes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#speicherung-und-kompilierung-des-quellcodes"}},[e._v("#")]),e._v(" Speicherung und Kompilierung des Quellcodes")]),e._v(" "),t("p",[e._v("Verträge und Funktionen werden mit Golang geschrieben und in den Vertragstabellen von Ökosystemen gespeichert.")]),e._v(" "),t("p",[e._v("Wenn ein Vertrag ausgeführt wird, wird sein Quellcode aus der Datenbank gelesen und in Bytecode kompiliert.")]),e._v(" "),t("p",[e._v("Wenn ein Vertrag geändert wird, wird sein Quellcode aktualisiert und in der Datenbank gespeichert. Dann wird der Quellcode kompiliert, wodurch der Bytecode in der entsprechenden virtuellen Maschine aktualisiert wird.")]),e._v(" "),t("p",[e._v("Da Bytecodes nicht physikalisch gespeichert werden, werden sie bei einer erneuten Programmausführung neu kompiliert.")]),e._v(" "),t("p",[e._v("Der gesamte in der Vertragstabelle jedes Ökosystems beschriebene Quellcode wird in einer strengen Reihenfolge in eine virtuelle Maschine kompiliert, und der Status der virtuellen Maschine ist auf allen Knoten gleich.")]),e._v(" "),t("p",[e._v("Beim Vertragsaufruf ändert die virtuelle Maschine ihren Status in keiner Weise. Die Ausführung eines Vertrages oder das Aufrufen einer Funktion erfolgt auf einem separaten laufenden Stack, der während jedes externen Aufrufs erstellt wird.")]),e._v(" "),t("p",[e._v("Jedes Ökosystem kann ein sogenanntes virtuelles Ökosystem haben, das innerhalb eines Knotens in Verbindung mit Tabellen außerhalb der Blockchain verwendet werden kann, ohne direkten Einfluss auf die Blockchain oder andere virtuelle Ökosysteme. In diesem Fall erstellt der Knoten, der ein solches virtuelles Ökosystem hostet, seinen Vertrag und erstellt seine eigene virtuelle Maschine.")]),e._v(" "),t("h2",{attrs:{id:"strukturen-virtueller-maschinen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#strukturen-virtueller-maschinen"}},[e._v("#")]),e._v(" Strukturen virtueller Maschinen")]),e._v(" "),t("h3",{attrs:{id:"vm-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vm-struktur"}},[e._v("#")]),e._v(" VM-Struktur")]),e._v(" "),t("p",[e._v("Eine virtuelle Maschine ist im Arbeitsspeicher als Struktur wie unten organisiert.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type VM struct {\n   Block\n   ExtCost func(string) int64\n   FuncCallsDB map[string]struct{}\n   Extern bool\n   ShiftContract int64\n   logger *log.Entry\n}\n")])])]),t("p",[e._v("Eine VM-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[e._v("Block - enthält eine [Blockstruktur] (#block-structure);")]),e._v(" "),t("li",[e._v("ExtCost - eine Funktion gibt die Kosten für die Ausführung einer externen Golang-Funktion zurück;")]),e._v(" "),t("li",[e._v("FuncCallsDB - eine Sammlung von Golang-Funktionsnamen. Diese Funktion gibt die Ausführungskosten als ersten Parameter zurück. Diese Funktionen verwenden EXPLAIN, um die Kosten der Datenbankverarbeitung zu berechnen;")]),e._v(" "),t("li",[e._v("Extern – ein Boolesches Flag, das angibt, ob ein Vertrag ein externer Vertrag ist. Es wird auf „true“ gesetzt, wenn eine VM erstellt wird. Aufgerufene Verträge werden beim Kompilieren des Codes nicht angezeigt. Mit anderen Worten, es ermöglicht, den in Zukunft festgelegten Vertragscode aufzurufen;")]),e._v(" "),t("li",[e._v("Schichtvertrag – ID des ersten Vertrags in der VM;")]),e._v(" "),t("li",[e._v("logger - Ausgabe des VM-Fehlerprotokolls.")])]),e._v(" "),t("h3",{attrs:{id:"blockstruktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blockstruktur"}},[e._v("#")]),e._v(" Blockstruktur")]),e._v(" "),t("p",[e._v("Eine virtuelle Maschine ist ein Baum, der aus "),t("strong",[e._v("Blocktyp")]),e._v("-Objekten besteht.")]),e._v(" "),t("p",[e._v("Ein Block ist eine unabhängige Einheit, die einige Bytecodes enthält. Einfach ausgedrückt ist alles, was Sie in der Sprache in die geschweiften Klammern ("),t("code",[e._v("{}")]),e._v(") setzen, ein Block.")]),e._v(" "),t("p",[e._v("Der folgende Code würde beispielsweise einen Block mit Funktionen erstellen. Dieser Block enthält auch einen weiteren Block mit einer if-Anweisung, der wiederum einen Block mit einer while-Anweisung enthält.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func my() {\n   if true {\n      while false {\n      ...\n      }\n   }\n}\n")])])]),t("p",[e._v("Der Block ist im Speicher als Struktur wie unten organisiert.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type Block struct {\n   Objects map[string]*ObjInfo\n   Type int\n   Owner *OwnerInfo\n   Info interface{}\n   Parent *Block\n   Vars []reflect.Type\n   Code ByteCodes\n   Children Blocks\n}\n")])])]),t("p",[e._v("Eine Blockstruktur besteht aus folgenden Elementen:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Objekte")]),e._v(" - eine Abbildung interner Objekte des Zeigertyps "),t("a",{attrs:{href:"#objInfo-Struktur"}},[e._v("ObjInfo")]),e._v(". Wenn der Block beispielsweise eine Variable enthält, können Sie anhand ihres Namens Informationen darüber erhalten.")]),e._v(" "),t("li",[t("strong",[e._v("Typ")]),e._v(" - der Typ des Blocks. Bei einem Funktionsblock ist sein Typ "),t("strong",[e._v("ObjFunc")]),e._v("; für einen Vertragsblock ist sein Typ "),t("strong",[e._v("ObjContract")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("Eigentümer")]),e._v(" – eine Struktur vom Zeigertyp "),t("strong",[e._v("Eigentümerinfo")]),e._v(". Diese Struktur enthält Informationen über den Eigentümer des kompilierten Vertrags, der während der Vertragserstellung angegeben oder aus der Tabelle "),t("strong",[e._v("Verträge")]),e._v(" erhalten wird;")]),e._v(" "),t("li",[t("strong",[e._v("Info")]),e._v(" - enthält Informationen über das Objekt, die vom Blocktyp abhängen;")]),e._v(" "),t("li",[t("strong",[e._v("Parent")]),e._v(" – ein Zeiger auf den Elternblock;")]),e._v(" "),t("li",[t("strong",[e._v("Vars")]),e._v(" - ein Array, das die Typen der aktuellen Blockvariablen enthält;")]),e._v(" "),t("li",[t("strong",[e._v("Code")]),e._v(" - der Bytecode des Blocks selbst, der ausgeführt wird, wenn die Kontrollrechte an den Block übergeben werden, zum Beispiel Funktionsaufrufe oder Schleifenkörper;")]),e._v(" "),t("li",[t("strong",[e._v("Children")]),e._v(" - ein Array mit Unterblöcken, wie z. B. Funktionsverschachtelung, Schleifen, bedingte Operatoren.")])]),e._v(" "),t("h3",{attrs:{id:"objinfo-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#objinfo-struktur"}},[e._v("#")]),e._v(" ObjInfo-Struktur")]),e._v(" "),t("p",[e._v("Die ObjInfo-Struktur enthält Informationen über interne Objekte.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type ObjInfo struct {\n   Type int\n   Value interface{}\n}\n")])])]),t("p",[e._v("Die ObjInfo-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Typ")]),e._v(" ist der Objekttyp, der einen der folgenden Werte hat:\n"),t("ul",[t("li",[t("strong",[e._v("ObjContract")]),e._v(" – "),t("a",{attrs:{href:"#contractInfo-Struktur"}},[e._v("Vertrag")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("ObjFunc")]),e._v(" - Funktion;")]),e._v(" "),t("li",[t("strong",[e._v("ObjExtFunc")]),e._v(" - externe Golang-Funktion;")]),e._v(" "),t("li",[t("strong",[e._v("ObjVar")]),e._v(" - Variable;")]),e._v(" "),t("li",[t("strong",[e._v("ObjExtend")]),e._v(" - $name-Variable.")])])]),e._v(" "),t("li",[t("strong",[e._v("Wert")]),e._v(" – enthält die Struktur jedes Typs.")])]),e._v(" "),t("h4",{attrs:{id:"contractinfo-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#contractinfo-struktur"}},[e._v("#")]),e._v(" ContractInfo-Struktur")]),e._v(" "),t("p",[e._v("Zeigt auf den Typ "),t("strong",[e._v("ObjContract")]),e._v(", und das Feld "),t("strong",[e._v("Value")]),e._v(" enthält eine "),t("strong",[e._v("ContractInfo")]),e._v("-Struktur.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type ContractInfo struct {\n   ID uint32\n   Name string\n   Owner *OwnerInfo\n   Used map[string]bool\n   Tx *[]*FieldInfo\n}\n")])])]),t("p",[e._v("Die ContractInfo-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("ID")]),e._v(" - Vertrags-ID, die beim Aufruf des Vertrags in der Blockchain angezeigt wird;")]),e._v(" "),t("li",[t("strong",[e._v("Name")]),e._v(" - Vertragsname;")]),e._v(" "),t("li",[t("strong",[e._v("Eigentümer")]),e._v(" - andere Informationen zum Vertrag;")]),e._v(" "),t("li",[t("strong",[e._v("Verwendet")]),e._v(" - Karte der aufgerufenen Vertragsnamen;")]),e._v(" "),t("li",[t("strong",[e._v("Tx")]),e._v(" – ein Datenarray, das im "),t("RouterLink",{attrs:{to:"/de/topics/script.html#data-section"}},[e._v("Datenabschnitt")]),e._v(" des Vertrags beschrieben wird.")],1)]),e._v(" "),t("h4",{attrs:{id:"fieldinfo-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fieldinfo-struktur"}},[e._v("#")]),e._v(" FieldInfo-Struktur")]),e._v(" "),t("p",[e._v("Die FieldInfo-Struktur wird in der "),t("strong",[e._v("ContractInfo")]),e._v("-Struktur verwendet und beschreibt Elemente im "),t("RouterLink",{attrs:{to:"/de/topics/script.html#data-section"}},[e._v("Datenabschnitt")]),e._v(" eines Vertrags.")],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type FieldInfo struct {\n   Name string\n   Type reflect.Type\n   Original uint32\n   Tags string\n}\n")])])]),t("p",[e._v("Die FieldInfo-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Name")]),e._v(" - Feldname;")]),e._v(" "),t("li",[t("strong",[e._v("Typ")]),e._v(" - Feldtyp;")]),e._v(" "),t("li",[t("strong",[e._v("Original")]),e._v(" - optionales Feld;")]),e._v(" "),t("li",[t("strong",[e._v("Tags")]),e._v(" - zusätzliche Beschriftungen für dieses Feld.")])]),e._v(" "),t("h4",{attrs:{id:"funcinfo-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#funcinfo-struktur"}},[e._v("#")]),e._v(" FuncInfo-Struktur")]),e._v(" "),t("p",[e._v("Zeigt auf den ObjFunc-Typ, und das Value-Feld enthält eine FuncInfo-Struktur.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type FuncInfo struct {\n   Params []reflect.Type\n   Results []reflect.Type\n   Names *map[string]FuncName\n   Variadic bool\n   ID uint32\n}\n")])])]),t("p",[e._v("Die FuncInfo-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Params")]),e._v(" - ein Array von Parametertypen;")]),e._v(" "),t("li",[t("strong",[e._v("Ergebnisse")]),e._v(" - ein Array zurückgegebener Typen;")]),e._v(" "),t("li",[t("strong",[e._v("Namen")]),e._v(" - Abbildung von Daten für Tail-Funktionen, zum Beispiel "),t("code",[e._v("DBFind().Columns ()")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("Variadic")]),e._v(" - wahr, wenn die Funktion eine variable Anzahl von Parametern haben kann;")]),e._v(" "),t("li",[t("strong",[e._v("ID")]),e._v(" - Funktions-ID.")])]),e._v(" "),t("h4",{attrs:{id:"funcname-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#funcname-struktur"}},[e._v("#")]),e._v(" FuncName-Struktur")]),e._v(" "),t("p",[e._v("Die Struktur FuncName wird für FuncInfo verwendet und beschreibt die Daten einer Tail-Funktion.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type FuncName struct {\n   Params []reflect.Type\n   Offset []int\n   Variadic bool\n}\n")])])]),t("p",[e._v("Die FuncName-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Params")]),e._v(" - ein Array von Parametertypen;")]),e._v(" "),t("li",[t("strong",[e._v("Offset")]),e._v(" - das Array von Offsets für diese Variablen. Tatsächlich können die Werte aller Parameter in einer Funktion mit dem Punkt . initialisiert werden;")]),e._v(" "),t("li",[t("strong",[e._v("Variadic")]),e._v(" - true, wenn die Tail-Funktion eine variable Anzahl von Parametern haben kann.")])]),e._v(" "),t("h4",{attrs:{id:"extfuncinfo-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extfuncinfo-struktur"}},[e._v("#")]),e._v(" ExtFuncInfo-Struktur")]),e._v(" "),t("p",[e._v("Zeigt auf den ObjExtFunc-Typ, und das Value-Feld enthält eine ExtFuncInfo-Struktur. Es wird verwendet, um Golang-Funktionen zu beschreiben.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type ExtFuncInfo struct {\n   Name string\n   Params []reflect.Type\n   Results []reflect.Type\n   Auto []string\n   Variadic bool\n   Func interface{}\n}\n")])])]),t("p",[e._v("Die ExtFuncInfo-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[e._v("Die Parameter "),t("strong",[e._v("Name")]),e._v(", "),t("strong",[e._v("Params")]),e._v(", "),t("strong",[e._v("Results")]),e._v(" haben die gleiche Struktur wie "),t("a",{attrs:{href:"#funcinfo-structure"}},[e._v("FuncInfo")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("Auto")]),e._v(" - ein Array von Variablen. Wird gegebenenfalls als zusätzlicher Parameter an die Funktion übergeben. Beispielsweise eine Variable vom Typ SmartContract sc;")]),e._v(" "),t("li",[t("strong",[e._v("Func")]),e._v(" - Golang-Funktionen.")])]),e._v(" "),t("h4",{attrs:{id:"varinfo-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#varinfo-struktur"}},[e._v("#")]),e._v(" VarInfo-Struktur")]),e._v(" "),t("p",[e._v("Zeigt auf den Typ "),t("strong",[e._v("ObjVar")]),e._v(", und das Feld "),t("strong",[e._v("Value")]),e._v(" enthält eine "),t("strong",[e._v("VarInfo")]),e._v("-Struktur.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type VarInfo struct {\n   Obj *ObjInfo\n   Owner *Block\n}\n")])])]),t("p",[e._v("Die VarInfo-Struktur hat die folgenden Elemente:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Obj")]),e._v(" - Informationen über Typ und Wert der Variablen;")]),e._v(" "),t("li",[t("strong",[e._v("Eigentümer")]),e._v(" - Zeiger auf den Eigentümerblock.")])]),e._v(" "),t("h4",{attrs:{id:"objextend-wert"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#objextend-wert"}},[e._v("#")]),e._v(" ObjExtend-Wert")]),e._v(" "),t("p",[e._v("Zeigt auf den Typ "),t("strong",[e._v("ObjExtend")]),e._v(", und das Feld "),t("strong",[e._v("Value")]),e._v(" enthält eine Zeichenfolge, die den Namen der Variablen oder Funktion enthält.")]),e._v(" "),t("h2",{attrs:{id:"befehle-fur-virtuelle-maschinen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#befehle-fur-virtuelle-maschinen"}},[e._v("#")]),e._v(" Befehle für virtuelle Maschinen")]),e._v(" "),t("h3",{attrs:{id:"bytecode-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bytecode-struktur"}},[e._v("#")]),e._v(" ByteCode-Struktur")]),e._v(" "),t("p",[e._v("Ein Bytecode ist eine Folge von Strukturen vom Typ "),t("strong",[e._v("ByteCode")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type ByteCode struct {\n   Cmd uint16\n   Value interface{}\n}\n")])])]),t("p",[e._v("Diese Struktur hat die folgenden Felder:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Cmd")]),e._v(" - der Bezeichner der Speicherbefehle;")]),e._v(" "),t("li",[t("strong",[e._v("Wert")]),e._v(" - enthält den Operanden (Wert).")])]),e._v(" "),t("p",[e._v("Im Allgemeinen führen Befehle eine Operation auf dem obersten Element des Stapels aus und schreiben bei Bedarf den Ergebniswert hinein.")]),e._v(" "),t("h3",{attrs:{id:"befehlskennungen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#befehlskennungen"}},[e._v("#")]),e._v(" Befehlskennungen")]),e._v(" "),t("p",[e._v("Bezeichner der Befehle der virtuellen Maschine sind in der Datei vm/cmds_list.go beschrieben.")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("cmdPush")]),e._v(" – legt einen Wert aus dem Value-Feld auf den Stack. Legen Sie zum Beispiel Zahlen und Linien auf den Stapel;")]),e._v(" "),t("li",[t("strong",[e._v("cmdVar")]),e._v(" - Legt den Wert einer Variablen auf den Stack. Value enthält einen Zeiger auf die VarInfo-Struktur und Informationen über die Variable;")]),e._v(" "),t("li",[t("strong",[e._v("cmdExtend")]),e._v(" – legt den Wert einer externen Variablen auf den Stack. Wert enthält eine Zeichenfolge mit dem Variablennamen (beginnend mit $);")]),e._v(" "),t("li",[t("strong",[e._v("cmdCallExtend")]),e._v(" – Aufruf einer externen Funktion (beginnend mit $). Die Parameter der Funktion werden aus dem Stapel abgerufen und die Ergebnisse auf dem Stapel abgelegt. Wert enthält einen Funktionsnamen (beginnend mit $);")]),e._v(" "),t("li",[t("strong",[e._v("cmdPushStr")]),e._v(" – legt den String in Value auf den Stack;")]),e._v(" "),t("li",[t("strong",[e._v("cmdCall")]),e._v(" - ruft die Funktion der virtuellen Maschine auf. Wert enthält eine "),t("strong",[e._v("ObjInfo")]),e._v("-Struktur. Dieser Befehl gilt für die Golang-Funktion "),t("strong",[e._v("ObjExtFunc")]),e._v(" und die Needle-Funktion "),t("strong",[e._v("ObjFunc")]),e._v(". Wenn eine Funktion aufgerufen wird, werden ihre Parameter vom Stapel abgerufen und die Ergebniswerte werden auf dem Stapel abgelegt;")]),e._v(" "),t("li",[t("strong",[e._v("cmdCallVari")]),e._v(" - Ähnlich wie der Befehl "),t("strong",[e._v("cmdCall")]),e._v(" ruft er die Funktion der virtuellen Maschine auf. Dieser Befehl wird verwendet, um eine Funktion mit einer variablen Anzahl von Parametern aufzurufen;")]),e._v(" "),t("li",[t("strong",[e._v("cmdReturn")]),e._v(" - wird verwendet, um die Funktion zu verlassen. Die Rückgabewerte werden auf den Stack gelegt und das Value-Feld wird nicht verwendet;")]),e._v(" "),t("li",[t("strong",[e._v("cmdIf")]),e._v(" – übergibt die Kontrolle an den Bytecode in der Struktur "),t("strong",[e._v("block")]),e._v(", der im Feld Wert übergeben wird. Das Steuerelement wird nur dann auf den Stack übertragen, wenn das oberste Element des Stacks von der "),t("em",[e._v("valueToBool")]),e._v("-Funktion aufgerufen und "),t("code",[e._v("true")]),e._v(" zurückgegeben wird. Andernfalls wird die Steuerung an den nächsten Befehl übergeben;")]),e._v(" "),t("li",[t("strong",[e._v("cmdElse")]),e._v(" - dieser Befehl funktioniert auf die gleiche Weise wie "),t("strong",[e._v("cmdIf")]),e._v(", aber nur wenn das oberste Element des Stacks von der valueToBool-Funktion aufgerufen und "),t("code",[e._v("false")]),e._v(" zurückgegeben wird, wird die Steuerung an die übertragen angegebener Block;")]),e._v(" "),t("li",[t("strong",[e._v("cmdAssignVar")]),e._v(" – erhält eine Liste von Variablen des Typs "),t("strong",[e._v("VarInfo")]),e._v(" von Value. Diese Variablen verwenden den Befehl "),t("strong",[e._v("cmdAssign")]),e._v(", um den Wert abzurufen;")]),e._v(" "),t("li",[t("strong",[e._v("cmdAssign")]),e._v(" – weist den Wert im Stack der Variablen zu, die durch den Befehl "),t("strong",[e._v("cmdAssignVar")]),e._v(" erhalten wurde;")]),e._v(" "),t("li",[t("strong",[e._v("cmdLabel")]),e._v(" - definiert ein Label, wenn die Steuerung während der While-Schleife zurückgegeben wird;")]),e._v(" "),t("li",[t("strong",[e._v("cmdContinue")]),e._v(" - Dieser Befehl überträgt die Steuerung an das Label "),t("strong",[e._v("cmdLabel")]),e._v(". Beim Ausführen einer neuen Iteration der Schleife wird Value nicht verwendet;")]),e._v(" "),t("li",[t("strong",[e._v("cmdWhile")]),e._v(" – Verwenden Sie valueToBool, um das oberste Element des Stapels zu überprüfen. Wenn dieser Wert „true“ ist, wird die Struktur "),t("strong",[e._v("block")]),e._v(" aus dem Wertefeld aufgerufen;")]),e._v(" "),t("li",[t("strong",[e._v("cmdBreak")]),e._v(" - beendet die Schleife;")]),e._v(" "),t("li",[t("strong",[e._v("cmdIndex")]),e._v(" – legt den Wert in der Map oder im Array nach Index in den Stack, ohne Value zu verwenden. Beispiel: "),t("code",[e._v("(map | array) (index value) => (map | array [index value])")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdSetIndex")]),e._v(" – weist den Wert des obersten Elements des Stapels den Elementen der Karte oder des Arrays zu, ohne Value zu verwenden. Beispiel: "),t("code",[e._v("(map | array) (index value) (value) => (map | array)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdFuncName")]),e._v(" - fügt Parameter hinzu, die mit sequentiellen Beschreibungen geteilt durch Punkt übergeben werden. Beispiel: "),t("code",[e._v("func name => Fun (...) .Name (...)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdUnwrapArr")]),e._v(" - definiert ein boolesches Flag, wenn das oberste Element des Stapels ein Array ist;")]),e._v(" "),t("li",[t("strong",[e._v("cmdMapInit")]),e._v(" – initialisiert den Wert von map;")]),e._v(" "),t("li",[t("strong",[e._v("cmdArrayInit")]),e._v(" – initialisiert den Wert des Arrays;")]),e._v(" "),t("li",[t("strong",[e._v("cmdError")]),e._v(" - Dieser Befehl wird erstellt, wenn ein Vertrag oder eine Funktion mit einem angegebenen "),t("code",[e._v("error, warning, info")]),e._v(" beendet wird.")])]),e._v(" "),t("h3",{attrs:{id:"stack-operationsbefehle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stack-operationsbefehle"}},[e._v("#")]),e._v(" Stack-Operationsbefehle")]),e._v(" "),t("blockquote",[t("p",[e._v("Hinweis")])]),e._v(" "),t("blockquote",[t("p",[e._v("In der aktuellen Version ist die automatische Typkonvertierung für diese Befehle nicht vollständig anwendbar. Zum Beispiel,")])]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("string + float | int | decimal => float | int | decimal, float + int | str => float, but int + string => runtime error")]),e._v(".")])]),e._v(" "),t("p",[e._v("Das Folgende sind Befehle für die direkte Stack-Verarbeitung. Das Feld Wert wird in diesen Befehlen nicht verwendet.")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("cmdNot")]),e._v(" - logische Negation. "),t("code",[e._v("(val) => (!ValueToBool(val))")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdSign")]),e._v(" - Vorzeichenwechsel. "),t("code",[e._v("(val) => (-val)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdAdd")]),e._v(" - Ergänzung. "),t("code",[e._v("(val1)(val2) => (val1 + val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdSub")]),e._v(" - Subtraktion. "),t("code",[e._v("(val1)(val2) => (val1-val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdMul")]),e._v(" - Multiplikation. "),t("code",[e._v("(val1)(val2) => (val1 * val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdDiv")]),e._v(" - Division. "),t("code",[e._v("(val1)(val2) => (val1 / val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdAnd")]),e._v(" - logisches UND. "),t("code",[e._v("(val1)(val2) => (valueToBool(val1) && valueToBool(val2))")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdOr")]),e._v(" - logisches ODER. "),t("code",[e._v("(val1)(val2) => (valueToBool(val1) || valueToBool(val2))")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdEqual")]),e._v(" - Gleichheitsvergleich, bool wird zurückgegeben. "),t("code",[e._v("(val1)(val2) => (val1 == val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdNotEq")]),e._v(" - Ungleichheitsvergleich, bool wird zurückgegeben. "),t("code",[e._v("(val1)(val2) => (val1 != val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdLess")]),e._v(" - Kleiner-als-Vergleich, bool wird zurückgegeben. "),t("code",[e._v("(val1)(val2) => (val1 <val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdNotLess")]),e._v(" - Größer-gleich-Vergleich, bool wird zurückgegeben. "),t("code",[e._v("(val1)(val2) => (val1 >= val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdGreat")]),e._v(" - Größer-als-Vergleich, bool wird zurückgegeben. "),t("code",[e._v("(val1)(val2) => (val1> val2)")]),e._v(";")]),e._v(" "),t("li",[t("strong",[e._v("cmdNotGreat")]),e._v(" - Kleiner-gleich-Vergleich, bool wird zurückgegeben. "),t("code",[e._v("(val1)(val2) => (val1 <= val2)")]),e._v(".")])]),e._v(" "),t("h3",{attrs:{id:"laufzeitstruktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#laufzeitstruktur"}},[e._v("#")]),e._v(" Laufzeitstruktur")]),e._v(" "),t("p",[e._v("Die Ausführung von Bytecodes wirkt sich nicht auf die virtuelle Maschine aus. Beispielsweise können verschiedene Funktionen und Verträge gleichzeitig in einer einzigen virtuellen Maschine ausgeführt werden. Die Runtime-Struktur wird verwendet, um Funktionen und Verträge sowie beliebige Ausdrücke und Bytecode auszuführen.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type RunTime struct {\n   stack []interface{}\n   blocks []*blockStack\n   vars []interface{}\n   extend *map[string]interface{}\n   vm *VM\n   cost int64\n   err error\n}\n")])])]),t("ul",[t("li",[t("strong",[e._v("stack")]),e._v(" - der Stack zum Ausführen des Bytecodes;")]),e._v(" "),t("li",[t("strong",[e._v("blocks")]),e._v(" - Stack für Blockaufrufe;")]),e._v(" "),t("li",[t("strong",[e._v("vars")]),e._v(" - Stapel von Variablen. Seine Variable wird dem Stapel von Variablen hinzugefügt, wenn der Bytecode im Block aufgerufen wird. Nach dem Verlassen des Blocks kehrt die Größe des Variablenstapels zum vorherigen Wert zurück;")]),e._v(" "),t("li",[t("strong",[e._v("extend")]),e._v(" - ein Zeiger zum Abbilden mit Werten externer Variablen ("),t("code",[e._v("$name")]),e._v(");")]),e._v(" "),t("li",[t("strong",[e._v("vm")]),e._v(" - ein Zeiger einer virtuellen Maschine;")]),e._v(" "),t("li",[t("strong",[e._v("cost")]),e._v(" - Kraftstoffeinheit der resultierenden Ausführungskosten;")]),e._v(" "),t("li",[t("strong",[e._v("err")]),e._v(" - Fehler während der Ausführung aufgetreten.")])]),e._v(" "),t("h4",{attrs:{id:"blockstack-struktur"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blockstack-struktur"}},[e._v("#")]),e._v(" blockStack-Struktur")]),e._v(" "),t("p",[e._v("Die blockStack-Struktur wird in der Runtime-Struktur verwendet.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type blockStack struct {\n   Block *Block\n   Offset int\n}\n")])])]),t("ul",[t("li",[t("strong",[e._v("Block")]),e._v(" – ein Zeiger auf den ausgeführten Block;")]),e._v(" "),t("li",[t("strong",[e._v("Offset")]),e._v(" – der Offset des letzten ausgeführten Befehls im Bytecode des angegebenen Blocks.")])]),e._v(" "),t("h3",{attrs:{id:"runcode-funktion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runcode-funktion"}},[e._v("#")]),e._v(" RunCode-Funktion")]),e._v(" "),t("p",[e._v("Bytecodes werden in der Funktion "),t("strong",[e._v("RunCode")]),e._v(" ausgeführt. Es enthält eine Schleife, die die entsprechende Operation für jeden Bytecode-Befehl durchführt. Vor der Verarbeitung eines Bytecodes müssen die erforderlichen Daten initialisiert werden.")]),e._v(" "),t("p",[e._v("Neue Blöcke werden zu anderen Blöcken hinzugefügt.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("rt.blocks = append(rt.blocks, &blockStack{block, len(rt.vars)})\n")])])]),t("p",[e._v("Rufen Sie als Nächstes die Informationen zu den relevanten Parametern der Tail-Funktion ab. Diese Parameter sind im letzten Element des Stapels enthalten.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var namemap map[string][]interface{}\nif block.Type == ObjFunc && block.Info.(*FuncInfo).Names != nil {\n   if rt.stack[len(rt.stack)-1] != nil {\n      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})\n   }\n   rt.stack = rt.stack[:len(rt.stack)-1]\n}\n")])])]),t("p",[e._v("Anschließend müssen alle im aktuellen Block definierten Variablen mit ihren Anfangswerten initialisiert werden.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("start := len(rt.stack)\nvaroff := len(rt.vars)\nfor vkey, vpar := range block.Vars {\n   rt.cost--\n   var value interface{}\n")])])]),t("p",[e._v("Da Variablen in der Funktion auch Variablen sind, müssen wir sie vom letzten Element des Stacks in der von der Funktion selbst beschriebenen Reihenfolge abrufen.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("   if block.Type == ObjFunc && vkey <len(block.Info.(*FuncInfo).Params) {\n      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]\n   } else {\n")])])]),t("p",[e._v("Lokale Variablen mit ihren Anfangswerten initialisieren.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("      value = reflect.New(vpar).Elem().Interface()\n\n      if vpar == reflect.TypeOf(map[string]interface{}{}) {\n\n         value = make(map[string]interface{})\n      } else if vpar == reflect.TypeOf([]interface{}{}) {\n         value = make([]interface{}, 0, len(rt.vars)+1)\n      }\n   }\n   rt.vars = append(rt.vars, value)\n}\n")])])]),t("p",[e._v("Aktualisieren Sie als Nächstes die Werte der variablen Parameter, die in der Tail-Funktion übergeben werden.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if namemap != nil {\n   for key, item := range namemap {\n      params := (*block.Info.(*FuncInfo).Names)[key]\n      for i, value := range item {\n         if params.Variadic && i >= len(params.Params)-1 {\n")])])]),t("p",[e._v("Wenn übergebene variable Parameter zu einer variablen Anzahl von Parametern gehören, werden diese Parameter zu einem Array von Variablen kombiniert.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("            off := varoff + params.Offset[len(params.Params)-1]\n            rt.vars[off] = append(rt.vars[off].([]interface{}), value)\n         } else {\n            rt.vars[varoff+params.Offset[i]] = value\n         }\n      }\n   }\n}\n")])])]),t("p",[e._v("Danach müssen wir nur noch Werte löschen, die von der Spitze des Stacks als Funktionsparameter übergeben wurden, wodurch der Stack verschoben wird. Wir haben ihre Werte in ein Variablenarray kopiert.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if block.Type == ObjFunc {\n   start -= len(block.Info.(*FuncInfo).Params)\n}\n")])])]),t("p",[e._v("Wenn eine Bytecode-Befehlsschleife beendet ist, müssen wir den Stack korrekt leeren.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("last := rt.blocks[len(rt.blocks)-1]\n")])])]),t("p",[e._v("Löschen Sie den aktuellen Block aus dem Blockstapel.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("rt.blocks = rt.blocks[:len(rt.blocks)-1]\nif status == statusReturn {\n")])])]),t("p",[e._v("Wenn eine bereits ausgeführte Funktion erfolgreich beendet wird, fügen wir den Rückgabewert am Ende des vorherigen Stacks hinzu.```\nif last.Block.Type == ObjFunc {\nfor count := len(last.Block.Info.(*FuncInfo).Results); count > 0; count-- {\nrt.stack[start] = rt.stack[len(rt.stack)-count]\nstart++\n}\nstatus = statusNormal\n} else {")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Wie Sie sehen können, stellen wir den Stack-Status nicht wieder her und beenden die Funktion unverändert, wenn wir die Funktion nicht ausführen. Der Grund ist, dass Schleifen und bedingte Strukturen, die in der Funktion ausgeführt wurden, ebenfalls Bytecode-Blöcke sind.\n")])])]),t("p",[e._v("return")]),e._v(" "),t("p",[e._v("}\n}")]),e._v(" "),t("p",[e._v("rt.stack = rt.stack[:start]")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n### Weitere Funktionen für Operationen mit VM\n\nMit der Funktion **NewVM** können Sie eine virtuelle Maschine erstellen. Jeder virtuellen Maschine werden über die Funktion **Extend** vier Funktionen hinzugefügt, z. B. **ExecContract**, **MemoryUsage**, **CallContract** und **Settings**.\n\n")])])]),t("p",[e._v("for key, item := range ext.Objects {\nfobj := reflect.ValueOf(item).Type()")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nWir durchlaufen alle übergebenen Objekte und betrachten nur die Funktionen.\n\n")])])]),t("p",[e._v("switch fobj.Kind() {\ncase reflect.Func:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nWir füllen die **ExtFuncInfo**-Struktur gemäß den über die Funktion erhaltenen Informationen und fügen ihre Struktur namentlich der Top-Level-Map **Objects** hinzu.\n\n")])])]),t("p",[e._v("data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),\nmake([]string, fobj.NumIn()), fobj.IsVariadic(), item}\nfor i := 0; i <fobj.NumIn(); i++ {")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Die **ExtFuncInfo**-Struktur hat ein **Auto**-Parameter-Array. Normalerweise ist der erste Parameter `sc *SmartContract` oder `rt *Runtime`, wir können sie nicht von der Sprache Needle übergeben, da sie für uns notwendig sind, um einige Golang-Funktionen auszuführen. Daher legen wir fest, dass diese Variablen automatisch verwendet werden, wenn diese Funktionen aufgerufen werden. In diesem Fall ist der erste Parameter der obigen vier Funktionen `rt *Runtime`.\n\n")])])]),t("p",[e._v("if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {\ndata.Auto[i] = isauto\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nInformationen zur Parametrierung.\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  data.Params[i] = fobj.In(i)\n")])])]),t("p",[e._v("}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nUnd die Typen der Rückgabewerte.\n")])])]),t("p",[e._v("for i := 0; i <fobj.NumOut(); i++ {\ndata.Results[i] = fobj.Out(i)\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Fügt eine Funktion zu den **Objekten** des Stammverzeichnisses hinzu, damit der Compiler sie später finden kann, wenn er den Vertrag verwendet.\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  vm.Objects[key] = &ObjInfo{ObjExtFunc, data}\n")])])]),t("p",[e._v("}")]),e._v(" "),t("p",[e._v("}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n## Compiler\n\nFunktionen in der Datei compile.go sind für das Kompilieren des Token-Arrays verantwortlich, das vom lexikalischen Analysator erhalten wird. Die Zusammenstellung kann bedingt in zwei Ebenen unterteilt werden. Auf der obersten Ebene beschäftigen wir uns mit Funktionen, Verträgen, Codeblöcken, Bedingungs- und Schleifenanweisungen, Variablendefinitionen und so weiter. Auf der unteren Ebene kompilieren wir Ausdrücke in Codeblöcke oder Bedingungen in Schleifen und bedingte Anweisungen.\n\nZunächst beginnen wir mit der einfachen unteren Ebene. In der Funktion **compileEval** können Ausdrücke in Bytecode umgewandelt werden. Da wir eine virtuelle Maschine mit einem Stack verwenden, ist es notwendig, gewöhnliche Infix-Record-Ausdrücke in Postfix-Notation oder umgekehrte polnische Notation umzuwandeln. Zum Beispiel wandeln wir „1+2“ in „12+“ um und legen „1“ und „2“ auf den Stack. Dann wenden wir die Additionsoperation auf die letzten beiden Elemente im Stack an und schreiben das Ergebnis in den Stack. Sie finden diesen [Konvertierungs-](https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/) Algorithmus im Internet.\n\nDie globale Variable „opers = map [uint32] operPrior“ enthält die Priorität der Operationen, die für die Konvertierung in die inverse polnische Notation erforderlich sind.\n\nDie folgenden Variablen werden am Anfang der Funktion **compileEval** definiert:\n* **Puffer** - temporärer Puffer für Bytecode-Befehle;\n* **Bytecode** - letzter Puffer von Bytecode-Befehlen;\n* **parcount** - temporärer Puffer, der zum Berechnen von Parametern beim Aufrufen einer Funktion verwendet wird;\n* **setIndex** - Variablen im Arbeitsprozess werden auf true gesetzt, wenn wir Map- oder Array-Elemente zuweisen. Beispiel: `a["my"] = 10`. In diesem Fall müssen wir den angegebenen Befehl **cmdSetIndex** verwenden.\n\nWir erhalten ein Token in einer Schleife und verarbeiten es entsprechend. Beispielsweise wird die Ausdruckstrennung gestoppt, wenn geschweiften Klammern gefunden werden. Beim Verschieben der Zeichenfolge prüfen wir, ob die vorherige Anweisung eine Operation ist und ob sie innerhalb der Klammern steht, andernfalls wird der Ausdruck beendet und analysiert.\n\n')])])]),t("p",[e._v("case isRCurly, isLCurly:\ni--\nif prevLex == isComma || prevLex == lexOper {\nreturn errEndExp\n}\nbreak main\ncase lexNewLine:\nif i > 0 && ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {\ncontinue main\n}\nfor k := len(buffer) - 1; k >= 0; k-- {\nif buffer[k].Cmd == cmdSys {\ncontinue main\n}\n}\nbreak main")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Im Allgemeinen entspricht der Algorithmus selbst einem Algorithmus zum Umwandeln in die inverse polnische Notation. Unter Berücksichtigung des Aufrufs notwendiger Verträge, Funktionen und Indizes sowie anderer Dinge, die beim Parsing nicht vorkommen, und Optionen zum Parsing von Token vom Typ lexIdent werden dann Variablen, Funktionen oder Verträge mit diesem Namen überprüft. Wenn nichts gefunden wird und es sich nicht um einen Funktions- oder Vertragsaufruf handelt, wird ein Fehler angezeigt.\n\n")])])]),t("p",[e._v("objInfo, tobj := vm.findObj(lexem.Value.(string), block)\nif objInfo == nil && (!vm.Extern || i> *ind || i >= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {\nreturn fmt.Errorf("),t("code",[e._v("unknown identifier %s")]),e._v(", lexem.Value.(string))\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nWir können auf eine solche Situation stoßen, und der Vertragsaufruf wird später beschrieben. Wenn in diesem Beispiel keine Funktionen oder Variablen mit demselben Namen gefunden werden, halten wir es für notwendig, einen Vertrag aufzurufen. In dieser kompilierten Sprache gibt es keinen Unterschied zwischen Verträgen und Funktionsaufrufen. Aber wir müssen den Vertrag über die Funktion **ExecContract** aufrufen, die im Bytecode verwendet wird.\n")])])]),t("p",[e._v("if objInfo.Type == ObjContract {\nif objInfo.Value != nil {\nobjContract = objInfo.Value.(*Block)\n}\nobjInfo, tobj = vm.findObj("),t("code",[e._v("ExecContract")]),e._v(", block)\nisContract = true\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Die Anzahl der bisherigen Variablen erfassen wir in `count`, die zusammen mit der Anzahl der Funktionsparameter auch auf den Stack geschrieben werden. Bei jeder weiteren Erkennung von Parametern müssen wir diese Zahl nur am letzten Element des Stapels um eine Einheit erhöhen.\n\n\n")])])]),t("p",[e._v("count := 0\nif (*lexems)[i+2].Type != isRPar {\ncount++\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Wir haben eine Liste mit aufgerufenen Parametern für Verträge verwendet, dann müssen wir den Fall markieren, in dem der Vertrag aufgerufen wird. Wenn der Vertrag ohne Parameter aufgerufen wird, müssen wir zwei leere Parameter hinzufügen, um **ExecContract** aufzurufen, um mindestens zwei Parameter zu erhalten.\n")])])]),t("p",[e._v('if isContract {\nname := StateName((*block)[0].Info.(uint32), lexem.Value.(string))\nfor j := len(*block) - 1; j >= 0; j-- {\ntopblock := (*block)[j]\nif topblock.Type == ObjContract {\nif topblock.Info.(*ContractInfo).Used == nil {\ntopblock.Info.(*ContractInfo).Used = make(map[string]bool)\n}\ntopblock.Info.(*ContractInfo).Used[name] = true\n}\n}\nbytecode = append(bytecode, &ByteCode{cmdPush, name})\nif count == 0 {\ncount = 2\nbytecode = append(bytecode, &ByteCode{cmdPush, ""})\nbytecode = append(bytecode, &ByteCode{cmdPush, ""})\n}\ncount++\n}')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nWenn wir sehen, dass als nächstes eine eckige Klammer steht, fügen wir den Befehl **cmdIndex** hinzu, um den Wert durch den Index zu erhalten.\n")])])]),t("p",[e._v("if (*lexems)[i+1].Type == isLBrack {\nif objInfo == nil || objInfo.Type != ObjVar {\nreturn fmt.Errorf("),t("code",[e._v("unknown variable %s")]),e._v(", lexem.Value.(string))\n}\nbuffer = append(buffer, &ByteCode{cmdIndex, 0})\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Die Funktion **CompileBlock** kann Objektbäume und ausdrucksunabhängige Bytecodes generieren. Der Kompilierungsprozess basiert auf einer endlichen Zustandsmaschine, genau wie ein lexikalischer Analysator, aber mit den folgenden Unterschieden. Erstens verwenden wir keine Symbole, sondern Tokens; zweitens werden wir gleich die *states*-Variablen in allen Zuständen und Übergängen beschreiben. Es stellt ein Array von Objekten dar, die nach Tokentyp indiziert sind. Jedes Token hat eine Struktur von *compileState*, und ein neuer Status wird in *NewState* angegeben. Wenn klar ist, welche Struktur wir aufgelöst haben, können wir die Funktion des Handlers im Feld *Func* angeben.\n\nBetrachten wir den Hauptzustand als Beispiel.\n\nWenn wir auf einen Zeilenumbruch oder einen Kommentar stoßen, bleiben wir im selben Zustand. Wenn wir auf das Schlüsselwort **contract** stoßen, ändern wir den Status in *stateContract* und beginnen mit dem Parsen der Struktur. Wenn wir auf das Schlüsselwort **func** stoßen, ändern wir den Status in *stateFunc*. Wenn andere Token empfangen werden, wird die Funktion, die einen Fehler generiert, aufgerufen.\n\n")])])]),t("p",[e._v("{// stateRoot\nlexNewLine: {stateRoot, 0},\nlexKeyword | (keyContract << 8): {stateContract | statePush, 0},\nlexKeyword | (keyFunc << 8): {stateFunc | statePush, 0},\nlexComment: {stateRoot, 0},\n0: {errUnknownCmd, cfError},\n},")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Angenommen, wir sind auf das Schlüsselwort **func** gestoßen und haben den Status in *stateFunc* geändert. Da der Funktionsname auf das Schlüsselwort **func** folgen muss, behalten wir denselben Zustand bei, wenn wir den Funktionsnamen ändern. Für alle anderen Token werden wir entsprechende Fehler generieren. Wenn wir den Funktionsnamen in der Token-ID erhalten, gehen wir zum *stateFParams*-Zustand, wo wir die Parameter der Funktion erhalten können.\n")])])]),t("p",[e._v("{// stateFunc\nlexNewLine: {stateFunc, 0},\nlexIdent: {stateFParams, cfNameBlock},\n0: {errMustName, cfError},\n},")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Gleichzeitig mit den obigen Operationen rufen wir die Funktion **fNameBlock** auf. Es sollte beachtet werden, dass die Blockstruktur mit der statePush-Markierung erstellt wird, wo wir sie aus dem Puffer holen und mit den Daten füllen, die wir benötigen. Die **fNameBlock**-Funktion eignet sich für Verträge und Funktionen (einschließlich der darin verschachtelten). Er füllt das *Info*-Feld mit der entsprechenden Struktur und schreibt sich in die *Objects* des übergeordneten Blocks. Auf diese Weise können wir die Funktion oder den Vertrag mit dem angegebenen Namen aufrufen. Ebenso erstellen wir entsprechende Funktionen für alle Zustände und Variablen. Diese Funktionen sind normalerweise sehr klein und führen einige Aufgaben beim Erstellen des Baums der virtuellen Maschine aus.\n")])])]),t("p",[e._v("func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {\nvar itype int\nprev := (*buf)[len(*buf)-2]\nfblock := (*buf)[len(*buf)-1]\nname := lexem.Value.(string)\nswitch state {\ncase stateBlock:\nitype = ObjContract\nname = StateName((*buf)[0].Info.(uint32), name)\nfblock.Info = &ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,\nOwner: (*buf)[0].Owner}\ndefault:\nitype = ObjFunc\nfblock.Info = &FuncInfo{}\n}\nfblock.Type = itype\nprev.Objects[name] = &ObjInfo{Type: itype, Value: fblock}\nreturn nil\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Für die Funktion **CompileBlock** durchläuft sie einfach alle Tokens und wechselt die Zustände gemäß den in den Zuständen beschriebenen Tokens. Fast alle zusätzlichen Token entsprechen zusätzlichen Programmcodes.\n\n* **statePush** – fügt das Objekt **Block** zum Objektbaum hinzu;\n* **statePop** - wird verwendet, wenn der Block mit einer schließenden geschweiften Klammer endet;\n* **stateStay** - Sie müssen die aktuelle Markierung beibehalten, wenn Sie in einen neuen Status wechseln;\n* **stateToBlock** - Übergang in den Zustand **stateBlock** zur Verarbeitung von *while* und *if*. Nach der Verarbeitung von Ausdrücken müssen Sie Blöcke innerhalb der geschweiften Klammern verarbeiten;\n* **stateToBody** - Übergang in den Zustand **stateBody**;\n* **stateFork** - speichert die markierte Position. Wenn der Ausdruck mit einem Bezeichner oder einem Namen mit `$` beginnt, können wir Funktionsaufrufe oder Zuweisungen vornehmen;\n* **stateToFork** – wird verwendet, um das in **stateFork** gespeicherte Token abzurufen, das an die Prozessfunktion übergeben wird;\n* **stateLabel** – wird zum Einfügen von **cmdLabel**-Befehlen verwendet. *während* die Struktur dieses Flag erfordert;\n* **stateMustEval** – prüft die Verfügbarkeit von bedingten Ausdrücken am Anfang von *if*- und *while*-Strukturen.\n\nNeben der Funktion **CompileBlock** ist auch die Funktion **FlushBlock** zu nennen. Das Problem besteht jedoch darin, dass der Blockbaum unabhängig von vorhandenen virtuellen Maschinen erstellt wird. Genauer gesagt erhalten wir Informationen über Funktionen und Verträge, die in einer virtuellen Maschine vorhanden sind, aber wir sammeln die kompilierten Blöcke in einem separaten Baum. Andernfalls, wenn während der Kompilierung ein Fehler auftritt, müssen wir die virtuelle Maschine auf den vorherigen Zustand zurücksetzen. Daher gehen wir separat zum Kompilierungsbaum, aber nachdem die Kompilierung erfolgreich ist, muss die Funktion **FlushContract** aufgerufen werden. Diese Funktion fügt den fertigen Blockbaum zur aktuellen virtuellen Maschine hinzu. Die Kompilierungsphase ist nun abgeschlossen.\n\n## Lexikalischer Analysator\nDer lexikalische Analysator verarbeitet eingehende Zeichenfolgen und bildet eine Folge von Token der folgenden Typen:\n* **lexSys** - Systemtoken, zum Beispiel: `{}, [], (), ,, .` usw.;\n* **lexOper** - Vorgangstoken, zum Beispiel: `+, -, /, \\, *`;\n* **lexNumber** - Zahl;\n* **lexident** - Kennung;\n* **lexNewline** - Zeilenumbruchzeichen;\n* **lexString** - Zeichenkette;\n* **lexComment** - Kommentar;\n* **lexKeyword** - Schlüsselwort;\n* **lexType** - Typ;\n* **lexExtend** - Verweis auf externe Variablen oder Funktionen, zum Beispiel: `$myname`.\n\nIn der aktuellen Version wird zunächst mit Hilfe der Datei [script/lextable/lextable.go](#lextablelextablego) eine Konvertierungstabelle (finite state machine) zum Parsen der Tokens aufgebaut, die in die Datei lex_table.go geschrieben wird. Im Allgemeinen können Sie die ursprünglich von der Datei generierte Konvertierungstabelle loswerden und direkt beim Start eine Konvertierungstabelle im Speicher erstellen (`init()`). Die lexikalische Analyse selbst findet in der lexParser-Funktion in der Datei [lex.go](#lex-go) statt.\n\n### <span id = "lextable-lextable-go">lextable/lextable.go</span>\n\nHier definieren wir das zu betreibende Alphabet und beschreiben, wie die endliche Zustandsmaschine basierend auf dem nächsten empfangenen Symbol von einem Zustand in einen anderen wechselt.\n\n*states* ist ein JSON-Objekt, das eine Liste von Zuständen enthält.\nMit Ausnahme bestimmter Symbole steht „d“ für alle Symbole, die nicht im Staat angegeben sind.\n„n“ steht für 0x0a, „s“ steht für Leerzeichen, „q“ steht für Backquote, „Q“ steht für doppeltes Anführungszeichen, „r“ steht für Zeichen >= 128, „a“ steht für AZ und az und „ 1` steht für 1-9.\n\nDie Namen dieser Zustände sind Schlüssel, und die möglichen Werte sind im Wertobjekt aufgelistet. Dann gibt es einen neuen Zustand, um Übergänge für jede Gruppe vorzunehmen. Dann gibt es noch den Namen des Tokens. Wenn wir zum Anfangszustand zurückkehren müssen, ist der dritte Parameter das Service-Token, das angibt, wie mit dem aktuellen Symbol umgegangen werden soll.\n\nZum Beispiel haben wir den Hauptzustand und die eingehenden Zeichen `/`, `"/": ["solidus", "", "push next"]`,\n\n* **push** - gibt den Befehl, sich daran zu erinnern, dass es sich in einem separaten Stack befindet ;\n* **nächster** - geht zum nächsten Zeichen, und gleichzeitig ändern wir den Status auf **solidus**. Ruft danach das nächste Zeichen ab und überprüft den Status von **solidus**.\n\nWenn das nächste Zeichen `/` oder `/*` hat, gehen wir zum Kommentarstatus **Kommentar**, weil sie mit `//` oder `/*` beginnen. Offensichtlich hat jeder Kommentar danach einen anderen Zustand, weil sie mit einem anderen Symbol enden.\n\nWenn das nächste Zeichen nicht `/` und `*` ist, dann zeichnen wir alles im Stack als Tags vom Typ **lexOper** auf, leeren den Stack und kehren zum Hauptzustand zurück.\nDas folgende Modul konvertiert den Zustandsbaum in ein numerisches Array und schreibt es in die Datei *lex_table.go*.\n\nIn der ersten Schleife:\n\nWir bilden ein Alphabet gültiger Symbole.\n\n')])])]),t("p",[e._v("for ind, ch := range alphabet {\ni := byte(ind)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Darüber hinaus versehen wir in **state2int** jeden Zustand mit einer eigenen Sequenzkennung.\n\n")])])]),t("p",[e._v("state2int := map[string]uint{"),t("code",[e._v("main")]),e._v(": 0}\nif err := json.Unmarshal([]byte(states), &data); err == nil {\nfor key := range data {\nif key != "),t("code",[e._v("main")]),e._v(" {\nstate2int[key] = uint(len(state2int))")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Wenn wir alle Zustände und jede Menge in einem Zustand und jedes Symbol in einer Menge durchlaufen, schreiben wir eine Drei-Byte-Zahl [neue Zustandskennung (0 = Haupt)] + [Tokentyp (0-kein Token)] + [Token] .\nDie Zweidimensionalität des Arrays *table* besteht darin, dass es in Zustände und 34 Eingabesymbole aus dem Array *alphabet* unterteilt ist, die in derselben Reihenfolge angeordnet sind.\nWir befinden uns im *Hauptzustand* in der Nullzeile der *Tabelle*. Nehmen Sie das erste Zeichen, finden Sie seinen Index im Array *alphabet* und erhalten Sie den Wert aus der Spalte mit dem angegebenen Index. Ausgehend vom empfangenen Wert erhalten wir den Token im Low-Byte. Wenn die Analyse abgeschlossen ist, zeigt das zweite Byte den Typ des empfangenen Tokens an. Im dritten Byte erhalten wir den Index des nächsten neuen Zustands.\nAll dies wird ausführlicher in der Funktion **lexParser** in *lex.go* beschrieben.\nWenn Sie einige neue Zeichen hinzufügen möchten, müssen Sie sie dem Array *alphabet* hinzufügen und die Menge der Konstante *AlphaSize* erhöhen. Wenn Sie eine neue Symbolkombination hinzufügen möchten, sollte diese ähnlich wie bei den bestehenden Optionen im Status beschrieben werden. Führen Sie nach dem obigen Vorgang die Datei *lextable.go* aus, um die Datei *lex_table.go* zu aktualisieren.\n\n### <span id = "lex-go">lex.go</span>\nDie **lexParser**-Funktion generiert direkt eine lexikalische Analyse und gibt basierend auf eingehenden Zeichenfolgen ein Array empfangener Tags zurück. Lassen Sie uns die Struktur von Token analysieren.\n\n')])])]),t("p",[e._v("type Lexem struct {\nType  uint32 // Type of the lexem\nValue interface{} // Value of lexem\nLine  uint32 // Line of the lexem\nColumn uint32 // Position inside the line\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('* **Typ** - Token-Typ. Es hat einen der folgenden Werte: `lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend`;\n* **value** – Wert des Tokens. Die Art des Werts hängt vom Token-Typ ab. Lassen Sie uns das genauer analysieren:\n   * **lexSys** - enthält Klammern, Kommas usw. In diesem Fall `Type = ch << 8 | lexSys“, beziehen Sie sich bitte auf die Konstante „isLPar ... isRBrack“, und ihr Wert ist uint32 Bits;\n   * **lexOper** - der Wert stellt eine äquivalente Zeichenfolge in Form von uint32 dar. Siehe die `isNot ... isOr`-Konstanten;\n   * **lexNumber** - Zahlen werden als int64 oder float64 gespeichert. Wenn die Zahl einen Dezimalpunkt hat, ist sie Float64;\n   * **lexIdent** - Identifikatoren werden als String gespeichert;\n   * **lexNewLine** - Zeilenumbruchzeichen. Wird auch zur Berechnung der Reihen- und Tokenposition verwendet;\n   * **lexString** - Zeilen werden als String gespeichert;\n   * **lexComment** - Kommentare werden als String gespeichert;\n   * **lexKeyword** - für Schlüsselwörter werden nur die entsprechenden Indizes gespeichert, siehe `keyContract ... keyTail`-Konstante. In diesem Fall `Type = KeyID << 8 | lexKeyword`. Außerdem ist zu beachten, dass die Schlüsselwörter „true, false, nil“ sofort in Token vom Typ „lexNumber“ umgewandelt und die entsprechenden Typen „bool“ und „interface {}“ verwendet werden;\n   * **lexType** – dieser Wert enthält den entsprechenden „reflect.Type“-Typwert;\n   * **lexExtend** – Bezeichner, die mit einem `$` beginnen. Diese Variablen und Funktionen werden von außen übergeben und sind daher speziellen Arten von Token zugeordnet. Dieser Wert enthält den Namen als String ohne $ am Anfang.\n* **Line** - die Zeile, in der das Token gefunden wird;\n* **Column** - Inline-Position des Tokens.\nLassen Sie uns die Funktion **lexParser** im Detail analysieren. Die **todo**-Funktion schlägt den Symbolindex im Alphabet basierend auf dem aktuellen Status und dem eingehenden Symbol nach und erhält einen neuen Status, Token-Identifikator (falls vorhanden) und andere Token aus der Umwandlungstabelle. Das Parsing selbst beinhaltet das Aufrufen der **todo**-Funktion der Reihe nach für jedes nächste Zeichen und das Wechseln in einen neuen Zustand. Sobald das Tag empfangen wurde, erstellen wir das entsprechende Token in den Ausgabekriterien und setzen den Parsing-Prozess fort. Es sollte beachtet werden, dass wir während des Parsing-Prozesses die Token-Symbole nicht in einem separaten Stack oder Array akkumulieren, weil wir nur den Offset des Starts des Tokens speichern. Nachdem wir das Token erhalten haben, verschieben wir den Offset des nächsten Tokens an die aktuelle Parsing-Position.\n\nEs bleibt nur noch, die beim Parsing verwendeten lexikalischen Status-Token zu überprüfen:\n* **lexfPush** - dieses Token bedeutet, dass wir beginnen, Symbole in einem neuen Token zu sammeln;\n* **lexfNext** - das Zeichen muss dem aktuellen Token hinzugefügt werden;\n* **lexfPop** - Der Empfang des Tokens ist abgeschlossen. Normalerweise haben wir mit diesem Flag den Bezeichnertyp des geparsten Tokens;\n* **lexfSkip** - Dieses Token wird verwendet, um Zeichen vom Parsen auszuschließen. Beispielsweise sind die Kontrollschrägstriche in der Zeichenfolge \\n \\r \\". Sie werden während der lexikalischen Analysephase automatisch ersetzt.\n\n## Needle Sprache\n### Lexemes\nDer Quellcode eines Programms muss in UTF-8-Kodierung vorliegen.\n\nDie folgenden lexikalischen Typen werden verarbeitet:\n\n* **Schlüsselwörter** - ```action, break, conditions, Continue, Contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while``` ;\n* **Zahl** - nur Dezimalzahlen werden akzeptiert. Es gibt zwei Grundtypen: **int** und **float**. Wenn die Zahl einen Dezimalpunkt hat, wird sie zu einem Float **float**. Der Typ **int** entspricht in Golang **int64**, während der Typ **float** in Golang **float64** entspricht.\n* **String** - Der String kann in doppelte Anführungszeichen ```("ein String")``` oder Backquotes ```(\\`ein String\\`)``` eingeschlossen werden. Beide Arten von Zeichenfolgen können Zeilenumbruchzeichen enthalten. Zeichenfolgen in doppelten Anführungszeichen können doppelte Anführungszeichen, Zeilenumbruchzeichen und mit Schrägstrichen maskierte Wagenrückläufe enthalten. Beispiel: ```"Dies ist eine \\"erste Zeichenfolge\\".\\r\\nDies ist eine zweite Zeichenfolge."```.\n* **Kommentar** - Es gibt zwei Arten von Kommentaren. Einzeilige Kommentare verwenden zwei Schrägstriche (//). Beispiel: // Dies ist ein einzeiliger Kommentar. Mehrzeilige Kommentare verwenden Schrägstriche und Sternchen und können sich über mehrere Zeilen erstrecken. Beispiel: ```/* Dies ist ein mehrzeiliger Kommentar */```.\n* **Bezeichner** - die Namen von Variablen und Funktionen, die aus Buchstaben a-z und A-Z, UTF-8-Symbolen, Zahlen und Unterstrichen bestehen. Der Name kann mit einem Buchstaben, Unterstrich, ```@``` oder ```$``` beginnen. Der Name, der mit ```$``` beginnt, ist der Name der Variablen, die im **Datenabschnitt** definiert ist. Der mit ```$``` beginnende Name kann auch verwendet werden, um globale Variablen im Bereich von **Bedingungen** und **Aktionsabschnitten** zu definieren. Ökosystemverträge können über das Symbol ```@``` aufgerufen werden. Zum Beispiel: ```@1NewTable(...)```.\n\n### Typen\n\nNeben den Nadeltypen sind entsprechende Golang-Typen angegeben.\n* **bool** - bool, standardmäßig **false**;\n* **bytes** - []byte{}, standardmäßig ein leeres Byte-Array;\n* **int** - standardmäßig int64, **0**;\n* **Address** - uint64, standardmäßig **0**;\n* **Array** - []interface{}, standardmäßig ein leeres Array;\n* **map** - map[string]interface{}, standardmäßig ein leeres Objekt-Array;\n* **money** - Dezimalzahl. Dezimal, standardmäßig **0**;\n* **float** - float64, standardmäßig **0**;\n* **String** - String, standardmäßig ein leerer String;\n* **file** - map[string]interface{}, standardmäßig ein leeres Objekt-Array.\nDiese Variablentypen werden mit dem Schlüsselwort ```var``` definiert. Beispiel: ```var var1, var2 int```. Bei dieser Definition wird einer Variablen ein Standardwert nach Typ zugewiesen.\n\nAlle Variablenwerte sind vom Typ interface{} und werden dann den erforderlichen Golang-Typen zugewiesen. Daher sind beispielsweise Array- und Map-Typen Golang-Typen []interface{} und map[string]interface{}. Beide Arten von Arrays können Elemente beliebigen Typs enthalten.\n\n### Ausdrücke\n\nEin Ausdruck kann arithmetische Operationen, logische Operationen und Funktionsaufrufe enthalten. Alle Ausdrücke werden von links nach rechts nach Priorität der Operatoren ausgewertet. Bei gleicher Priorität werden Operatoren von links nach rechts ausgewertet.\n\nPriorität der Operationen von hoch nach niedrig:\n* **Funktionsaufruf und Klammern** - Beim Aufruf einer Funktion werden übergebene Parameter von links nach rechts berechnet;\n* **Unäre Operation** - logische Negation ```!``` und arithmetischer Vorzeichenwechsel ```-```;\n* **Multiplikation und Division** - arithmetische Multiplikation ```*``` und Division ```/```;\n* **Addition und Subtraktion** - arithmetische Addition ```+``` und Subtraktion ```-```;\n* **Logischer Vergleich** - ```>=>> >=```;\n* **Logische Gleichheit und Ungleichheit** - ```== !=```;\n* **Logisches UND** - ```&&```;\n* **Logisches ODER** - ```||```.\n\nBei der Auswertung von logischem AND und OR werden in jedem Fall beide Seiten des Ausdrucks ausgewertet.\n\nNeedle hat keine Typprüfung während der Kompilierung. Beim Auswerten von Operanden wird versucht, den Typ in einen komplexeren Typ umzuwandeln. Die Art der Komplexitätsreihenfolge kann wie folgt sein: ```string, int, float, money```. Nur ein Teil der Typkonvertierungen ist implementiert. Der Zeichenfolgentyp unterstützt Additionsoperationen, und das Ergebnis ist eine Zeichenfolgenverkettung. Beispiel: ```string + string = string, money-int = money, int * float = float```.\n\nBei Funktionen wird während der Ausführung eine Typprüfung für die Typen ```string``` und ```int``` durchgeführt.\nDie Typen **array** und **map** können per Index adressiert werden. Beim Typ **array** muss als Index der Wert **int** angegeben werden. Für den Typ **Map** muss eine Variable oder ein **String**-Wert angegeben werden. Wenn Sie einem **Array**-Element einen Wert zuweisen, dessen Index größer als der aktuelle maximale Index ist, wird dem Array ein leeres Element hinzugefügt. Der Anfangswert dieser Elemente ist **nil**. Zum Beispiel: .. Code:\n')])])]),t("p",[e._v('var my array\nmy[5] = 0\nvar mymap map\nmymap["index"] = my[3]')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("In Ausdrücken mit bedingten logischen Werten (z. B. `if, while, &&, ||, !`) wird der Typ automatisch in einen logischen Wert konvertiert. Wenn der Typ nicht der Standardwert ist, ist er wahr.\n")])])]),t("p",[e._v("var mymap map\nvar val string\nif mymap && val {\n...\n}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("### Zielfernrohr\n\nKlammern geben einen Block an, der lokale Bereichsvariablen enthalten kann. Standardmäßig erstreckt sich der Geltungsbereich einer Variablen auf ihre eigenen Blöcke und alle verschachtelten Blöcke. In einem Block können Sie eine neue Variable mit dem Namen einer vorhandenen Variablen definieren. In diesem Fall sind jedoch externe Variablen mit demselben Namen nicht mehr verfügbar.\n")])])]),t("p",[e._v("var a int\na = 3\n{\nvar a int\na = 4\nPrintln(a) // 4\n}\nPrintln(a) // 3")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('### Vertragsabwicklung\n\nBeim Aufruf eines Contracts müssen ihm in **data** definierte Parameter übergeben werden. Vor Ausführung eines Auftrags erhält die virtuelle Maschine diese Parameter und weist sie den entsprechenden Variablen ($Param) zu. Dann werden die vordefinierten Funktionen **conditions** und **action** aufgerufen.\n\nFehler, die während der Vertragsausführung auftreten, können in zwei Arten unterteilt werden: Formularfehler und Umgebungsfehler. Formularfehler werden mit speziellen Befehlen generiert: `error, warning, info` und wenn die eingebaute Funktion `err` ungleich *nil* zurückgibt.\n\nDie Needle-Sprache behandelt keine Ausnahmen. Jeder Fehler wird die Ausführung von Verträgen beenden. Da ein separater Stack und eine separate Struktur zum Speichern von Variablenwerten erstellt werden, wenn ein Vertrag ausgeführt wird, löscht der Golang-Garbage-Collection-Mechanismus diese Daten automatisch, wenn ein Vertrag ausgeführt wird.\n\n### <span id = "backus-naur-form-bnf">Backus–Naur Form (BNF)</span>\nIn der Informatik ist BNF eine Notationstechnik für kontextfreie Syntax und wird normalerweise verwendet, um die Syntax der beim Rechnen verwendeten Sprache zu beschreiben.\n\n* &lt;decimal digit&gt;\n')])])]),t("p",[e._v("'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;decimal number&gt;\n")])])]),t("p",[t("decimal",{attrs:{digit:""}},[e._v(" {"),t("decimal",{attrs:{digit:""}},[e._v("}")])],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;symbol code&gt;\n")])])]),t("p",[e._v("'''"),t("any",{attrs:{symbol:""}},[e._v("'''")])],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;real number&gt;\n")])])]),t("p",[e._v("['-'] <decimal number'.'["),t("decimal",{attrs:{number:""}},[e._v("]")])],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;integer number&gt;\n")])])]),t("p",[e._v("['-'] "),t("decimal",{attrs:{number:""}},[e._v(" | "),t("symbol",{attrs:{code:""}})])],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;number&gt;\n")])])]),t("p",[e._v("'"),t("integer",{attrs:{number:""}},[e._v(" | "),t("real",{attrs:{number:""}},[e._v("'")])],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;letter&gt;\n")])])]),t("p",[e._v("'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;space&gt;\n")])])]),t("p",[e._v("'0x20'")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;tabulation&gt;\n")])])]),t("p",[e._v("'0x09'")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;newline&gt;\n")])])]),t("p",[e._v("'0x0D 0x0A'")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;special symbol&gt;\n")])])]),t("p",[e._v("'!' |'\"' |'$' |''' |'(' |')' |'*' |'+' |',' |'-' |'.' |'/ '|'<' |'=' |'>' |'[' |'\\' |']' |'_' |'|' |'}' | '{' | "),t("tabulation",[e._v(" | "),t("space",[e._v(" | "),t("newline")],1)],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;symbol&gt;\n")])])]),t("p",[t("decimal",{attrs:{digit:""}},[e._v(" | "),t("letter",[e._v(" | "),t("special",{attrs:{symbol:""}})],1)],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;name&gt;\n")])])]),t("p",[e._v("("),t("letter",[e._v(" |'"),t("em",[e._v("') {"),t("letter",[e._v(" |'")])],1),e._v("' | "),t("decimal",{attrs:{digit:""}},[e._v("}")])],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n* &lt;function name&gt;\n")])])]),t("name",[e._v("\n```\n"),t("ul",[t("li",[e._v("<variable name>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<name>\n")])])]),t("ul",[t("li",[e._v("<type name>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<name>\n")])])]),t("ul",[t("li",[e._v("<string symbol>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<tabulation> | <space> |'!' |'#' | ... |'[' |']' | ...\n")])])]),t("ul",[t("li",[e._v("<string element>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{<string symbol> |'\\\"' |'\\n' |'\\r'}\n")])])]),t("ul",[t("li",[e._v("<string>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'\"' {<string element>}'\"' |'\\`' {<string element>}'\\`'\n")])])]),t("ul",[t("li",[e._v("<assignment operator>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'='\n")])])]),t("ul",[t("li",[e._v("<unary operator>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'-'\n")])])]),t("ul",[t("li",[e._v("<binary operator>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'==' |'!=' |'>' |'<' |'<=' |'>=' |'&&' |'||' |'\\*' |'/' |'+ '|'-'\n")])])]),t("ul",[t("li",[e._v("<operator>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<assignment operator> | <unary operator> | <binary operator>\n")])])]),t("ul",[t("li",[e._v("<parameters>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<expression> {','<expression>}\n")])])]),t("ul",[t("li",[e._v("<contract call>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<contract name>'(' [<parameters>]')'\n")])])]),t("ul",[t("li",[e._v("<function call>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<contract call> [{'.' <name>'(' [<parameters>]')'}]\n")])])]),t("ul",[t("li",[e._v("<block contents>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<block command> {<newline><block command>}\n")])])]),t("ul",[t("li",[e._v("<block>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'{'<block contents>'}'\n")])])]),t("ul",[t("li",[e._v("<block command>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("(<block> | <expression> | <variables definition> | <if> | <while> | break | continue | return)\n")])])]),t("ul",[t("li",[e._v("<if>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'if <expression><block> [else <block>]'\n")])])]),t("ul",[t("li",[e._v("<while>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'while <expression><block>'\n")])])]),t("ul",[t("li",[e._v("<contract>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'contract <name> '{'[<data section>] {<function>} [<conditions>] [<action>]'}''\n")])])]),t("ul",[t("li",[e._v("<data section>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'data '{' {<data parameter><newline>} '}''\n")])])]),t("ul",[t("li",[e._v("<data parameter>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<variable name> <type name>'\"'{<tag>}'\"'\n")])])]),t("ul",[t("li",[e._v("<tag>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'optional | image | file | hidden | text | polymap | map | address | signature:<name>'\n")])])]),t("ul",[t("li",[e._v("<conditions>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'conditions <block>'\n")])])]),t("ul",[t("li",[e._v("<action>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'action <block>'\n")])])]),t("ul",[t("li",[e._v("<function>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'func <function name>'('[<variable description>{','<variable description>}]')'[{<tail>}] [<type name>] <block>'\n")])])]),t("ul",[t("li",[e._v("<variable description>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<variable name> {',' <variable name>} <type name>\n")])])]),t("ul",[t("li",[e._v("<tail>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'.'<function name>'('[<variable description>{','<variable description>}]')'\n")])])]),t("ul",[t("li",[e._v("<variables definition>")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("'var <variable description>{','<variable description>}'\n")])])])])],1)}),[],!1,null,null,null);n.default=a.exports}}]);