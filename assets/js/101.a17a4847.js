(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{481:function(e,t,n){"use strict";n.r(t);var a=n(51),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"compiler-and-virtual-machine"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compiler-and-virtual-machine"}},[e._v("#")]),e._v(" Compiler and Virtual Machine")]),e._v(" "),n("ul",[n("li",[e._v("Source code storage and compilation")]),e._v(" "),n("li",[e._v("Virtual machine structures\n–VM structure\n–Block structure\n–ObjInfo structure")]),e._v(" "),n("li",[e._v("Virtual machine commands\n–ByteCode structure\n–Command identifiers\n–Stack operation commands\n–Runtime structure\n–RunCode function\n–Other functions for operations with VM")]),e._v(" "),n("li",[e._v("Compiler")]),e._v(" "),n("li",[e._v("Lexical analyzer\n–lextable/lextable.go\n–lex.go")]),e._v(" "),n("li",[e._v("V-Logic language\n–Lexemes\n–Types\n–Expressions\n–Scope\n–Contract execution\n–Backus–Naur Form (BNF)\nThis section involves program compilation and V-Logic language operations in the Virtual Machine (VM).\nSource code storage and compilation")])]),e._v(" "),n("p",[e._v("Contracts and functions are written with Golang and stored in the contract tables of ecosystems.")]),e._v(" "),n("p",[e._v("When a contract is executed, its source code will be read from the database and compiled into bytecode.")]),e._v(" "),n("p",[e._v("When a contract is changed, its source code will be updated and saved in the database. Then, the source code is compiled, thereby updating the bytecode in the corresponding virtual machine.")]),e._v(" "),n("p",[e._v("As bytecodes are not physically saved, it will be compiled anew when the program is executed again.")]),e._v(" "),n("p",[e._v("The entire source code described in the contract table of each ecosystem is compiled into a virtual machine in strict order, and the status of the virtual machine is the same on all nodes.")]),e._v(" "),n("p",[e._v("When the contract is called, the virtual machine will not change its status in any way. The execution of any contract or calling of any function occurs on a separate running stack created during each external call.")]),e._v(" "),n("p",[e._v("Each ecosystem can have a so-called virtual ecosystem, which can be used within a node in conjunction with tables outside the blockchain, without direct affection on the blockchain or other virtual ecosystems. In this case, the node hosting such a virtual ecosystem will compile its contract and create its own virtual machine.\nVirtual machine structures\nVM Structure")]),e._v(" "),n("p",[e._v("A virtual machine is organized in memory as a structure like below.")]),e._v(" "),n("p",[e._v("type VM struct {\nBlock\nExtCost func(string) int64\nFuncCallsDB map[string]struct{}\nExtern bool\nShiftContract int64\nlogger *log.Entry\n}")]),e._v(" "),n("p",[e._v("A VM structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Block - contains a block structure;")]),e._v(" "),n("li",[e._v("ExtCost - a function returns the cost of executing an external golang function;")]),e._v(" "),n("li",[e._v("FuncCallsDB - a collection of Golang function names. This function returns the execution cost as the first parameter. These functions use EXPLAIN to calculate the cost of database processing;")]),e._v(" "),n("li",[e._v("Extern - a Boolean flag indicating whether a contract is an external contract. It is set to true when a VM is created. Contracts called are not displayed when the code is compiled. In other words, it allows to call the contract code determined in the future;")]),e._v(" "),n("li",[e._v("ShiftContract - ID of the first contract in the VM;")]),e._v(" "),n("li",[e._v("logger - VM error log output.")])]),e._v(" "),n("p",[e._v("Block structure")]),e._v(" "),n("p",[e._v("A virtual machine is a tree composed of Block type objects.")]),e._v(" "),n("p",[e._v("A block is an independent unit that contains some bytecodes. In simple terms, everything you put in the braces ({}) in the language is a block.")]),e._v(" "),n("p",[e._v("For example, the following code would create a block with functions. This block also contains another block with an if statement, which contains a block with a while statement.")]),e._v(" "),n("p",[e._v("func my() {\nif true {\nwhile false {\n...\n}\n}\n}\nThe block is organized in the memory as a structure like below.\ntype Block struct {\nObjects map[string]*ObjInfo\nType int\nOwner *OwnerInfo\nInfo interface{}\nParent *Block\nVars []reflect.Type\nCode ByteCodes\nChildren Blocks\n}")]),e._v(" "),n("p",[e._v("A block structure consists of the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Objects - a map of internal objects of the pointer type ObjInfo. For example, if there is a variable in the block, you can get information about it by its name;")]),e._v(" "),n("li",[e._v("Type - the type of the block. For a function block, its type is ObjFunc; for a contract block, its type is ObjContract;")]),e._v(" "),n("li",[e._v("Owner - a structure of OwnerInfo pointer type. This structure contains information about the owner of the compiled contract, which is specified during contract compilation or obtained from the contracts table;")]),e._v(" "),n("li",[e._v("Info - it contains information about the object, which depends on the block type;")]),e._v(" "),n("li",[e._v("Parent - a pointer to the parent block;")]),e._v(" "),n("li",[e._v("Vars - an array containing the types of current block variables;")]),e._v(" "),n("li",[e._v("Code - the bytecode of the block itself, which will be executed when the control rights are passed to the block, for example, function calls or loop bodies;")]),e._v(" "),n("li",[e._v("Children - an array containing sub-blocks, such as function nesting, loops, conditional operators.")])]),e._v(" "),n("p",[e._v("ObjInfo structure")]),e._v(" "),n("p",[e._v("The ObjInfo structure contains information about internal objects.")]),e._v(" "),n("p",[e._v("type ObjInfo struct {\nType int\nValue interface{}\n}")]),e._v(" "),n("p",[e._v("The ObjInfo structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Type is the object type, which has any of the following values:")]),e._v(" "),n("li",[e._v("ObjContract – contract;")]),e._v(" "),n("li",[e._v("ObjFunc - function;")]),e._v(" "),n("li",[e._v("ObjExtFunc - external golang function;")]),e._v(" "),n("li",[e._v("ObjVar - variable;")]),e._v(" "),n("li",[e._v("ObjExtend - $name variable.")]),e._v(" "),n("li",[e._v("Value – it contains the structure of each type.")])]),e._v(" "),n("p",[e._v("ContractInfo structure")]),e._v(" "),n("p",[e._v("Pointing to the ObjContract type, and the Value field contains a ContractInfo structure.")]),e._v(" "),n("p",[e._v("type ContractInfo struct {\nID uint32\nName string\nOwner *OwnerInfo\nUsed map[string]bool\nTx *[]*FieldInfo\n}")]),e._v(" "),n("p",[e._v("The ContractInfo structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("ID - contract ID, displayed in the blockchain when calling the contract;")]),e._v(" "),n("li",[e._v("Name - contract name;")]),e._v(" "),n("li",[e._v("Owner - other information about the contract;")]),e._v(" "),n("li",[e._v("Used - map of contracts names that has been called;")]),e._v(" "),n("li",[e._v("Tx - a data array described in the data section of the contract.")])]),e._v(" "),n("p",[e._v("FieldInfo structure")]),e._v(" "),n("p",[e._v("The FieldInfo structure is used in the ContractInfo structure and describes elements in data of a contract.")]),e._v(" "),n("p",[e._v("type FieldInfo struct {\nName string\nType reflect.Type\nOriginal uint32\nTags string\n}")]),e._v(" "),n("p",[e._v("The FieldInfo structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Name - field name;")]),e._v(" "),n("li",[e._v("Type - field type;")]),e._v(" "),n("li",[e._v("Original - optional field;")]),e._v(" "),n("li",[e._v("Tags - additional labels for this field.")])]),e._v(" "),n("p",[e._v("FuncInfo structure")]),e._v(" "),n("p",[e._v("Pointing to the ObjFunc type, and the Value field contains a FuncInfo structure.")]),e._v(" "),n("p",[e._v("type FuncInfo struct {\nParams []reflect.Type\nResults []reflect.Type\nNames *map[string]FuncName\nVariadic bool\nID uint32\n}")]),e._v(" "),n("p",[e._v("The FuncInfo structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Params - an array of parameter types;")]),e._v(" "),n("li",[e._v("Results - an array of returned types;")]),e._v(" "),n("li",[e._v("Names - map of data for tail functions, for example, DBFind().Columns ();")]),e._v(" "),n("li",[e._v("Variadic - true if the function can have a variable number of parameters;")]),e._v(" "),n("li",[e._v("ID - function ID.")])]),e._v(" "),n("p",[e._v("FuncName Structure")]),e._v(" "),n("p",[e._v("The FuncName structure is used for FuncInfo and describes the data of a tail function.")]),e._v(" "),n("p",[e._v("type FuncName struct {\nParams []reflect.Type\nOffset []int\nVariadic bool\n}")]),e._v(" "),n("p",[e._v("The FuncName structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Params - an array of parameter types;")]),e._v(" "),n("li",[e._v("Offset - the array of offsets for these variables. In fact, the values of all parameters in a function can be initialized with the dot .;")]),e._v(" "),n("li",[e._v("Variadic - true if the tail function can have a variable number of parameters.")])]),e._v(" "),n("p",[e._v("ExtFuncInfo structure")]),e._v(" "),n("p",[e._v("Pointing to the ObjExtFunc type, and the Value field contains a ExtFuncInfo structure. It is used to describe golang functions.")]),e._v(" "),n("p",[e._v("type ExtFuncInfo struct {\nName string\nParams []reflect.Type\nResults []reflect.Type\nAuto []string\nVariadic bool\nFunc interface{}\n}")]),e._v(" "),n("p",[e._v("The ExtFuncInfo structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Name, Params, Results parameters have the same structure as FuncInfo;")]),e._v(" "),n("li",[e._v("Auto - an array of variables. If any, passes to the function as an additional parameter. For example, a variable of type SmartContract sc;")]),e._v(" "),n("li",[e._v("Func - golang functions.")])]),e._v(" "),n("p",[e._v("VarInfo structure")]),e._v(" "),n("p",[e._v("Pointing to the ObjVar type, and the Value field contains a VarInfo structure.")]),e._v(" "),n("p",[e._v("type VarInfo struct {\nObj *ObjInfo\nOwner *Block\n}")]),e._v(" "),n("p",[e._v("The VarInfo structure has the following elements:")]),e._v(" "),n("ul",[n("li",[e._v("Obj - information about the type and value of the variable;")]),e._v(" "),n("li",[e._v("Owner - Pointer to the owner block.")])]),e._v(" "),n("p",[e._v("ObjExtend value")]),e._v(" "),n("p",[e._v("Pointing to the ObjExtend type, and the Value field contains a string containing the name of the variable or function.\nVirtual machine commands\nByteCode structure")]),e._v(" "),n("p",[e._v("A bytecode is a sequence of ByteCode type structures.")]),e._v(" "),n("p",[e._v("type ByteCode struct {\nCmd uint16\nValue interface{}\n}")]),e._v(" "),n("p",[e._v("This structure has the following fields:")]),e._v(" "),n("ul",[n("li",[e._v("Cmd - the identifier of the storage commands;")]),e._v(" "),n("li",[e._v("Value - contains the operand (value).")])]),e._v(" "),n("p",[e._v("In general, commands perform an operation on the top element of the stack and writes the result value into it if necessary.\nCommand identifiers")]),e._v(" "),n("p",[e._v("Identifiers of the virtual machine commands are described in the vm/cmds_list.go file.")]),e._v(" "),n("ul",[n("li",[e._v("cmdPush – put a value from the Value field to the stack. For example, put numbers and lines to the stack;")]),e._v(" "),n("li",[e._v("cmdVar - put the value of a variable to the stack. Value contains a pointer to the VarInfo structure and information about the variable;")]),e._v(" "),n("li",[e._v("cmdExtend – put the value of an external variable to the stack. Value contains a string with the variable name (starting with $);")]),e._v(" "),n("li",[e._v("cmdCallExtend – call an external function (starting with $). The parameters of the function are obtained from the stack, and the results are placed to the stack. Value contains a function name (starting with $);")]),e._v(" "),n("li",[e._v("cmdPushStr – put the string in Value to the stack;")]),e._v(" "),n("li",[e._v("cmdCall - calls the virtual machine function. Value contains a ObjInfo structure. This command is applicable to the ObjExtFunc golang function and ObjFunc V-Logic function. If a function is called, its parameters will be obtained from the stack and the result values will be placed to the stack;")]),e._v(" "),n("li",[e._v("cmdCallVari - similar to the cmdCall command, it calls the virtual machine function. This command is used to call a function with a variable number of parameters;")]),e._v(" "),n("li",[e._v("cmdReturn - used to exit the function. The return values will be put to the stack, and the Value field is not used;")]),e._v(" "),n("li",[e._v("cmdIf – transfer control to the bytecode in the block structure, which is passed in the Value field. The control will be transferred to the stack only when the top element of the stack is called by the valueToBool function and returned true. Otherwise, the control will be transferred to the next command;")]),e._v(" "),n("li",[e._v("cmdElse - this command works in the same way as the cmdIf, but only when the top element of the stack is called by the valueToBool function and returned false, the control will be transferred to the specified block;")]),e._v(" "),n("li",[e._v("cmdAssignVar – get a list of variables of type VarInfo from Value. These variables use the cmdAssign command to get the value;")]),e._v(" "),n("li",[e._v("cmdAssign – assign the value in the stack to the variable obtained by the cmdAssignVar command;")]),e._v(" "),n("li",[e._v("cmdLabel - defines a label when control is returned during the while loop;")]),e._v(" "),n("li",[e._v("cmdContinue - this command transfers control to the cmdLabel label. When executing a new iteration of the loop, Value is not used;")]),e._v(" "),n("li",[e._v("cmdWhile – use valueToBool to check the top element of the stack. If this value is true, the block structure will be called from the value field;")]),e._v(" "),n("li",[e._v("cmdBreak - exits the loop;")]),e._v(" "),n("li",[e._v("cmdIndex – put the value in map or array into the stack by index, without using Value. For example, (map | array) (index value) => (map | array [index value]);")]),e._v(" "),n("li",[e._v("cmdSetIndex – assigns the value of the top element of the stack to elements of map or array, without using Value. For example, (map | array) (index value) (value) => (map | array);")]),e._v(" "),n("li",[e._v("cmdFuncName - adds parameters that are passed using sequential descriptions divided by dot . For example, func name => Func (...) .Name (...);")]),e._v(" "),n("li",[e._v("cmdUnwrapArr - defines a Boolean flag if the top element of the stack is an array;")]),e._v(" "),n("li",[e._v("cmdMapInit – initializes the value of map;")]),e._v(" "),n("li",[e._v("cmdArrayInit – initializes the value of array;")]),e._v(" "),n("li",[e._v("cmdError - this command is created when a contract or function terminates with a specified error, warning, info.")])]),e._v(" "),n("p",[e._v("Stack operation commands")]),e._v(" "),n("p",[e._v("Note")]),e._v(" "),n("p",[e._v("In the current version, automatic type conversion is not fully applicable for these commands. For example, string + float | int | decimal => float | int | decimal, float + int | str => float, but int + string => runtime error.")]),e._v(" "),n("p",[e._v("The following are commands for direct stack processing. The Value field is not used in these commands.")]),e._v(" "),n("ul",[n("li",[e._v("cmdNot - logical negation. (val) => (!ValueToBool(val));")]),e._v(" "),n("li",[e._v("cmdSign - change of sign. (val) => (-val);")]),e._v(" "),n("li",[e._v("cmdAdd - addition. (val1)(val2) => (val1 + val2);")]),e._v(" "),n("li",[e._v("cmdSub - subtraction. (val1)(val2) => (val1-val2);")]),e._v(" "),n("li",[e._v("cmdMul - multiplication. (val1)(val2) => (val1 * val2);")]),e._v(" "),n("li",[e._v("cmdDiv - division. (val1)(val2) => (val1 / val2);")]),e._v(" "),n("li",[e._v("cmdAnd - logical AND. (val1)(val2) => (valueToBool(val1) && valueToBool(val2));")]),e._v(" "),n("li",[e._v("cmdOr - logical OR. (val1)(val2) => (valueToBool(val1) || valueToBool(val2));")]),e._v(" "),n("li",[e._v("cmdEqual - equality comparison, bool is returned. (val1)(val2) => (val1 == val2);")]),e._v(" "),n("li",[e._v("cmdNotEq - inequality comparison, bool is returned. (val1)(val2) => (val1 != val2);")]),e._v(" "),n("li",[e._v("cmdLess - less-than comparison, bool is returned. (val1)(val2) => (val1 <val2);")]),e._v(" "),n("li",[e._v("cmdNotLess - greater-than-or-equal comparison, bool is returned. (val1)(val2) => (val1 >= val2);")]),e._v(" "),n("li",[e._v("cmdGreat - greater-than comparison, bool is returned. (val1)(val2) => (val1> val2);")]),e._v(" "),n("li",[e._v("cmdNotGreat - less-than-or-equal comparison, bool is returned. (val1)(val2) => (val1 <= val2).")])]),e._v(" "),n("p",[e._v("Runtime structure")]),e._v(" "),n("p",[e._v("The execution of bytecodes will not affect the virtual machine. For example, it allows various functions and contracts to run simultaneously in a single virtual machine. The Runtime structure is used to run functions and contracts, as well as any expressions and bytecode.")]),e._v(" "),n("p",[e._v("type RunTime struct {\nstack []interface{}\nblocks []*blockStack\nvars []interface{}\nextend *map[string]interface{}\nvm *VM\ncost int64\nerr error\n}")]),e._v(" "),n("ul",[n("li",[e._v("stack - the stack to execute the bytecode;")]),e._v(" "),n("li",[e._v("blocks - block calls stack;")]),e._v(" "),n("li",[e._v("vars - stack of variables. Its variable will be added to the stack of variables when the bytecode is called in the block. After exiting the block, the size of the stack of variables will return to the previous value;")]),e._v(" "),n("li",[e._v("extend - a pointer to map with values of external variables ($name);")]),e._v(" "),n("li",[e._v("vm - a virtual machine pointer;")]),e._v(" "),n("li",[e._v("cost - fuel unit of the resulting cost of execution;")]),e._v(" "),n("li",[e._v("err - error occurred during execution.")])]),e._v(" "),n("p",[e._v("blockStack structure")]),e._v(" "),n("p",[e._v("The blockStack structure is used in the Runtime structure.")]),e._v(" "),n("p",[e._v("type blockStack struct {\nBlock *Block\nOffset int\n}")]),e._v(" "),n("ul",[n("li",[e._v("Block - a pointer to the block being executed;")]),e._v(" "),n("li",[e._v("Offset – the offset of the last command executed in the bytecode of the specified block.")])]),e._v(" "),n("p",[e._v("RunCode function")]),e._v(" "),n("p",[e._v("Bytecodes are executed in the RunCode function. It contains a loop that performs the corresponding operation for each bytecode command. Before processing a bytecode, the data required must be initialized.")]),e._v(" "),n("p",[e._v("New blocks are added to other blocks.")]),e._v(" "),n("p",[e._v("rt.blocks = append(rt.blocks, &blockStack{block, len(rt.vars)})")]),e._v(" "),n("p",[e._v("Next, get the information of relevant parameters of the tail function. These parameters are contained in the last element of the stack.\nvar namemap map[string][]interface{}\nif block.Type == ObjFunc && block.Info.(*FuncInfo).Names != nil {\nif rt.stack[len(rt.stack)-1] != nil {\nnamemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})\n}\nrt.stack = rt.stack[:len(rt.stack)-1]\n}\nThen, all variables defined in the current block must be initialized with their initial values.\nstart := len(rt.stack)\nvaroff := len(rt.vars)\nfor vkey, vpar := range block.Vars {\nrt.cost--\nvar value interface{}\nSince variables in the function are also variables, we need to retrieve them from the last element of the stack in the order described by the function itself.")]),e._v(" "),n("p",[e._v("if block.Type == ObjFunc && vkey <len(block.Info.(*FuncInfo).Params) {\nvalue = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]\n} else {")]),e._v(" "),n("p",[e._v("Initialize local variables with their initial values.")]),e._v(" "),n("p",[e._v("value = reflect.New(vpar).Elem().Interface()")]),e._v(" "),n("p",[e._v("if vpar == reflect.TypeOf(map[string]interface{}{}) {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("value \\= make(map\\[string\\]interface{})\n")])])]),n("p",[e._v("} else if vpar == reflect.TypeOf([]interface{}{}) {\nvalue = make([]interface{}, 0, len(rt.vars)+1)\n}\n}\nrt.vars = append(rt.vars, value)\n}\nNext, update the values of variable parameters passed in the tail function.\nif namemap != nil {\nfor key, item := range namemap {\nparams := (*block.Info.(*FuncInfo).Names)[key]\nfor i, value := range item {\nif params.Variadic && i >= len(params.Params)-1 {\nIf variable parameters passed belongs to a variable number of parameters, then these parameters will be combined into an array of variables.\noff := varoff + params.Offset[len(params.Params)-1]\nrt.vars[off] = append(rt.vars[off].([]interface{}), value)\n} else {\nrt.vars[varoff+params.Offset[i]] = value\n}\n}\n}\n}\nAfter that, all we have to do is delete values passed from the top of the stack as function parameters, thereby moving the stack. We have copied their values into a variable array.")]),e._v(" "),n("p",[e._v("if block.Type == ObjFunc {\nstart -= len(block.Info.(*FuncInfo).Params)\n}")]),e._v(" "),n("p",[e._v("When a bytecode command loop finished, we must clear the stack correctly.")]),e._v(" "),n("p",[e._v("last := rt.blocks[len(rt.blocks)-1]")]),e._v(" "),n("p",[e._v("Delete the current block from the stack of blocks.")]),e._v(" "),n("p",[e._v("rt.blocks = rt.blocks[:len(rt.blocks)-1]\nif status == statusReturn {\nIf successfully exited from a function already executed, we will add the return value to the end of the previous stack.\nif last.Block.Type == ObjFunc {\nfor count := len(last.Block.Info.(*FuncInfo).Results); count > 0; count-- {\nrt.stack[start] = rt.stack[len(rt.stack)-count]\nstart++\n}\nstatus = statusNormal\n} else {")]),e._v(" "),n("p",[e._v("As you can see, if we do not execute the function, then we will not restore the stack status and exit the function as is. The reason is that loops and conditional structures that have been executed in the function are also bytecode blocks.")]),e._v(" "),n("p",[e._v("return")]),e._v(" "),n("p",[e._v("}\n}\nrt.stack = rt.stack[:start]\nOther functions for operations with VM")]),e._v(" "),n("p",[e._v("Your may create a virtual machine with the NewVM function. Each virtual machine will be added with four functions, such as ExecContract, MemoryUsage, CallContract, and Settings, through the Extend function.")]),e._v(" "),n("p",[e._v("for key, item := range ext.Objects {\nfobj := reflect.ValueOf(item).Type()")]),e._v(" "),n("p",[e._v("We traverse all the objects passed and only look at the functions.")]),e._v(" "),n("p",[e._v("switch fobj.Kind() {\ncase reflect.Func:\nWe fill the ExtFuncInfo structure according to the information received about the function, and add its structure to the top level map Objects by name.")]),e._v(" "),n("p",[e._v("data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),\nmake([]string, fobj.NumIn()), fobj.IsVariadic(), item}\nfor i := 0; i <fobj.NumIn(); i++ {")]),e._v(" "),n("p",[e._v("The ExtFuncInfo structure has an Auto parameter array. Usually the first parameter is sc *SmartContract or rt *Runtime, we cannot pass them from the V-Logic language, because they are necessary for us to execute some golang functions. Therefore, we specify that these variables will be used automatically when these functions are called. In this case, the first parameter of the above four functions is rt *Runtime.")]),e._v(" "),n("p",[e._v("if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {\ndata.Auto[i] = isauto\n}")]),e._v(" "),n("p",[e._v("Information about assigning the parameters.\ndata.Params[i] = fobj.In(i)\n}\nAnd the types of return values.\nfor i := 0; i <fobj.NumOut(); i++ {\ndata.Results[i] = fobj.Out(i)\n}\nAdds a function to the root Objects so that the compiler can find them later when using the contract.\nvm.Objects[key] = &ObjInfo{ObjExtFunc, data}\n}")]),e._v(" "),n("p",[e._v("}\nCompiler")]),e._v(" "),n("p",[e._v("Functions in the compile.go file are responsible for compiling the array of tokens obtained from the lexical analyzer. Compilation can be divided into two levels conditionally. At the top level, we deal with functions, contracts, code blocks, conditional and loop statements, variable definitions, and so on. At the lower level, we compile expressions in code blocks or conditions in loops and conditional statements.")]),e._v(" "),n("p",[e._v("First, we will start from the simple lower level. In the compileEval function, expressions can be converted to bytecode. Since we use a virtual machine with a stack, it is necessary to convert ordinary infix record expressions into postfix notation or reverse Polish notation. For example, we convert 1+2 to 12+ and put 1 and 2 to the stack. Then, we apply the addition operation to the last two elements in the stack and write the result to the stack. You can find this conversion algorithm on the Internet.")]),e._v(" "),n("p",[e._v("The global variable opers = map [uint32] operPrior contains the priority of operations required for conversion to inverse Polish notation.")]),e._v(" "),n("p",[e._v("The following variables are defined at the beginning of the compileEval function:")]),e._v(" "),n("ul",[n("li",[e._v("buffer - temporary buffer for bytecode commands;")]),e._v(" "),n("li",[e._v("bytecode - final buffer of bytecode commands;")]),e._v(" "),n("li",[e._v("parcount - temporary buffer used to calculate parameters when calling a function;")]),e._v(" "),n("li",[e._v('setIndex - variables in the work process will be set to true when we assign map or array elements. For example, a["my"] = 10. In this case, we need to use the specified cmdSetIndex command.')])]),e._v(" "),n("p",[e._v("We get a token in a loop and process it accordingly. For example, expression paring will be stopped if braces are found. When moving the string, we check whether the previous statement is an operation and whether it is inside the parentheses, otherwise it will exit the expression is parsed.")]),e._v(" "),n("p",[e._v("case isRCurly, isLCurly:\ni--\nif prevLex == isComma || prevLex == lexOper {\nreturn errEndExp\n}\nbreak main\ncase lexNewLine:\nif i > 0 && ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {\ncontinue main\n}\nfor k := len(buffer) - 1; k >= 0; k-- {\nif buffer[k].Cmd == cmdSys {\ncontinue main\n}\n}\nbreak main")]),e._v(" "),n("p",[e._v("In general, the algorithm itself corresponds to an algorithm for converting to inverse Polish notation. With the consideration of the calling of necessary contracts, functions, and indexes, as well as other things not encountered during parsing and options for parsing lexIdent type tokens, then, variables, functions or contracts with this name will be checked. If nothing is found and this is not a function or contract call, then it will indicate an error.")]),e._v(" "),n("p",[e._v("objInfo, tobj := vm.findObj(lexem.Value.(string), block)\nif objInfo == nil && (!vm.Extern || i> *ind || i >= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {\nreturn fmt.Errorf(\\ʻunknown identifier %s`, lexem.Value.(string))\n}")]),e._v(" "),n("p",[e._v("We may encounter such a situation, and the contract call will be described later. In this example, if no functions or variables with the same name are found, then we think it is necessary to call a contract. In this compiled language, there is no difference between contracts and function calls. But we need to call the contract through the ExecContract function used in the bytecode.\nif objInfo.Type == ObjContract {\nif objInfo.Value != nil {\nobjContract = objInfo.Value.(*Block)\n}\nobjInfo, tobj = vm.findObj(\\ʻExecContract`, block)\nisContract = true\n}")]),e._v(" "),n("p",[e._v("We record the number of variables so far in count, which will also be written to the stack along with the number of function parameters. In each subsequent detection of parameters, we only need to increase this number by one unit at the last element of the stack.")]),e._v(" "),n("p",[e._v("count := 0\nif (*lexems)[i+2].Type != isRPar {\ncount++\n}")]),e._v(" "),n("p",[e._v('We have a list Used of called parameters for contracts, then we need to mark the case of the contract is called. If the contract is called without parameters, we must add two empty parameters to call ExecContract to get at least two parameters.\nif isContract {\nname := StateName((*block)[0].Info.(uint32), lexem.Value.(string))\nfor j := len(*block) - 1; j >= 0; j-- {\ntopblock := (*block)[j]\nif topblock.Type == ObjContract {\nif topblock.Info.(*ContractInfo).Used == nil {\ntopblock.Info.(*ContractInfo).Used = make(map[string]bool)\n}\ntopblock.Info.(*ContractInfo).Used[name] = true\n}\n}\nbytecode = append(bytecode, &ByteCode{cmdPush, name})\nif count == 0 {\ncount = 2\nbytecode = append(bytecode, &ByteCode{cmdPush, ""})\nbytecode = append(bytecode, &ByteCode{cmdPush, ""})\n}\ncount++\n}\nIf we see that there is a square bracket next, then we add the cmdIndex command to get the value by the index.\nif (*lexems)[i+1].Type == isLBrack {\nif objInfo == nil || objInfo.Type != ObjVar {\nreturn fmt.Errorf(\\ʻunknown variable %s`, lexem.Value.(string))\n}\nbuffer = append(buffer, &ByteCode{cmdIndex, 0})\n}\nThe CompileBlock function can generate object trees and expression-independent bytecodes. The compilation process is based on a finite state machine, just like a lexical analyzer, but with the following differences. First, we do not use symbols but tokens; second, we will immediately describe the states variables in all states and transitions. It represents an array of objects indexed by token type. Each token has a structure of compileState, and a new state is specified in NewState. If it is clear what structure we have resolved, we can specify the function of the handler in the Func field.\nLet us review the main state as an example.\nIf we encounter a newline or comment, then we will remain in the same state. If we encounter the contract keyword, then we change the state to stateContract and start parsing the structure. If we encounter the func keyword, then we change the state to stateFunc. If other tokens are received, the function generating error will be called.\n{// stateRoot\nlexNewLine: {stateRoot, 0},\nlexKeyword | (keyContract << 8): {stateContract | statePush, 0},\nlexKeyword | (keyFunc << 8): {stateFunc | statePush, 0},\nlexComment: {stateRoot, 0},\n0: {errUnknownCmd, cfError},\n},\nSuppose we encountered the func keyword and we have changed the state to stateFunc. Since the function name must follow the func keyword, we will keep the same state when changing the function name. For all other tokens, we will generate corresponding errors. If we get the function name in the token identifier, then we go to the stateFParams state, where we can get the parameters of the function.\n{// stateFunc\nlexNewLine: {stateFunc, 0},\nlexIdent: {stateFParams, cfNameBlock},\n0: {errMustName, cfError},\n},\nAt the same time as the above operations, we will call the fNameBlock function. It should be noted that the Block structure is created with the statePush mark, where we get it from the buffer and fill it with the data we need. The fNameBlock function is suitable for contracts and functions (including those nested in them). It fills the Info field with the corresponding structure and writes itself into the Objects of the parent block. In this way, we can call the function or contract with the specified name. Similarly, we create corresponding functions for all states and variables. These functions are usually very small and perform some duties when constructing the virtual machine tree.\nfunc fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {\nvar itype int\nprev := (*buf)[len(*buf)-2]\nfblock := (*buf)[len(*buf)-1]\nname := lexem.Value.(string)\nswitch state {\ncase stateBlock:\nitype = ObjContract\nname = StateName((*buf)[0].Info.(uint32), name)\nfblock.Info = &ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,\nOwner: (*buf)[0].Owner}\ndefault:\nitype = ObjFunc\nfblock.Info = &FuncInfo{}\n}\nfblock.Type = itype\nprev.Objects[name] = &ObjInfo{Type: itype, Value: fblock}\nreturn nil\n}')]),e._v(" "),n("p",[e._v("For the CompileBlock function, it just traverses all the tokens and switches states according to the tokens described in states. Almost all additional tokens correspond to additional program codes.")]),e._v(" "),n("ul",[n("li",[e._v("statePush – adds the Block object to the object tree;")]),e._v(" "),n("li",[e._v("statePop - used when the block ends with a closing brace;")]),e._v(" "),n("li",[e._v("stateStay - you need to keep the current mark when changing to a new state;")]),e._v(" "),n("li",[e._v("stateToBlock - transition to the stateBlock state for processing while and if. After processing expressions, you need to process blocks within the braces;")]),e._v(" "),n("li",[e._v("stateToBody - transition to the stateBody state;")]),e._v(" "),n("li",[e._v("stateFork - save the marked position. When the expression starts with an identifier or a name with $, we can make function calls or assignments;")]),e._v(" "),n("li",[e._v("stateToFork – used to get the token stored in stateFork, which will be passed to the process function;")]),e._v(" "),n("li",[e._v("stateLabel – used to insert cmdLabel commands. while structure requires this flag;")]),e._v(" "),n("li",[e._v("stateMustEval – check the availability of conditional expressions at the beginning of if and while structures.")])]),e._v(" "),n("p",[e._v("In addition to the CompileBlock function, the FlushBlock function should also be mentioned. But the problem is that the block tree is constructed independently of existing virtual machines. More precisely, we obtain information about functions and contracts that exist in a virtual machine, but we collect the compiled blocks into a separate tree. Otherwise, if an error occurs during compilation, we must roll back the virtual machine to the previous state. Therefore, we go to the compilation tree separately, but after the compilation is successful, the FlushContract function must be called. This function adds the completed block tree to the current virtual machine. The compilation phase is now complete.\nLexical analyzer")]),e._v(" "),n("p",[e._v("The lexical analyzer processes incoming strings and forms a sequence of tokens of the following types :")]),e._v(" "),n("ul",[n("li",[e._v("lexSys - system token, for example: {}, [], (), ,, . etc;")]),e._v(" "),n("li",[e._v("lexOper - operation token, for example: +, -, /, , *;")]),e._v(" "),n("li",[e._v("lexNumber - number;")]),e._v(" "),n("li",[e._v("lexident - identifier;")]),e._v(" "),n("li",[e._v("lexNewline - newline character;")]),e._v(" "),n("li",[e._v("lexString - string;")]),e._v(" "),n("li",[e._v("lexComment - comment;")]),e._v(" "),n("li",[e._v("lexKeyword - keyword;")]),e._v(" "),n("li",[e._v("lexType - type;")]),e._v(" "),n("li",[e._v("lexExtend - reference to external variables or functions, for example: $myname.")])]),e._v(" "),n("p",[e._v("In the current version, a conversion table (finite state machine) is initially constructed with the help of the script/lextable/lextable.go file to parse the tokens, which is written to the lex_table.go file. In general, you can get rid of the conversion table initially generated by the file and create a conversion table in the memory (init()) immediately upon startup. The lexical analysis itself occurs in the lexParser function in the lex.go file.\nlextable/lextable.go")]),e._v(" "),n("p",[e._v("Here we define the alphabet to operate and describe how the finite state machine changes from one state to another based on the next received symbol.")]),e._v(" "),n("p",[e._v("states is a JSON object containing a list of states.")]),e._v(" "),n("p",[e._v("Except for specific symbols, d stands for all symbols not specified in the state.\nn stands for 0x0a, s stands for space, q stands for backquote, Q stands for double quote, r stands for character >= 128, a stands for AZ and az, and 1 stands for 1- 9.")]),e._v(" "),n("p",[e._v("The name of these states are keys, and the possible values are listed in the value object. Then, there is a new state to make transitions for each group. Then there is the name of the token. If we need to return to the initial state, the third parameter is the service token, which indicates how to handle the current symbol.")]),e._v(" "),n("p",[e._v('For example, we have the main state and the incoming characters /, "/": ["solidus", "", "push next"],')]),e._v(" "),n("ul",[n("li",[e._v("push - gives the command to remember that it is in a separate stack ;")]),e._v(" "),n("li",[e._v("next - goes to the next character, and at the same time we change the status to solidus. After that, gets the next character and check the status of solidus.")])]),e._v(" "),n("p",[e._v("If the next character has / or /"),n("em",[e._v(", then we go to the comment comment state because they start with // or /")]),e._v(". Obviously, each comment has a different state afterwards, because they end with a different symbol.")]),e._v(" "),n("p",[e._v("If the next character is not / and *, then we record everything in the stack as lexOper type tags, clear the stack and return to the main state.")]),e._v(" "),n("p",[e._v("The following module converts the state tree into a numeric array and writes it into the lex_table.go file.\nIn the first loop:\nWe form an alphabet of valid symbols.\nfor ind, ch := range alphabet {\ni := byte(ind)\nIn addition, in state2int, we provide each state with its own sequence identifier.\nstate2int := map[string]uint{"),n("code",[e._v("main")]),e._v(": 0}\nif err := json.Unmarshal([]byte(states), &data); err == nil {\nfor key := range data {\nif key != "),n("code",[e._v("main")]),e._v(" {\nstate2int[key] = uint(len(state2int))\nWhen we traverse all states and each set in a state and each symbol in a set, we write a three-byte number [new state identifier (0 = main)] + [token type ( 0-no token)] + [token].\nThe bidimensionality of the table array is that it is divided into states and 34 input symbols from the alphabet array, which are arranged in the same order.\nWe are in the main state on the zero row of the table. Take the first character, find its index in the alphabet array, and get the value from the column with the given index. Starting from the value received, we receive the token in the low byte. If the parsing is complete, the second byte indicates the type of token received. In the third byte, we receive the index of the next new state.\nAll of these are described in more detail in the lexParser function in lex.go.\nIf you want to add some new characters, you need to add them to the alphabet array and increase the quantity of the AlphaSize constant. If you want to add a new symbol combination, it should be described in the status, similar to the existing options. After the above operation, run the lextable.go file to update the lex_table.go file.\nlex.go\nThe lexParser function directly generates lexical analysis and returns an array of received tags based on incoming strings. Let us analyze the structure of tokens.\ntype Lexem struct {\nType uint32 // Type of the lexem\nValue interface{} // Value of lexem\nLine uint32 // Line of the lexem\nColumn uint32 // Position inside the line\n}")]),e._v(" "),n("ul",[n("li",[e._v("Type - token type. It has one of the following values: lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend;")]),e._v(" "),n("li",[e._v("Value – token value. The type of value depends on the token type, Let us analyze it in more detail:\n–lexSys - includes brackets, commas, etc. In this case, Type = ch << 8 | lexSys, please refer to the isLPar ... isRBrack constant, and its value is uint32 bits;\n–lexOper - the value represents an equivalent character sequence in the form of uint32. See the isNot ... isOr constants;\n–lexNumber - numbers are stored as int64 or float64. If the number has a decimal point, it is float64;\n–lexIdent - identifiers are stored as string;\n–lexNewLine - newline character. Also used to calculate the row and token position;\n–lexString - lines are stored as string;\n–lexComment - comments are stored as string;\n–lexKeyword - for keywords, only the corresponding indexes are stored, see the keyContract ... keyTail constant. In this case Type = KeyID << 8 | lexKeyword. In addition, it should be noted that the true, false, nil keywords will be immediately converted to lexNumber type tokens, and the corresponding bool and intreface {} types will be used;\n–lexType – this value contains the corresponding reflect.Type type value;\n–lexExtend – identifiers beginning with a $. These variables and functions are passed from the outside and are therefore assigned to special types of tokens. This value contains the name as a string without a $ at the beginning.")]),e._v(" "),n("li",[e._v("Line - the line where the token is found;")]),e._v(" "),n("li",[e._v("Column - in-line position of the token.")])]),e._v(" "),n("p",[e._v("Let us analyze the lexParser function in detail. The todo function looks up the symbol index in the alphabet based on the current state and the incoming symbol, and obtains a new state, token identifier (if any), and other tokens from the conversion table. The parsing itself involves calling the todo function in turn for each next character and switching to a new state. Once the tag is received, we create the corresponding token in the output criteria and continue the parsing process. It should be noted that during the parsing process, we do not accumulate the token symbols into a separate stack or array, because we only save the offset of the start of the token. After getting the token, we move the offset of the next token to the current parsing position.")]),e._v(" "),n("p",[e._v("All that remains is to check the lexical status tokens used in the parsing:")]),e._v(" "),n("ul",[n("li",[e._v("lexfPush - this token means that we start to accumulate symbols in a new token;")]),e._v(" "),n("li",[e._v("lexfNext - the character must be added to the current token;")]),e._v(" "),n("li",[e._v("lexfPop - the receipt of the token is complete. Usually, with this flag we have the identifier type of the parsed token;")]),e._v(" "),n("li",[e._v('lexfSkip - this token is used to exclude characters from parsing. For example, the control slashes in the string are \\n \\r ". They will be automatically replaced during the lexical analysis stage.')])]),e._v(" "),n("p",[e._v("V-Logic language\nLexemes")]),e._v(" "),n("p",[e._v("The source code of a program must be in UTF-8 encoding.")]),e._v(" "),n("p",[e._v("The following lexical types are processed:")]),e._v(" "),n("ul",[n("li",[e._v("Keywords - action, break, conditions, continue, contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while;")]),e._v(" "),n("li",[e._v("Number - only decimal numbers are accepted. There are two basic types: int and float. If the number has a decimal point, it becomes a float float. int type is equivalent to int64 in golang, while float type is equivalent to float64 in golang.")]),e._v(" "),n("li",[e._v('String - the string can be enclosed in double quotes ("a string") or backquotes (`a string`). Both types of strings can contain newline characters. Strings in double quotes can contain double quotes, newline characters, and carriage returns escaped with slashes. For example, "This is a "first string".\\r\\nThis is a second string.".')]),e._v(" "),n("li",[e._v("Comment - there are two types of comments. Single-line comments use two slashes (//). For example, // This is a single-line comment. Multi-line comments use slash and asterisk symbols and can span multiple lines. For example, /* This is a multi-line comment */.")]),e._v(" "),n("li",[e._v("Identifier - the names of variables and functions composed of a-z and A-Z letters, UTF-8 symbols, numbers and underscores. The name can start with a letter, underscore, @ or $. The name starting with $ is the name of the variable defined in the data section. The name starting with $ can also be used to define global variables in the scope of conditions and action sections. Ecosystem contracts can be called using the @ symbol. For example: @1NewTable(...).")])]),e._v(" "),n("p",[e._v("Type")]),e._v(" "),n("p",[e._v("Corresponding golang types are specified next to the V-Logic types.")]),e._v(" "),n("ul",[n("li",[e._v("bool - bool, false by default;")]),e._v(" "),n("li",[e._v("bytes - []byte{}, an empty byte array by default;")]),e._v(" "),n("li",[e._v("int - int64, 0 by default;")]),e._v(" "),n("li",[e._v("address - uint64, 0 by default;")]),e._v(" "),n("li",[e._v("array - []interface{}, an empty array by default;")]),e._v(" "),n("li",[e._v("map - map[string]interface{}, an empty object array by default;")]),e._v(" "),n("li",[e._v("money - decimal. Decimal, 0 by default;")]),e._v(" "),n("li",[e._v("float - float64, 0 by default;")]),e._v(" "),n("li",[e._v("string - string, an empty string by default;")]),e._v(" "),n("li",[e._v("file - map[string]interface{}, an empty object array by default.")])]),e._v(" "),n("p",[e._v("These types of variables are defined with the var keyword. For example, var var1, var2 int. When defined in this way, a variable will be assigned with a default value by type.")]),e._v(" "),n("p",[e._v("All variable values are of the interface{} type, and then they are assigned to the required golang types. Therefore, for example, array and map types are golang types []interface{} and map[string]interface{}. Both types of arrays can contain elements of any type.\nExpression")]),e._v(" "),n("p",[e._v("An expression may include arithmetic operations, logical operations, and function calls. All expressions are evaluated from left to right by priority of operators. If having an equal priority, operators are evaluated from left to right.")]),e._v(" "),n("p",[e._v("Priority of operations from high to low:")]),e._v(" "),n("ul",[n("li",[e._v("Function call and parentheses - when a function is called, passed parameters will be calculated from left to right;")]),e._v(" "),n("li",[e._v("Unary Operation - logical negation ! and arithmetic sign change -;")]),e._v(" "),n("li",[e._v("Multiplication and Division - arithmetic multiplication * and division /;")]),e._v(" "),n("li",[e._v("Addition and Subtraction - arithmetic addition + and subtraction -;")]),e._v(" "),n("li",[e._v("Logical comparison - >=>> >=;")]),e._v(" "),n("li",[e._v("Logical equality and inequality - == !=;")]),e._v(" "),n("li",[e._v("Logical AND - &&;")]),e._v(" "),n("li",[e._v("Logical OR - ||.")])]),e._v(" "),n("p",[e._v("When evaluating logical AND and OR, both sides of the expression are evaluated in any case.")]),e._v(" "),n("p",[e._v("V-Logic has no type checking during compilation. When evaluating operands, an attempt is made to convert the type to a more complex type. The type of complexity order can be as follows: string, int, float, money. Only part of the type conversions is implemented. The string type supports addition operations, and the result will be string concatenation. For example, string + string = string, money-int = money, int * float = float.")]),e._v(" "),n("p",[e._v('For functions, type checking is performed on the string and int types during execution.\narray and map types can be addressed by index. For the array type, the int value must be specified as the index. For the map type, a variable or string value must be specified. If you assign a value to an array element whose index is greater than the current maximum index, an empty element will be added to the array. The initial value of these elements is nil. For example: .. code:\nvar my array\nmy[5] = 0\nvar mymap map\nmymap["index"] = my[3]\nIn expressions of conditional logical values (such as if, while, &&, ||, !), the type is automatically converted to a logical value. If the type is not the default value, it is true.\nvar mymap map\nvar val string\nif mymap && val {\n...\n}\nScope')]),e._v(" "),n("p",[e._v("Braces specify a block that can contain local scope variables. By default, the scope of a variable extends to its own blocks and all nested blocks. In a block, you can define a new variable using the name of an existing variable. However, in this case, external variables with the same name become unavailable.")]),e._v(" "),n("p",[e._v("var a int\na = 3\n{\nvar a int\na = 4\nPrintln(a) // 4\n}\nPrintln(a) // 3\nContract execution")]),e._v(" "),n("p",[e._v("When calling a contract, parameters defined in data must be passed to it. Before executing a contract, the virtual machine receives these parameters and assigns them to the corresponding variables ($Param). Then, the predefined conditions function and action function are called.")]),e._v(" "),n("p",[e._v("Errors that occur during contract execution can be divided into two types: form errors and environment errors. Form errors are generated using special commands: error, warning, info and when the built-in function returns err not equal to nil.")]),e._v(" "),n("p",[e._v("The V-Logic language does not handle exceptions. Any error will terminate the execution of contracts. Since a separate stack and structure for saving variable values are created when a contract is executed, the golang garbage collection mechanism will automatically delete these data when a contract is executed.\nBackus–Naur Form (BNF)")]),e._v(" "),n("p",[e._v("In computer science, BNF is a notation technique for context-free syntax and is usually used to describe the syntax of the language used in computing.\n*"),n("br"),e._v("\n'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n*"),n("br"),e._v(" "),n("decimal",{attrs:{digit:""}},[e._v(" {"),n("decimal",{attrs:{digit:""}},[e._v("}\n*"),n("br"),e._v("\n''''''\n*"),n("br"),e._v("\n['-'] <decimal number'.'["),n("decimal",{attrs:{number:""}},[e._v("]\n*"),n("br"),e._v("\n['-'] "),n("decimal",{attrs:{number:""}},[e._v(" | "),n("symbol",{attrs:{code:""}},[e._v("\n*"),n("br"),e._v("\n' | '\n*"),n("br"),e._v("\n'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF\n*"),n("br"),e._v("\n'0x20'\n*"),n("br"),e._v("\n'0x09'\n*"),n("br"),e._v("\n'0x0D 0x0A'\n*"),n("br"),e._v("\n'!' |'\"' |'$' |''' |'(' |')' |'*' |'+' |',' |'-' |'.' |'/ '|'<' |'=' |'>' |'[' |'\\' |']' |'"),n("em",[e._v("' |'|' |'}' |'{' |  |  |\n*"),n("br"),e._v(" "),n("decimal",{attrs:{digit:""}},[e._v(" | "),n("letter",[e._v(" | "),n("special",{attrs:{symbol:""}},[e._v("\n*"),n("br"),e._v("\n("),n("letter",[e._v(" |'")])],1)],1)],1)],1),e._v("') {"),n("letter",[e._v(" |'_' | "),n("decimal",{attrs:{digit:""}},[e._v("}\n*"),n("br"),e._v(" "),n("name",[e._v("\n*"),n("br"),e._v(" "),n("name",[e._v("\n*"),n("br"),e._v(" "),n("name",[e._v("\n*"),n("br"),e._v(" "),n("tabulation",[e._v(" | "),n("space",[e._v(" |'!' |'#' | ... |'[' |']' | ...\n*"),n("br"),e._v("\n{"),n("string",{attrs:{symbol:""}},[e._v(" |'\"' |'\\n' |'\\r'}\n*"),n("br"),e._v("\n'\"' {"),n("string",{attrs:{element:""}},[e._v("}'\"' |'`' {"),n("string",{attrs:{element:""}},[e._v("}'`'\n*"),n("br"),e._v("\n'='\n*"),n("br"),e._v("\n'-'\n*"),n("br"),e._v("\n'==' |'!=' |'>' |'<' |'<=' |'>=' |'&&' |'||' |'*' |'/' |'+ '|'-'\n*"),n("br"),e._v(" "),n("assignment",{attrs:{operator:""}},[e._v(" | "),n("unary",{attrs:{operator:""}},[e._v(" | "),n("binary",{attrs:{operator:""}},[e._v("\n*"),n("br"),e._v(" "),n("expression",[e._v(" {','"),n("expression",[e._v("}\n*"),n("br"),e._v(" "),n("contract",{attrs:{name:""}},[e._v("'(' ["),n("parameters",[e._v("]')'\n*"),n("br"),e._v(" "),n("contract",{attrs:{call:""}},[e._v(" [{'.' "),n("name",[e._v("'(' ["),n("parameters",[e._v("]')'}]\n*"),n("br"),e._v(" "),n("block",{attrs:{command:""}},[e._v(" {"),n("newline",[n("block",{attrs:{command:""}},[e._v("}\n*"),n("br"),e._v("\n'{'"),n("block",{attrs:{contents:""}},[e._v("'}'\n*"),n("br"),e._v("\n("),n("block",[e._v(" | "),n("expression",[e._v(" | "),n("variables",{attrs:{definition:""}},[e._v(" | "),n("if",[e._v(" | "),n("while",[e._v(" | break | continue | return)\n*"),n("br"),e._v("\n'if  [else ]'\n*"),n("br"),e._v("\n'while '\n*"),n("br"),e._v("\n'contract '{'[] {} [] []'}''\n*"),n("br"),e._v("\n'data'{' {}'}''\n*"),n("br"),e._v(" "),n("variable",{attrs:{name:""}},[n("type",{attrs:{name:""}},[e._v("'\"'{"),n("tag",[e._v("}'\"'\n*"),n("br"),e._v("\n'optional | image | file | hidden | text | polymap | map | address | signature:'\n*"),n("br"),e._v("\n'conditions '\n*"),n("br"),e._v("\n'action '\n*"),n("br"),e._v("\n'func '('[{','}]')'[{}] [] '\n*"),n("br"),e._v(" "),n("variable",{attrs:{name:""}},[e._v(" {',' "),n("variable",{attrs:{name:""}},[e._v("} "),n("type",{attrs:{name:""}},[e._v("\n*"),n("br"),e._v("\n'.'"),n("function",{attrs:{name:""}},[e._v("'('["),n("variable",{attrs:{description:""}},[e._v("{','"),n("variable",{attrs:{description:""}},[e._v("}]')'\n*"),n("br"),e._v("\n'var {','}'")])],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)])],1)],1)],1)],1)])}),[],!1,null,null,null);t.default=i.exports}}]);