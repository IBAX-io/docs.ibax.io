<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>コンパイラと仮想マシン（Virtual Machine）  </a></li><li><a href="/ja/topics/templates2.html" class="sidebar-link">テンプレート言語 </a></li><li><a href="/ja/topics/vm.html" aria-current="page" class="active sidebar-link">コンパイラと仮想マシン（Virtual Machine）  </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#source-code-storage-and-compilation" class="sidebar-link">ソースコードの保存とコンパイル </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#virtual-machine-structures" class="sidebar-link">仮想マシンの構造 </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#vm-structure" class="sidebar-link">VMの構造 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#block-structure" class="sidebar-link">ブロックの構造 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#objinfo-structure" class="sidebar-link">ObjInfoの構造 </a></li></ul></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#virtual-machine-commands" class="sidebar-link">仮想マシンのコマンド </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#bytecode-structure" class="sidebar-link">ByteCodeの構造 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#command-identifiers" class="sidebar-link">コマンド識別子 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#stack-operation-commands" class="sidebar-link">スタック操作コマンド </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#runtime-structure" class="sidebar-link">ランタイムの構造 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#runcode-function" class="sidebar-link">RunCode関数 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#other-functions-for-operations-with-vm" class="sidebar-link">仮想マシンの他の操作用関数 </a></li></ul></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#compiler" class="sidebar-link">コンパイラ </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#lexical-analyzer" class="sidebar-link">字句解析器 </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#lextable-lextable-go" class="sidebar-link">lextable/lextable.go </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#lex-go" class="sidebar-link">lex.go </a></li></ul></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#needle-language" class="sidebar-link">Needle言語 </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#lexemes" class="sidebar-link">字句 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#types" class="sidebar-link">型 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#expressions" class="sidebar-link">式 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#scope" class="sidebar-link">スコープ </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#contract-execution" class="sidebar-link">コントラクトの実行 </a></li><li class="sidebar-sub-header"><a href="/ja/topics/vm.html#backus-naur-form-bnf" class="sidebar-link">バッカス・ナウア形式（BNF） </a></li></ul></li></ul></li><li><a href="/ja/topics/daemons.html" class="sidebar-link">デーモン </a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="compiler-and-virtual-machine"><a href="#compiler-and-virtual-machine" class="header-anchor">#</a> コンパイラと仮想マシン（Virtual Machine）  </h1> <ul><li><a href="#source-code-storage-and-compilation">ソースコードの保存とコンパイル</a></li> <li><a href="#virtual-machine-structures">仮想マシンの構造</a> <ul><li><a href="#vm-structure">VMの構造</a></li> <li><a href="#block-structure">ブロックの構造</a></li> <li><a href="#objinfo-structure">ObjInfoの構造</a> <ul><li><a href="#contractinfo-structure">ContractInfoの構造</a></li> <li><a href="#fieldinfo-structure">FieldInfoの構造</a></li> <li><a href="#funcinfo-structure">FuncInfoの構造</a></li> <li><a href="#funcname-structure">FuncNameの構造</a></li> <li><a href="#extfuncinfo-structure">ExtFuncInfoの構造</a></li> <li><a href="#varinfo-structure">VarInfoの構造</a></li> <li><a href="#objextend-value">ObjExtendの値</a></li></ul></li></ul></li> <li><a href="#virtual-machine-commands">仮想マシンのコマンド</a> <ul><li><a href="#bytecode-structure">ByteCodeの構造</a></li> <li><a href="#command-identifiers">コマンド識別子</a></li> <li><a href="#stack-operation-commands">スタック操作コマンド</a></li> <li><a href="#runtime-structure">ランタイムの構造</a> <ul><li><a href="#blockstack-structure">blockStackの構造</a></li></ul></li> <li><a href="#runcode-function">RunCode関数</a></li> <li><a href="#other-functions-for-operations-with-vm">仮想マシンの他の操作用関数</a></li></ul></li> <li><a href="#compiler">コンパイラ</a></li> <li><a href="#lexical-analyzer">字句解析器</a> <ul><li><a href="#lextable-lextable-go">lextable/lextable.go</a></li> <li><a href="#lex-go">lex.go</a></li></ul></li> <li><a href="#needle-language">Needle言語</a> <ul><li><a href="#lexemes">字句</a></li> <li><a href="#types">型</a></li> <li><a href="#expressions">式</a></li> <li><a href="#scope">スコープ</a></li> <li><a href="#contract-execution">コントラクトの実行</a></li> <li><a href="#backus-naur-form-bnf">バッカス・ナウア形式（BNF）</a></li></ul></li></ul> <p>このセクションでは、仮想マシン (VM) でのプログラムのコンパイルと Needle 言語の操作について説明します。</p> <h2 id="source-code-storage-and-compilation"><a href="#source-code-storage-and-compilation" class="header-anchor">#</a> ソースコードの保存とコンパイル </h2> <p>コントラクトと関数はGolangで書かれ、エコシステムのコントラクトテーブルに保存されます。</p> <p>コントラクトが実行されると、そのソースコードはデータベースから読み取られ、バイトコードにコンパイルされます。</p> <p>コントラクトが変更されると、そのソースコードが更新され、データベースに保存されます。そして、ソースコードはコンパイルされ、対応する仮想マシンのバイトコードが更新されます。</p> <p>バイトコードは物理的に保存されないため、プログラムが再実行されると再度コンパイルされます。</p> <p>各エコシステムのコントラクトテーブルに記述されたソースコードは、厳密な順序で仮想マシンにコンパイルされ、すべてのノードで仮想マシンの状態が同じです。</p> <p>コントラクトが呼び出されると、仮想マシンは状態を変更しません。任意のコントラクトの実行または関数の呼び出しは、外部呼び出し時に作成される個別の実行スタック上で行われます。</p> <p>各エコシステムには、仮想エコシステムと呼ばれるものが存在することがあります。これはブロックチェーンの外部テーブルと組み合わせてノード内で使用され、ブロックチェーンや他の仮想エコシステムに直接的な影響を与えません。この場合、仮想エコシステムをホストするノードは、独自のコントラクトをコンパイルし、独自の仮想マシンを作成します。</p> <h2 id="virtual-machine-structures"><a href="#virtual-machine-structures" class="header-anchor">#</a> 仮想マシンの構造 </h2> <h3 id="vm-structure"><a href="#vm-structure" class="header-anchor">#</a> VMの構造 </h3> <p>仮想マシンは、以下のような構造でメモリに組織化されます。</p> <div class="language- extra-class"><pre class="language-text"><code>type VM struct {
   Block
   ExtCost func(string) int64
   FuncCallsDB map[string]struct{}
   Extern bool
   ShiftContract int64
   logger *log.Entry
}
</code></pre></div><p>仮想マシンの構造は以下の要素を持っています：</p> <ul><li>Block - <a href="#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%81%AE%E6%A7%8B%E9%80%A0">ブロックの構造</a>を含む</li> <li>ExtCost - 外部のGolang関数の実行コストを返す関数</li> <li>FuncCallsDB - Golang関数名のコレクション。この関数は実行コストを最初のパラメータとして返します。これらの関数はEXPLAINを使用してデータベース処理のコストを計算します</li> <li>Extern - コントラクトが外部コントラクトであるかを示すブールフラグ。VMが作成されるとtrueに設定されます。コードがコンパイルされる際に呼び出されるコントラクトは表示されません。つまり、将来決まるコントラクトコードを呼び出すことができます</li> <li>ShiftContract - VM内の最初のコントラクトのID</li> <li>logger - VMのエラーログの出力</li></ul> <h3 id="block-structure"><a href="#block-structure" class="header-anchor">#</a> ブロックの構造 </h3> <p>仮想マシンは、<strong>Block型</strong>オブジェクトから構成されるツリーです。</p> <p>ブロックは、いくつかのバイトコードを含む独立したユニットです。言語で中括弧(<code>{}</code>)内に記述するものすべてがブロックです。</p> <p>例えば、以下のコードは関数を含むブロックを作成します。このブロックには、if文を含む別のブロックがあり、その中にはwhile文を含むさらなるブロックがあります。</p> <div class="language- extra-class"><pre class="language-text"><code>func my() {
   if true {
      while false {
      ...
      }
   }
}
</code></pre></div><p>ブロックは以下のような構造でメモリに組織化されます。</p> <div class="language- extra-class"><pre class="language-text"><code>type Block struct {
   Objects map[string]*ObjInfo
   Type int
   Owner *OwnerInfo
   Info interface{}
   Parent *Block
   Vars []reflect.Type
   Code ByteCodes
   Children Blocks
}
</code></pre></div><p>ブロックの構造は以下の要素から成り立ちます:</p> <ul><li><strong>Objects</strong> - <a href="#ObjInfo%E3%81%AE%E6%A7%8B%E9%80%A0">ObjInfo</a>というポインタ型の内部オブジェクトのマップです。例えば、ブロック内に変数がある場合は、その変数の情報を名前で取得することができます。</li> <li><strong>Type</strong> - ブロックのタイプです。関数ブロックの場合は<strong>ObjFunc</strong>、コントラクトブロックの場合は<strong>ObjContract</strong>です。</li> <li><strong>Owner</strong> - <strong>OwnerInfo</strong>というポインタ型の構造体です。この構造体には、コンパイルされたコントラクトの所有者に関する情報が含まれています。所有者情報はコンパイル時に指定されるか、<strong>contracts</strong>テーブルから取得されます。</li> <li><strong>Info</strong> - ブロックタイプに依存するオブジェクトに関する情報が含まれています。</li> <li><strong>Parent</strong> - 親ブロックへのポインタです。</li> <li><strong>Vars</strong> - 現在のブロック変数の型を含む配列です。</li> <li><strong>Code</strong> - ブロック自体のバイトコードです。制御権がブロックに渡された場合に実行される部分です。例えば、関数呼び出しやループの本体などが該当します。</li> <li><strong>Children</strong> - サブブロックを含む配列です。関数のネストやループ、条件演算子などがサブブロックとして扱われます。</li></ul> <h3 id="objinfo-structure"><a href="#objinfo-structure" class="header-anchor">#</a> ObjInfoの構造 </h3> <p>ObjInfoの構造は、内部オブジェクトに関する情報を含んでいます。</p> <div class="language- extra-class"><pre class="language-text"><code>type ObjInfo struct {
   Type int
   Value interface{}
}
</code></pre></div><p>ObjInfoの構造は以下の要素から成り立ちます:</p> <ul><li><strong>Type</strong> - オブジェクトのタイプであり、以下のいずれかの値を持ちます:
<ul><li><strong>ObjContract</strong> - <a href="#ContractInfo%E3%81%AE%E6%A7%8B%E9%80%A0">contractInfo</a></li> <li><strong>ObjFunc</strong> - 関数</li> <li><strong>ObjExtFunc</strong> - 外部のGolang関数</li> <li><strong>ObjVar</strong> - 変数</li> <li><strong>ObjExtend</strong> - $name変数</li></ul></li> <li><strong>Value</strong> - 各タイプの構造体が含まれています</li></ul> <h4 id="contractinfo-structure"><a href="#contractinfo-structure" class="header-anchor">#</a> ContractInfoの構造 </h4> <p><strong>ObjContract</strong>タイプを指し示し、<strong>Value</strong>フィールドには<strong>ContractInfo</strong>構造体が含まれています。</p> <div class="language- extra-class"><pre class="language-text"><code>type ContractInfo struct {
   ID uint32
   Name string
   Owner *OwnerInfo
   Used map[string]bool
   Tx *[]*FieldInfo
}
</code></pre></div><p>ContractInfoの構造は以下の要素を持っています:</p> <ul><li><strong>ID</strong> - コントラクトのID。コントラクトを呼び出す際にブロックチェーンに表示されます。</li> <li><strong>Name</strong> - コントラクトの名前。</li> <li><strong>Owner</strong> - コントラクトに関するその他の情報。</li> <li><strong>Used</strong> - 呼び出されたコントラクトの名前のマップ。</li> <li><strong>Tx</strong> - コントラクトの<a href="/ja/topics/script.html#データセクション">data section</a>に記述されたデータ配列。</li></ul> <h4 id="fieldinfo-structure"><a href="#fieldinfo-structure" class="header-anchor">#</a> FieldInfoの構造 </h4> <p><strong>FieldInfo</strong>構造体は<strong>ContractInfo</strong>構造体で使用され、コントラクトの<a href="/ja/topics/script.html#データセクション">data section</a>内の要素を説明します。</p> <div class="language- extra-class"><pre class="language-text"><code>type FieldInfo struct {
   Name string
   Type reflect.Type
   Original uint32
   Tags string
}
</code></pre></div><p>FieldInfoの構造は以下の要素を持っています:</p> <ul><li><strong>Name</strong> - フィールド名</li> <li><strong>Type</strong> - フィールドの型</li> <li><strong>Original</strong> - オプションのフィールド</li> <li><strong>Tags</strong> - このフィールドに対する追加のラベル</li></ul> <h4 id="funcinfo-structure"><a href="#funcinfo-structure" class="header-anchor">#</a> FuncInfoの構造 </h4> <p>ObjFunc タイプを指しており、Value フィールドには FuncInfo 構造体が含まれています。</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncInfo struct {
   Params []reflect.Type
   Results []reflect.Type
   Names *map[string]FuncName
   Variadic bool
   ID uint32
}
</code></pre></div><p>FuncInfoの構造は以下の要素を持っています:</p> <ul><li><strong>Params</strong> - パラメータの型の配列</li> <li><strong>Results</strong> - 戻り値の型の配列</li> <li><strong>Names</strong> - テール関数のためのデータのマップ。例えば、<code>DBFind().Columns()</code>のような場合です。</li> <li><strong>Variadic</strong> - 関数が可変長のパラメータを持つ場合はtrue</li> <li><strong>ID</strong> - 関数のID</li></ul> <h4 id="funcname-structure"><a href="#funcname-structure" class="header-anchor">#</a> FuncNameの構造 </h4> <p>FuncName 構造体は FuncInfo に使用され、tail 関数のデータを記述します。</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
</code></pre></div><p>FuncNameの構造は以下の要素を持っています:</p> <ul><li><strong>Params</strong> - パラメータの型の配列</li> <li><strong>Offset</strong> - 変数のオフセットの配列。実際には、関数内のすべてのパラメータの値をドット「.」で初期化することができます。</li> <li><strong>Variadic</strong> - テール関数が可変長のパラメータを持つ場合はtrue</li></ul> <h4 id="extfuncinfo-structure"><a href="#extfuncinfo-structure" class="header-anchor">#</a> ExtFuncInfoの構造 </h4> <p>ObjExtFuncタイプを指し示し、ValueフィールドにはExtFuncInfoの構造が含まれています。これはGolang関数を説明するために使用されます。</p> <div class="language- extra-class"><pre class="language-text"><code>type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
</code></pre></div><p>ExtFuncInfoの構造は以下の要素を持っています:</p> <ul><li><strong>Name</strong>、<strong>Params</strong>、<strong>Results</strong>のパラメータは<a href="#funcinfo-structure">FuncInfo</a>と同じ構造を持ちます。</li> <li><strong>Auto</strong> - 変数の配列。存在する場合、関数に追加のパラメータとして渡されます。例えば、SmartContract型の変数scです。</li> <li><strong>Func</strong> - Golang関数</li></ul> <h4 id="varinfo-structure"><a href="#varinfo-structure" class="header-anchor">#</a> VarInfoの構造 </h4> <p><strong>ObjVar</strong>タイプを指し示し、<strong>Value</strong>フィールドには<strong>VarInfo</strong>の構造が含まれています。</p> <div class="language- extra-class"><pre class="language-text"><code>type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
</code></pre></div><p>VarInfoの構造は以下の要素を持っています:</p> <ul><li><strong>Obj</strong> - 変数の型と値に関する情報</li> <li><strong>Owner</strong> - オーナーブロックへのポインタ</li></ul> <h4 id="objextend-value"><a href="#objextend-value" class="header-anchor">#</a> ObjExtendの値 </h4> <p><strong>ObjExtend</strong>タイプを指し示し、<strong>Value</strong>フィールドには変数や関数の名前を含む文字列が含まれています。</p> <h2 id="virtual-machine-commands"><a href="#virtual-machine-commands" class="header-anchor">#</a> 仮想マシンのコマンド </h2> <h3 id="bytecode-structure"><a href="#bytecode-structure" class="header-anchor">#</a> ByteCodeの構造 </h3> <p>バイトコードは、<strong>ByteCode</strong>タイプの構造体のシーケンスです。</p> <div class="language- extra-class"><pre class="language-text"><code>type ByteCode struct {
   Cmd uint16
   Value interface{}
}
</code></pre></div><p>この構造体は以下のフィールドを持っています:</p> <ul><li><strong>Cmd</strong> - ストレージコマンドの識別子です。</li> <li><strong>Value</strong> - オペランド（値）が含まれています。</li></ul> <p>一般的に、コマンドはスタックのトップ要素に対して操作を行い、必要に応じて結果値を書き込みます。</p> <h3 id="command-identifiers"><a href="#command-identifiers" class="header-anchor">#</a> コマンド識別子 </h3> <p>仮想マシンのコマンドの識別子は、vm/cmds_list.goファイルに記述されています。</p> <ul><li><strong>cmdPush</strong> - [Value] フィールドから値をスタックに格納します。例えば、数値や文字列をスタックに格納します。</li> <li><strong>cmdVar</strong> - 変数の値をスタックに格納します。ValueフィールドにはVarInfo構造体へのポインタと変数に関する情報が含まれます。</li> <li><strong>cmdExtend</strong> - 外部変数の値をスタックに格納します。Valueフィールドには変数名（$で始まる）が含まれます。</li> <li><strong>cmdCallExtend</strong> - 外部関数($で始まる)を呼び出します。関数のパラメータはスタックから取得され、結果はスタックに格納されます。Valueフィールドには関数名($で始まる)が含まれます。</li> <li><strong>cmdPushStr</strong> - Valueフィールドの文字列をスタックに格納します。</li> <li><strong>cmdCall</strong> - 仮想マシンの関数を呼び出します。Valueフィールドには <strong>ObjInfo</strong> 構造体が含まれます。このコマンドは、<strong>ObjExtFunc</strong>のGolang関数と<strong>ObjFunc</strong>のNeedle関数に適用されます。関数が呼び出されると、そのパラメータはスタックから取得され、結果値はスタックに格納されます。</li> <li><strong>cmdCallVari</strong> - <strong>cmdCall</strong>コマンドと似ていますが、可変長のパラメータを持つ関数を呼び出すために使用されます。</li> <li><strong>cmdReturn</strong> - 関数から出るために使用されます。戻り値はスタックに格納され、Valueフィールドは使用されません。</li> <li><strong>cmdIf</strong> - スタックのトップ要素が<em>valueToBool</em>関数によって呼び出され、<code>true</code>が返される場合にのみ、Valueフィールドに渡された<strong>block</strong>構造に制御が移ります。そうでない場合は、次のコマンドに制御が移ります。</li> <li><strong>cmdElse</strong> - このコマンドは<strong>cmdIf</strong>と同様に動作しますが、スタックのトップ要素が<em>valueToBool</em>関数によって呼び出され、<code>false</code>が返された場合に指定されたブロックに制御が移ります。</li> <li><strong>cmdAssignVar</strong> - Valueから<strong>VarInfo</strong>型の変数のリストを取得します。これらの変数は<strong>cmdAssign</strong>コマンドを使用して値を取得します。</li> <li><strong>cmdAssign</strong> - スタックの値を<strong>cmdAssignVar</strong>コマンドで取得した変数に割り当てます。</li> <li><strong>cmdLabel</strong> - ループ中に制御が戻ったときにラベルを定義します。</li> <li><strong>cmdContinue</strong> - このコマンドは<strong>cmdLabel</strong>ラベルに制御を移します。新しいループのイテレーションを実行する際にValueは使用されません。</li> <li><strong>cmdWhile</strong> - スタックのトップ要素を<strong>valueToBool</strong>でチェックします。この値が<code>true</code>の場合、Valueフィールドに渡された<strong>block</strong>構造が呼び出されます。</li> <li><strong>cmdBreak</strong> - ループを終了します。</li> <li><strong>cmdIndex</strong> - mapまたは配列の値をインデックスでスタックに格納します。Valueは使用されません。例: <code>(map | array) (index value) =&gt; (map | array [index value])</code></li> <li><strong>cmdSetIndex</strong> - スタックのトップ要素の値をmapまたは配列の要素に割り当てます。Valueは使用されません。例: <code>(map | array) (index value) (value) =&gt; (map | array)</code></li> <li><strong>cmdFuncName</strong> - ドット<code>.</code>で区切られた順序で渡されるパラメータを追加します。例: <code>func name =&gt; Func (...) .Name (...)</code></li> <li><strong>cmdUnwrapArr</strong> - スタックのトップ要素が配列である場合に、真偽値フラグを定義します。</li> <li><strong>cmdMapInit</strong> - mapの値を初期化します。</li> <li><strong>cmdArrayInit</strong> - 配列の値を初期化します。</li> <li><strong>cmdError</strong> - <code>error、warning、info</code></li></ul> <h3 id="stack-operation-commands"><a href="#stack-operation-commands" class="header-anchor">#</a> スタック操作コマンド </h3> <blockquote><p>注意</p></blockquote> <blockquote><p>現在のバージョンでは、これらのコマンドに対して自動型変換は完全に適用されません。例えば、</p></blockquote> <blockquote><p><code>string + float | int | decimal =&gt; float | int | decimal, float + int | str =&gt; float, しかし int + string =&gt; 実行時エラー</code>。</p></blockquote> <p>以下は、直接スタックを処理するためのコマンドです。これらのコマンドではValueフィールドは使用されません。</p> <ul><li><strong>cmdNot</strong> - 論理否定。 <code>(val) =&gt; (!ValueToBool(val))</code></li> <li><strong>cmdSign</strong> - 符号の変更。 <code>(val) =&gt; (-val)</code></li> <li><strong>cmdAdd</strong> - 加算。 <code>(val1)(val2) =&gt; (val1 + val2)</code></li> <li><strong>cmdSub</strong> - 減算。 <code>(val1)(val2) =&gt; (val1 - val2)</code></li> <li><strong>cmdMul</strong> - 乗算。 <code>(val1)(val2) =&gt; (val1 * val2)</code></li> <li><strong>cmdDiv</strong> - 除算。 <code>(val1)(val2) =&gt; (val1 / val2)</code></li> <li><strong>cmdAnd</strong> - 論理積。 <code>(val1)(val2) =&gt; (valueToBool(val1) &amp;&amp; valueToBool(val2))</code></li> <li><strong>cmdOr</strong> - 論理和。 <code>(val1)(val2) =&gt; (valueToBool(val1) || valueToBool(val2))</code></li> <li><strong>cmdEqual</strong> - 等しいかの比較結果を返す。 <code>(val1)(val2) =&gt; (val1 == val2)</code></li> <li><strong>cmdNotEq</strong> - 等しくないかの比較結果を返す。 <code>(val1)(val2) =&gt; (val1 != val2)</code></li> <li><strong>cmdLess</strong> - より小さいかの比較結果を返す。 <code>(val1)(val2) =&gt; (val1 &lt; val2)</code></li> <li><strong>cmdNotLess</strong> - より大きいか、または等しいかの比較結果を返す。 <code>(val1)(val2) =&gt; (val1 &gt;= val2)</code></li> <li><strong>cmdGreat</strong> - より大きいかの比較結果を返す。 <code>(val1)(val2) =&gt; (val1 &gt; val2)</code></li> <li><strong>cmdNotGreat</strong> - より小さいか、または等しいかの比較結果を返す。 <code>(val1)(val2) =&gt; (val1 &lt;= val2)</code></li></ul> <h3 id="runtime-structure"><a href="#runtime-structure" class="header-anchor">#</a> ランタイムの構造 </h3> <p>バイトコードの実行は仮想マシンに影響を与えません。例えば、さまざまな関数やコントラクトを単一の仮想マシンで同時に実行することができます。ランタイムの構造は、関数やコントラクト、および任意の式やバイトコードを実行するために使用されます。</p> <div class="language- extra-class"><pre class="language-text"><code>type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}
</code></pre></div><ul><li><strong>stack</strong> - バイトコードを実行するためのスタック</li> <li><strong>blocks</strong> - ブロック呼び出しのスタック</li> <li><strong>vars</strong> - 変数のスタック。ブロック内でバイトコードが呼び出されると、その変数が変数のスタックに追加されます。ブロックを抜けると、変数のスタックのサイズは前の値に戻ります。</li> <li><strong>extend</strong> - 外部変数（<code>$name</code>）の値のマップへのポインタ</li> <li><strong>vm</strong> - 仮想マシンへのポインタ</li> <li><strong>cost</strong> - 実行の結果得られるコストの燃料単位</li> <li><strong>err</strong> - 実行中に発生したエラー</li></ul> <h4 id="blockstack-structure"><a href="#blockstack-structure" class="header-anchor">#</a> blockStackの構造 </h4> <p>blockStackの構造は、Runtimeの構造体で使用されます。</p> <div class="language- extra-class"><pre class="language-text"><code>type blockStack struct {
   Block *Block
   Offset int
}
</code></pre></div><ul><li><strong>Block</strong> - 実行中のブロックへのポインタ</li> <li><strong>Offset</strong> - 指定されたブロックのバイトコード内で実行された最後のコマンドのオフセット</li></ul> <h3 id="runcode-function"><a href="#runcode-function" class="header-anchor">#</a> RunCode関数 </h3> <p>バイトコードは <strong>RunCode</strong> 関数で実行されます。各バイトコードのコマンドに対して対応する操作を実行するループが含まれています。バイトコードを処理する前に、必要なデータを初期化する必要があります。</p> <p>新しいブロックは他のブロックに追加されます。</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = append(rt.blocks, &amp;blockStack{block, len(rt.vars)})
</code></pre></div><p>次に、tail関数の関連パラメータの情報を取得します。 これらのパラメータはスタックの最後の要素に含まれています。</p> <div class="language- extra-class"><pre class="language-text"><code>var namemap map[string][]interface{}
if block.Type == ObjFunc &amp;&amp; block.Info.(*FuncInfo).Names != nil {
   if rt.stack[len(rt.stack)-1] != nil {
      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
   }
   rt.stack = rt.stack[:len(rt.stack)-1]
}
</code></pre></div><p>次に、現在のブロックで定義されているすべての変数を初期値で初期化する必要があります。</p> <div class="language- extra-class"><pre class="language-text"><code>start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
   rt.cost--
   var value interface{}
</code></pre></div><p>関数内の変数も変数であるため、関数自体で記述された順序でスタックの最後の要素から変数を取得する必要があります。</p> <div class="language- extra-class"><pre class="language-text"><code>   if block.Type == ObjFunc &amp;&amp; vkey &lt;len(block.Info.(*FuncInfo).Params) {
      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
   } else {
</code></pre></div><p>ローカル変数を初期値で初期化します。</p> <div class="language- extra-class"><pre class="language-text"><code>      value = reflect.New(vpar).Elem().Interface()

      if vpar == reflect.TypeOf(map[string]interface{}{}) {

         value = make(map[string]interface{})
      } else if vpar == reflect.TypeOf([]interface{}{}) {
         value = make([]interface{}, 0, len(rt.vars)+1)
      }
   }
   rt.vars = append(rt.vars, value)
}
</code></pre></div><p>次に、tail 関数で渡される変数パラメーターの値を更新します。</p> <div class="language- extra-class"><pre class="language-text"><code>if namemap != nil {
   for key, item := range namemap {
      params := (*block.Info.(*FuncInfo).Names)[key]
      for i, value := range item {
         if params.Variadic &amp;&amp; i &gt;= len(params.Params)-1 {
</code></pre></div><p>渡された変数パラメーターが可変数のパラメーターに属している場合、これらのパラメーターは変数の配列に結合されます。</p> <div class="language- extra-class"><pre class="language-text"><code>            off := varoff + params.Offset[len(params.Params)-1]
            rt.vars[off] = append(rt.vars[off].([]interface{}), value)
         } else {
            rt.vars[varoff+params.Offset[i]] = value
         }
      }
   }
}
</code></pre></div><p>あとはスタックの先頭から関数パラメータとして渡された値を削除することでスタックを移動するだけです。 それらの値を変数配列にコピーしました。</p> <div class="language- extra-class"><pre class="language-text"><code>if block.Type == ObjFunc {
   start -= len(block.Info.(*FuncInfo).Params)
}
</code></pre></div><p>バイトコードのコマンドループが終了したら、スタックを正しくクリアする必要があります。</p> <div class="language- extra-class"><pre class="language-text"><code>last := rt.blocks[len(rt.blocks)-1]
</code></pre></div><p>ブロックのスタックから現在のブロックを削除します。</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
</code></pre></div><p>すでに実行されている関数から正常に終了した場合は、戻り値を前のスタックの最後に追加します。</p> <div class="language- extra-class"><pre class="language-text"><code>   if last.Block.Type == ObjFunc {
      for count := len(last.Block.Info.(*FuncInfo).Results); count &gt; 0; count-- {
         rt.stack[start] = rt.stack[len(rt.stack)-count]
         start++
      }
      status = statusNormal
   } else {
</code></pre></div><p>ご覧のとおり、関数を実行しない場合はスタックの状態を復元せず、そのまま関数を終了します。 その理由は、関数内で実行されたループや条件構造もバイトコード ブロックであるためです。</p> <div class="language- extra-class"><pre class="language-text"><code>   return

   }
}

rt.stack = rt.stack[:start]
</code></pre></div><h3 id="other-functions-for-operations-with-vm"><a href="#other-functions-for-operations-with-vm" class="header-anchor">#</a> 仮想マシンの他の操作用関数 </h3> <p><strong>NewVM</strong> 関数を使用して仮想マシンを作成することができます。各仮想マシンには、<strong>ExecContract</strong>、<strong>MemoryUsage</strong>、<strong>CallContract</strong>、<strong>Settings</strong> の4つの関数が <strong>Extend</strong> 関数を介して追加されます。</p> <div class="language- extra-class"><pre class="language-text"><code>for key, item := range ext.Objects {
   fobj := reflect.ValueOf(item).Type()
</code></pre></div><p>渡されたすべてのオブジェクトを調べて、関数のみを確認します。</p> <div class="language- extra-class"><pre class="language-text"><code>   switch fobj.Kind() {
   case reflect.Func:
</code></pre></div><p>関数に関して受け取った情報に従って <strong>ExtFuncInfo</strong> 構造体にデータを入力し、その構造体を名前で最上位マップ <strong>Objects</strong> に追加します。</p> <div class="language- extra-class"><pre class="language-text"><code>   data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),
   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}
   for i := 0; i &lt;fobj.NumIn(); i++ {
</code></pre></div><p><strong>ExtFuncInfo</strong> 構造体には <strong>Auto</strong> パラメーター配列があります。 通常、最初のパラメータは <code>sc *SmartContract</code> または <code>rt *Runtime</code> ですが、これらはいくつかの golang 関数を実行するために必要であるため、Needle 言語から渡すことはできません。 したがって、これらの関数が呼び出されたときにこれらの変数が自動的に使用されるように指定します。 この場合、上記 4 つの関数の最初のパラメータは <code>rt *Runtime</code> です。</p> <div class="language- extra-class"><pre class="language-text"><code>   if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
      data.Auto[i] = isauto
   }
</code></pre></div><p>パラメータの割り当てに関する情報。</p> <div class="language- extra-class"><pre class="language-text"><code>      data.Params[i] = fobj.In(i)
   }
</code></pre></div><p>そして戻り値の型。</p> <div class="language- extra-class"><pre class="language-text"><code>for i := 0; i &lt;fobj.NumOut(); i++ {
   data.Results[i] = fobj.Out(i)
}
</code></pre></div><p>ルート <strong>Objects</strong> に関数を追加して、後でコントラクトを使用するときにコンパイラーがそれらを見つけられるようにします。</p> <div class="language- extra-class"><pre class="language-text"><code>      vm.Objects[key] = &amp;ObjInfo{ObjExtFunc, data}
   }

}
</code></pre></div><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> コンパイラ </h2> <p>compile.go ファイルの関数は、字句解析器から得られたトークンの配列をコンパイルする責任を持ちます。コンパイルは条件付きで2つのレベルに分けることができます。トップレベルでは、関数、コントラクト、コードブロック、条件文、ループ文、変数定義などに対処します。低レベルでは、コードブロック内の式やループおよび条件文の条件などをコンパイルします。</p> <p>まず、簡単な低レベルから始めましょう。<strong>compileEval</strong> 関数では、式をバイトコードに変換することができます。スタックを使用する仮想マシンを使用しているため、通常の中置記録式を逆ポーランド記法に変換する必要があります。例えば、 <code>1+2</code> を <code>12+</code> に変換し、 <code>1</code> と <code>2</code> をスタックに入れます。その後、スタック内の最後の2つの要素に対して加算演算を適用し、結果をスタックに書き込みます。この変換アルゴリズムは、インターネット上で<a href="https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/" target="_blank" rel="noopener noreferrer">見つけることができます<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>グローバル変数 <code>opers = map [uint32] operPrior</code> には、逆ポーランド記法への変換に必要な操作の優先順位が含まれています。</p> <p><strong>compileEval</strong> 関数の最初に以下の変数が定義されています：</p> <ul><li><strong>buffer</strong> - バイトコードコマンドの一時バッファ</li> <li><strong>bytecode</strong> - バイトコードコマンドの最終バッファ</li> <li><strong>parcount</strong> - 関数呼び出し時のパラメータ計算に使用される一時バッファ</li> <li><strong>setIndex</strong> - マップまたは配列の要素を割り当てる場合に変数が設定されます。例えば、 <code>a[&quot;my&quot;] = 10</code>。この場合、指定された <strong>cmdSetIndex</strong> コマンドを使用する必要があります。</li></ul> <p>ループ内でトークンを取得し、それに応じて処理します。例えば、括弧が見つかると式のパースが停止されます。文字列を移動する際に、前のステートメントが演算子であり、かつ括弧の内部にあるかどうかをチェックし、そうでない場合は式のパースを終了します。</p> <div class="language- extra-class"><pre class="language-text"><code>case isRCurly, isLCurly:
   i--
   if prevLex == isComma || prevLex == lexOper {
      return errEndExp
   }
   break main
case lexNewLine:
   if i &gt; 0 &amp;&amp; ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {
      continue main
   }
   for k := len(buffer) - 1; k &gt;= 0; k-- {
   if buffer[k].Cmd == cmdSys {
      continue main
   }
}
break main
</code></pre></div><p>一般的には、アルゴリズム自体は逆ポーランド記法への変換アルゴリズムに対応しています。必要な契約、関数、インデックスの呼び出し、およびパース中に遭遇しなかった他の要素を考慮して、lexIdentタイプのトークンのパースオプションを考慮して、その名前の変数、関数、または契約をチェックします。何も見つからない場合、およびこれが関数または契約の呼び出しでない場合は、エラーが発生します。</p> <div class="language- extra-class"><pre class="language-text"><code>objInfo, tobj := vm.findObj(lexem.Value.(string), block)
if objInfo == nil &amp;&amp; (!vm.Extern || i&gt; *ind || i &gt;= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {
   return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))
}
</code></pre></div><p>以下のような状況に遭遇することがあります。契約の呼び出しについては後で説明します。この例では、同じ名前の関数や変数が見つからない場合、契約を呼び出す必要があると考えます。このコンパイルされた言語では、契約の呼び出しと関数の呼び出しには違いがありません。ただし、バイトコードで使用される<strong>ExecContract</strong>関数を介して契約を呼び出す必要があります。</p> <div class="language- extra-class"><pre class="language-text"><code>if objInfo.Type == ObjContract {
   if objInfo.Value != nil {
      objContract = objInfo.Value.(*Block)
   }
   objInfo, tobj = vm.findObj(`ExecContract`, block)
   isContract = true
}
</code></pre></div><p><code>count</code>には、これまでの変数の数が記録されており、関数のパラメータの数とともにスタックに書き込まれます。パラメータの検出が行われるたびに、スタックの最後の要素に1を加えるだけで、この数を増やす必要があります。</p> <div class="language- extra-class"><pre class="language-text"><code>count := 0
if (*lexems)[i+2].Type != isRPar {
   count++
}
</code></pre></div><p>コントラクトの呼び出しにおいて、呼び出されたパラメータのリストUsedが存在します。そのため、コントラクトが呼び出された場合には、このケースをマークする必要があります。もしパラメータなしでコントラクトが呼び出された場合、少なくとも2つの空のパラメータを追加して<strong>ExecContract</strong>を呼び出す必要があります。</p> <div class="language- extra-class"><pre class="language-text"><code>if isContract {
   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))
   for j := len(*block) - 1; j &gt;= 0; j-- {
   topblock := (*block)[j]
      if topblock.Type == ObjContract {
         if topblock.Info.(*ContractInfo).Used == nil {
            topblock.Info.(*ContractInfo).Used = make(map[string]bool)
         }
         topblock.Info.(*ContractInfo).Used[name] = true
      }
   }
   bytecode = append(bytecode, &amp;ByteCode{cmdPush, name})
   if count == 0 {
      count = 2
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
   }
   count++
}
</code></pre></div><p>もし次に角括弧がある場合、<strong>cmdIndex</strong>コマンドを追加してインデックスによって値を取得します。</p> <div class="language- extra-class"><pre class="language-text"><code>if (*lexems)[i+1].Type == isLBrack {
   if objInfo == nil || objInfo.Type != ObjVar {
      return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))
   }
   buffer = append(buffer, &amp;ByteCode{cmdIndex, 0})
}
</code></pre></div><p><strong>CompileBlock</strong>関数は、オブジェクトツリーや式に依存しないバイトコードを生成することができます。コンパイルプロセスは、レキシカルアナライザと同様に有限状態機械に基づいていますが、以下の点が異なります。まず、シンボルではなくトークンを使用します。次に、すべての状態と遷移で<em>states</em>変数を直接記述します。これは、トークンタイプでインデックスされるオブジェクトの配列を表しています。各トークンは<em>compileState</em>の構造を持ち、<em>NewState</em>で新しい状態を指定します。解決した構造が明確な場合、<em>Func</em>フィールドにハンドラーの関数を指定できます。</p> <p>例として、主な状態を見直しましょう。</p> <p>改行またはコメントが現れた場合、同じ状態のままにします。<strong>contract</strong>キーワードが現れた場合、状態を<em>stateContract</em>に変更し、構造の解析を開始します。<strong>func</strong>キーワードが現れた場合、状態を<em>stateFunc</em>に変更します。その他のトークンが受信された場合、エラーを生成する関数が呼び出されます。</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateRoot
   lexNewLine: {stateRoot, 0},
   lexKeyword | (keyContract &lt;&lt; 8): {stateContract | statePush, 0},
   lexKeyword | (keyFunc &lt;&lt; 8): {stateFunc | statePush, 0},
   lexComment: {stateRoot, 0},
   0: {errUnknownCmd, cfError},
},
</code></pre></div><p>例えば、<strong>func</strong>キーワードが現れ、状態が<em>stateFunc</em>に変更されたとします。関数名は<strong>func</strong>キーワードの後に続く必要があるため、関数名を変更する際には同じ状態のままにします。その他のトークンに対しては、対応するエラーを生成します。トークン識別子で関数名を取得した場合、<em>stateFParams</em>状態に移行し、関数のパラメータを取得できます。</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateFunc
   lexNewLine: {stateFunc, 0},
   lexIdent: {stateFParams, cfNameBlock},
   0: {errMustName, cfError},
},
</code></pre></div><p>上記の操作と同時に、<strong>fNameBlock</strong>関数を呼び出します。注意点として、Block構造体はstatePushマークで作成されます。ここで、バッファから取得し必要なデータを埋め込みます。<strong>fNameBlock</strong>関数は、関数や契約（それらにネストされたものも含む）に適しています。それは対応する構造体である<em>Info</em>フィールドを埋め、自身を親ブロックの<em>Objects</em>に書き込みます。これにより、指定した名前で関数または契約を呼び出すことができます。同様に、すべての状態と変数に対して対応する関数を作成します。これらの関数は通常非常に小さく、仮想マシンツリーの構築時にいくつかの作業を行います。</p> <div class="language- extra-class"><pre class="language-text"><code>func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {
   var itype int
   prev := (*buf)[len(*buf)-2]
   fblock := (*buf)[len(*buf)-1]
   name := lexem.Value.(string)
   switch state {
      case stateBlock:
         itype = ObjContract
         name = StateName((*buf)[0].Info.(uint32), name)
         fblock.Info = &amp;ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,
         Owner: (*buf)[0].Owner}
      default:
         itype = ObjFunc
         fblock.Info = &amp;FuncInfo{}
   }
   fblock.Type = itype
   prev.Objects[name] = &amp;ObjInfo{Type: itype, Value: fblock}
   return nil
}
</code></pre></div><p><strong>CompileBlock</strong>関数では、すべてのトークンを走査し、ステートに基づいてステートを切り替えます。ほとんどの追加トークンは、追加のプログラムコードに対応しています。</p> <ul><li><strong>statePush</strong> - <strong>Block</strong>オブジェクトをオブジェクトツリーに追加します。</li> <li><strong>statePop</strong> - ブロックが閉じ括弧で終わる場合に使用されます。</li> <li><strong>stateStay</strong> - 新しいステートに移行する際に、現在のマークを保持する必要があります。</li> <li><strong>stateToBlock</strong> - <em>while</em>や<em>if</em>を処理するために<strong>stateBlock</strong>ステートに移行します。式の処理が終わった後、括弧内のブロックを処理する必要があります。</li> <li><strong>stateToBody</strong> - <strong>stateBody</strong>ステートに移行します。</li> <li><strong>stateFork</strong> - マークされた位置を保存します。識別子または<code>$</code>で始まる名前から式が始まる場合、関数呼び出しや代入が行われる可能性があります。</li> <li><strong>stateToFork</strong> - <strong>stateFork</strong>に格納されたトークンを取得するために使用され、プロセス関数に渡されます。</li> <li><strong>stateLabel</strong> - <strong>cmdLabel</strong>コマンドを挿入するために使用されます。<em>while</em>構造ではこのフラグが必要です。</li> <li><strong>stateMustEval</strong> - <em>if</em>や<em>while</em>構造の先頭で条件式が利用可能かどうかをチェックします。</li></ul> <p>また、<strong>CompileBlock</strong>関数以外にも<strong>FlushBlock</strong>関数について触れる必要があります。ただし、問題はブロックツリーが既存の仮想マシンとは独立して構築されていることです。より具体的には、仮想マシンに存在する関数やコントラクトの情報を取得しますが、コンパイルされたブロックは別のツリーに収集されます。コンパイル中にエラーが発生した場合、仮想マシンを前の状態に戻す必要があります。そのため、コンパイルツリーは別途移動し、コンパイルが成功した後に<strong>FlushContract</strong>関数を呼び出す必要があります。この関数は完了したブロックツリーを現在の仮想マシンに追加します。コンパイルフェーズはこれで完了です。</p> <h2 id="lexical-analyzer"><a href="#lexical-analyzer" class="header-anchor">#</a> 字句解析器 </h2> <p>字句解析器は入力文字列を処理し、以下の種類のトークンのシーケンスを形成します:</p> <ul><li><strong>lexSys</strong> - システムトークン、例: <code>{}, [], (), ,, .</code> など;</li> <li><strong>lexOper</strong> - 演算子トークン、例: <code>+, -, /, \, *</code>;</li> <li><strong>lexNumber</strong> - 数値;</li> <li><strong>lexident</strong> - 識別子;</li> <li><strong>lexNewline</strong> - 改行文字;</li> <li><strong>lexString</strong> - 文字列;</li> <li><strong>lexComment</strong> - コメント;</li> <li><strong>lexKeyword</strong> - キーワード;</li> <li><strong>lexType</strong> - 型;</li> <li><strong>lexExtend</strong> - 外部変数や関数への参照、例: <code>$myname</code>。</li></ul> <p>現在のバージョンでは、トークンを解析するために最初に <a href="#lextable-lextable-go">script/lextable/lextable.go</a> ファイルを使用して変換テーブル（有限状態機械）が初期に構築され、lex_table.go ファイルに書き込まれます。一般的には、ファイルで初期に生成された変換テーブルから解放され、起動時にメモリ内に変換テーブルを作成することができます。字句解析自体は、<a href="#lex-go">lex.go</a> ファイルの lexParser 関数で行われます。</p> <h3 id="lextable-lextable-go"><a href="#lextable-lextable-go" class="header-anchor">#</a> lextable/lextable.go </h3> <p>ここでは、操作するアルファベットを定義し、受け取った次のシンボルに基づいて有限状態機械がどのように状態から別の状態に変化するかを説明します。</p> <p><em>states</em> は、状態のリストを含む JSON オブジェクトです。</p> <p>特定のシンボル以外の場合、<code>d</code> は状態で指定されていないすべてのシンボルを示します。
<code>n</code> は 0x0a を、<code>s</code> は空白を、<code>q</code> はバッククォートを、<code>Q</code> はダブルクォートを、<code>r</code> は文字 &gt;= 128 を、<code>a</code> は AZ と az を、<code>1</code> は 1-9 を示します。</p> <p>これらの状態の名前はキーであり、可能な値は値オブジェクトにリストされています。次に、各グループに対して遷移するための新しい状態があります。その後にはトークンの名前があります。初期状態に戻る必要がある場合は、第3パラメーターがサービストークンであり、現在のシンボルの処理方法を示します。</p> <p>たとえば、メインの状態と次の文字 <code>/</code> の場合、<code>&quot;/&quot;: [&quot;solidus&quot;, &quot;&quot;, &quot;push next&quot;]</code> となります。</p> <ul><li><strong>push</strong> - 別のスタックに存在することを記憶するコマンドを与えます。</li> <li><strong>next</strong> - 次の文字に進み、同時に状態を <strong>solidus</strong> に変更します。その後、次の文字を取得し、<strong>solidus</strong> の状態をチェックします。</li></ul> <p>次の文字が <code>/</code> または <code>/*</code> の場合、<code>//</code> または <code>/*</code> で始まるため、コメント <strong>comment</strong> の状態に移行します。明らかに、各コメントにはその後に異なる状態がありますが、異なる記号で終了します。</p> <p>次の文字が <code>/</code> または <code>*</code> でない場合、スタック内のすべてのものを <strong>lexOper</strong> タイプのタグとして記録し、スタックをクリアしてメインの状態に戻ります。</p> <p>次のモジュールでは、状態ツリーを数値配列に変換し、<em>lex_table.go</em> ファイルに書き込みます。</p> <p>最初のループでは、有効なシンボルのアルファベットを形成します。</p> <div class="language- extra-class"><pre class="language-text"><code>for ind, ch := range alphabet {
   i := byte(ind)
</code></pre></div><p>In addition, in <strong>state2int</strong>, we provide each state with its own sequence identifier.</p> <div class="language- extra-class"><pre class="language-text"><code>   state2int := map[string]uint{`main`: 0}
   if err := json.Unmarshal([]byte(states), &amp;data); err == nil {
   for key := range data {
   if key != `main` {
   state2int[key] = uint(len(state2int))
</code></pre></div><p>When we traverse all states and each set in a state and each symbol in a set, we write a three-byte number [new state identifier (0 = main)] + [token type ( 0-no token)] + [token].
The bidimensionality of the <em>table</em> array is that it is divided into states and 34 input symbols from the <em>alphabet</em> array, which are arranged in the same order.
We are in the <em>main</em> state on the zero row of the <em>table</em>. Take the first character, find its index in the <em>alphabet</em> array, and get the value from the column with the given index. Starting from the value received, we receive the token in the low byte. If the parsing is complete, the second byte indicates the type of token received. In the third byte, we receive the index of the next new state.
All of these are described in more detail in the <strong>lexParser</strong> function in <em>lex.go</em>.
If you want to add some new characters, you need to add them to the <em>alphabet</em> array and increase the quantity of the <em>AlphaSize</em> constant. If you want to add a new symbol combination, it should be described in the status, similar to the existing options. After the above operation, run the <em>lextable.go</em> file to update the <em>lex_table.go</em> file.</p> <h3 id="lex-go"><a href="#lex-go" class="header-anchor">#</a> lex.go </h3> <p>The <strong>lexParser</strong> function directly generates lexical analysis and returns an array of received tags based on incoming strings. Let us analyze the structure of tokens.</p> <div class="language- extra-class"><pre class="language-text"><code>type Lexem struct {
   Type  uint32 // Type of the lexem
   Value interface{} // Value of lexem
   Line  uint32 // Line of the lexem
   Column uint32 // Position inside the line
}
</code></pre></div><ul><li><strong>Type</strong> - トークンのタイプ。次のいずれかの値を持ちます: <code>lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend</code></li> <li><strong>Value</strong> - トークンの値。値のタイプはトークンのタイプに依存します。詳細は次のようになります:
<ul><li><strong>lexSys</strong> - 括弧、カンマなどが含まれます。この場合、<code>Type = ch &lt;&lt; 8 | lexSys</code> となります。<code>isLPar ... isRBrack</code> 定数を参照し、その値は uint32 ビットです。</li> <li><strong>lexOper</strong> - 値は uint32 形式の等価な文字列です。<code>isNot ... isOr</code> 定数を参照してください。</li> <li><strong>lexNumber</strong> - 数値は int64 または float64 として格納されます。数値に小数点がある場合、float64 です。</li> <li><strong>lexIdent</strong> - 識別子は文字列として格納されます。</li> <li><strong>lexNewLine</strong> - 改行文字です。行とトークンの位置を計算するためにも使用されます。</li> <li><strong>lexString</strong> - 文字列は文字列として格納されます。</li> <li><strong>lexComment</strong> - コメントは文字列として格納されます。</li> <li><strong>lexKeyword</strong> - キーワードの場合、対応するインデックスのみが格納されます。<code>keyContract ... keyTail</code> 定数を参照してください。この場合、<code>Type = KeyID &lt;&lt; 8 | lexKeyword</code> となります。さらに、<code>true, false, nil</code> のキーワードは直ちに lexNumber タイプのトークンに変換され、対応する <code>bool</code> 型および <code>interface {}</code> 型が使用されます。</li> <li><strong>lexType</strong> - この値には、対応する <code>reflect.Type</code> 型の値が含まれます。</li> <li><strong>lexExtend</strong> - <code>$</code> で始まる識別子。これらの変数と関数は外部から渡されるため、特別な種類のトークンに割り当てられます。この値には、先頭の $ を含まない名前が文字列として格納されます。</li></ul></li> <li><strong>Line</strong> - トークンが見つかった行番号。</li> <li><strong>Column</strong> - トークンの行内位置。</li></ul> <p><strong>lexParser</strong> 関数を詳細に解析しましょう。<strong>todo</strong> 関数は、現在の状態と入力されたシンボルに基づいて、アルファベット内のシンボルのインデックスを調べ、新しい状態、トークン識別子（存在する場合）、および変換テーブルから他のトークンを取得します。解析自体は、次の文字ごとに<strong>todo</strong>関数を呼び出し、新しい状態に切り替えながら進めることで行われます。タグを受け取ったら、対応するトークンを出力基準に作成し、解析プロセスを続行します。解析プロセスでは、トークンのシンボルを別のスタックや配列に蓄積することはせず、トークンの開始オフセットのみを保存します。トークンを取得した後、次のトークンのオフセットを現在の解析位置に移動します。</p> <p>解析中に使用される字句ステータストークンをチェックします:</p> <ul><li><strong>lexfPush</strong> - このトークンは新しいトークンのシンボルの蓄積が開始されたことを意味します。</li> <li><strong>lexfNext</strong> - 文字を現在のトークンに追加する必要があります。</li> <li><strong>lexfPop</strong> - トークンの取得が完了しました。通常、解析されたトークンの識別子タイプがあります。</li> <li><strong>lexfSkip</strong> - このトークンは解析から除外するために使用されます。たとえば、文字列内の制御スラッシュは \n \r &quot; です。これらは、字句解析の段階で自動的に置き換えられます。</li></ul> <h2 id="needle-language"><a href="#needle-language" class="header-anchor">#</a> Needle言語 </h2> <h3 id="lexemes"><a href="#lexemes" class="header-anchor">#</a> 字句 </h3> <p>プログラムのソースコードはUTF-8エンコーディングである必要があります。</p> <p>次の字句タイプが処理されます:</p> <ul><li><strong>Keywords</strong> - <code>action, break, conditions, continue, contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while</code></li> <li><strong>Number</strong> - 十進数のみが受け入れられます。基本的な2つのタイプがあります: <strong>int</strong> と <strong>float</strong>。数値に小数点が含まれている場合、それは <strong>float</strong> となります。<strong>int</strong> 型は golang の <strong>int64</strong> に相当し、<strong>float</strong> 型は golang の <strong>float64</strong> に相当します。</li> <li><strong>String</strong> - 文字列は二重引用符 <code>(&quot;a string&quot;)</code> またはバッククォート <code>(`a string`)</code> で囲むことができます。両方のタイプの文字列は改行文字を含むことができます。二重引用符で囲まれた文字列には、スラッシュでエスケープされた二重引用符、改行文字、復帰文字を含めることができます。例: <code>&quot;This is a \&quot;first string\&quot;.\r\nThis is a second string.&quot;</code></li> <li><strong>Comment</strong> - 2つのタイプのコメントがあります。1行コメントは2つのスラッシュ (//) を使用します。例: // This is a single-line comment. 複数行コメントはスラッシュとアスタリスク記号を使用し、複数行にわたることができます。例: <code>/* This is a multi-line comment */</code></li> <li><strong>Identifier</strong> - 変数や関数の名前は、a-zおよびA-Zの文字、UTF-8のシンボル、数字、アンダースコアで構成されます。名前は文字、アンダースコア、<code>@</code> または <code>$</code> で始まることができます。<code>$</code> で始まる名前は、<strong>dataセクション</strong>で定義された変数の名前です。<code>$</code> で始まる名前は、<strong>conditionsセクション</strong>および<strong>actionセクション</strong>のスコープでグローバル変数を定義するためにも使用できます。エコシステムの契約は <code>@</code> 記号を使用して呼び出すことができます。例: <code>@1NewTable(...)</code></li></ul> <h3 id="types"><a href="#types" class="header-anchor">#</a> 型 </h3> <p>Needleの型の横に対応するgolangの型が指定されています。</p> <ul><li><strong>bool</strong> - bool, デフォルトは <strong>false</strong>;</li> <li><strong>bytes</strong> - []byte{}, デフォルトは空のバイト配列;</li> <li><strong>int</strong> - int64, デフォルトは <strong>0</strong>;</li> <li><strong>address</strong> - uint64, デフォルトは <strong>0</strong>;</li> <li><strong>array</strong> - []interface{}, デフォルトは空の配列;</li> <li><strong>map</strong> - map[string]interface{}, デフォルトは空のオブジェクト配列;</li> <li><strong>money</strong> - decimal, デフォルトは <strong>0</strong>;</li> <li><strong>float</strong> - float64, デフォルトは <strong>0</strong>;</li> <li><strong>string</strong> - string, デフォルトは空の文字列;</li> <li><strong>file</strong> - map[string]interface{}, デフォルトは空のオブジェクト配列;</li></ul> <p>これらの変数の型は <code>var</code> キーワードで定義されます。例: <code>var var1, var2 int</code>。このように定義すると、変数は型に応じたデフォルト値で初期化されます。</p> <p>すべての変数の値はinterface{}型であり、必要なgolangの型に代入されます。したがって、例えば、arrayとmapの型はgolangの []interface{} および map[string]interface{} です。両方の配列タイプは任意の型の要素を含むことができます。</p> <h3 id="expressions"><a href="#expressions" class="header-anchor">#</a> 式 </h3> <p>式には算術演算、論理演算、関数呼び出しが含まれることがあります。すべての式は演算子の優先順位に従って左から右に評価されます。優先順位が等しい場合、演算子は左から右に評価されます。</p> <p>演算の優先順位は高から低へと続きます：</p> <ul><li><strong>関数呼び出しと括弧</strong> - 関数が呼び出されると、渡されたパラメータは左から右に計算されます。</li> <li><strong>単項演算</strong> - 論理否定 <code>!</code> および算術符号変更 <code>-</code></li> <li><strong>乗算と除算</strong> - 算術乗算 <code>*</code> および除算 <code>/</code></li> <li><strong>加算と減算</strong> - 算術加算 <code>+</code> および減算 <code>-</code></li> <li><strong>論理比較</strong> - <code>&gt;=&gt;&gt; &gt;=</code></li> <li><strong>論理等価と不等価</strong> - <code>== !=</code></li> <li><strong>論理 AND</strong> - <code>&amp;&amp;</code></li> <li><strong>論理 OR</strong> - <code>||</code></li></ul> <p>論理 AND および OR の評価では、式の両側が常に評価されます。</p> <p>Needleでは、コンパイル中に型チェックは行われません。オペランドの評価時には、型をより複雑な型に変換しようとします。複雑さの順序に応じた型は次のようになります：<code>string、int、float、money</code>。型変換の一部しか実装されていません。string 型では、加算演算がサポートされ、結果は文字列の連結になります。例えば、<code>string + string = string, money - int = money, int * float = float</code>。</p> <p>関数の場合、実行時に <code>string</code> 型および <code>int</code> 型の型チェックが行われます。</p> <p><strong>array</strong> 型および <strong>map</strong> 型は、インデックスでアクセスできます。<strong>array</strong> 型の場合、インデックスとして <strong>int</strong> 値を指定する必要があります。<strong>map</strong> 型の場合、変数または <strong>string</strong> 値を指定する必要があります。インデックスが現在の最大インデックスよりも大きい <strong>array</strong> 要素に値を割り当てる場合、配列に空の要素が追加されます。これらの要素の初期値は <strong>nil</strong> です。例えば： .. code:</p> <div class="language- extra-class"><pre class="language-text"><code>var my array
my[5] = 0
var mymap map
mymap[&quot;index&quot;] = my[3]
</code></pre></div><p>In expressions of conditional logical values (such as <code>if, while, &amp;&amp;, ||, !</code>), the type is automatically converted to a logical value. If the type is not the default value, it is true.</p> <div class="language- extra-class"><pre class="language-text"><code>var mymap map
var val string
if mymap &amp;&amp; val {
...
}
</code></pre></div><h3 id="scope"><a href="#scope" class="header-anchor">#</a> スコープ </h3> <p>中括弧は、ローカルスコープ変数を含むことができるブロックを指定します。デフォルトでは、変数のスコープはその独自のブロックとすべてのネストされたブロックに拡張されます。ブロック内で、既存の変数の名前を使用して新しい変数を定義することができます。ただし、この場合、同じ名前の外部変数は利用できなくなります。</p> <div class="language- extra-class"><pre class="language-text"><code>var a int
a = 3
{
   var a int
   a = 4
   Println(a) // 4
}
Println(a) // 3
</code></pre></div><h3 id="contract-execution"><a href="#contract-execution" class="header-anchor">#</a> コントラクトの実行 </h3> <p>コントラクトを呼び出す際には、<strong>data</strong> で定義されたパラメータを渡す必要があります。コントラクトを実行する前に、仮想マシンはこれらのパラメータを受け取り、対応する変数（$Param）に割り当てます。その後、事前に定義された <strong>conditions</strong> 関数と <strong>action</strong> 関数が呼び出されます。</p> <p>コントラクトの実行中に発生するエラーは、フォームエラーと環境エラーの2つのタイプに分類されます。フォームエラーは、特別なコマンド（<code>error, warning, info</code>）や、組み込み関数が <code>err</code> を <em>nil</em> 以外に返す場合に生成されます。</p> <p>Needle言語では例外処理は行われません。任意のエラーがコントラクトの実行を終了させます。コントラクトの実行時には、別々のスタックと変数値保存用の構造体が作成されるため、ゴミ回収メカニズムがこれらのデータを自動的に削除します。</p> <h3 id="backus-naur-form-bnf"><a href="#backus-naur-form-bnf" class="header-anchor">#</a> バッカス・ナウア形式（BNF） </h3> <p>コンピュータ科学では、BNFはコンテキストフリー構文の表記技法であり、通常、コンピューティングで使用される言語の構文を記述するために使用されます。</p> <ul><li><p>&lt;decimal digit&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
</code></pre></div></li> <li><p>&lt;decimal number&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; {&lt;decimal digit&gt;}
</code></pre></div></li> <li><p>&lt;symbol code&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'''&lt;any symbol&gt;'''
</code></pre></div></li> <li><p>&lt;real number&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number'.'[&lt;decimal number&gt;]
</code></pre></div></li> <li><p>&lt;integer number&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number&gt; | &lt;symbol code&gt;
</code></pre></div></li> <li><p>&lt;number&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'&lt;integer number&gt; | &lt;real number&gt;'
</code></pre></div></li> <li><p>&lt;letter&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF
</code></pre></div></li> <li><p>&lt;space&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'0x20'
</code></pre></div></li> <li><p>&lt;tabulation&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'0x09'
</code></pre></div></li> <li><p>&lt;newline&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'0x0D 0x0A'
</code></pre></div></li> <li><p>&lt;special symbol&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'!' |'&quot;' |'$' |''' |'(' |')' |'\*' |'+' |',' |'-' |'.' |'/ '|'&lt;' |'=' |'&gt;' |'[' |'\\' |']' |'_' |'|' |'}' | '{' | &lt;tabulation&gt; | &lt;space&gt; | &lt;newline&gt;
</code></pre></div></li> <li><p>&lt;symbol&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; | &lt;letter&gt; | &lt;special symbol&gt;
</code></pre></div></li> <li><p>&lt;name&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>(&lt;letter&gt; |'_') {&lt;letter&gt; |'_' | &lt;decimal digit&gt;}
</code></pre></div></li> <li><p>&lt;function name&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;variable name&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;type name&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;string symbol&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;tabulation&gt; | &lt;space&gt; |'!' |'#' | ... |'[' |']' | ...
</code></pre></div></li> <li><p>&lt;string element&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>{&lt;string symbol&gt; |'\&quot;' |'\n' |'\r'}
</code></pre></div></li> <li><p>&lt;string&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'&quot;' {&lt;string element&gt;}'&quot;' |'\`' {&lt;string element&gt;}'\`'
</code></pre></div></li> <li><p>&lt;assignment operator&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'='
</code></pre></div></li> <li><p>&lt;unary operator&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'-'
</code></pre></div></li> <li><p>&lt;binary operator&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'==' |'!=' |'&gt;' |'&lt;' |'&lt;=' |'&gt;=' |'&amp;&amp;' |'||' |'\*' |'/' |'+ '|'-'
</code></pre></div></li> <li><p>&lt;operator&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;assignment operator&gt; | &lt;unary operator&gt; | &lt;binary operator&gt;
</code></pre></div></li> <li><p>&lt;parameters&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;expression&gt; {','&lt;expression&gt;}
</code></pre></div></li> <li><p>&lt;contract call&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract name&gt;'(' [&lt;parameters&gt;]')'
</code></pre></div></li> <li><p>&lt;function call&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract call&gt; [{'.' &lt;name&gt;'(' [&lt;parameters&gt;]')'}]
</code></pre></div></li> <li><p>&lt;block contents&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;block command&gt; {&lt;newline&gt;&lt;block command&gt;}
</code></pre></div></li> <li><p>&lt;block&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'{'&lt;block contents&gt;'}'
</code></pre></div></li> <li><p>&lt;block command&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>(&lt;block&gt; | &lt;expression&gt; | &lt;variables definition&gt; | &lt;if&gt; | &lt;while&gt; | break | continue | return)
</code></pre></div></li> <li><p>&lt;if&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'if &lt;expression&gt;&lt;block&gt; [else &lt;block&gt;]'
</code></pre></div></li> <li><p>&lt;while&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'while &lt;expression&gt;&lt;block&gt;'
</code></pre></div></li> <li><p>&lt;contract&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'contract &lt;name&gt; '{'[&lt;data section&gt;] {&lt;function&gt;} [&lt;conditions&gt;] [&lt;action&gt;]'}''
</code></pre></div></li> <li><p>&lt;data section&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'data '{' {&lt;data parameter&gt;&lt;newline&gt;} '}''
</code></pre></div></li> <li><p>&lt;data parameter&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; &lt;type name&gt;'&quot;'{&lt;tag&gt;}'&quot;'
</code></pre></div></li> <li><p>&lt;tag&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'optional | image | file | hidden | text | polymap | map | address | signature:&lt;name&gt;'
</code></pre></div></li> <li><p>&lt;conditions&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'conditions &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;action&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'action &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;function&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'func &lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'[{&lt;tail&gt;}] [&lt;type name&gt;] &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;variable description&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; {',' &lt;variable name&gt;} &lt;type name&gt;
</code></pre></div></li> <li><p>&lt;tail&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'.'&lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'
</code></pre></div></li> <li><p>&lt;variables definition&gt;</p> <div class="language- extra-class"><pre class="language-text"><code>'var &lt;variable description&gt;{','&lt;variable description&gt;}'
</code></pre></div></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/IBAX-io/documentation/edit/master/docs/ja/topics/vm.md" target="_blank" rel="noopener noreferrer">GitHubでこのページを編集する</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">最終更新:</span> <span class="time">2023/6/12 13:10:24</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ja/topics/templates2.html" class="prev">
        テンプレート言語 
      </a></span> <span class="next"><a href="/ja/topics/daemons.html">
        デーモン 
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1e099771.js" defer></script><script src="/assets/js/2.8d94a0db.js" defer></script><script src="/assets/js/101.c3ecbdaa.js" defer></script>
  </body>
</html>
