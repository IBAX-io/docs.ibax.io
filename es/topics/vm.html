<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Compilador y máquina virtual </a></li><li><a href="/es/topics/templates2.html" class="sidebar-link">Lenguaje de plantillas </a></li><li><a href="/es/topics/vm.html" aria-current="page" class="active sidebar-link">Compilador y máquina virtual </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/es/topics/vm.html#source-code-storage-and-compilation" class="sidebar-link">Almacenamiento y compilación de código fuente </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#virtual-machine-structures" class="sidebar-link">Estructuras de la máquina virtual  </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/es/topics/vm.html#vm-structure" class="sidebar-link">Estructura VM </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#block-structure" class="sidebar-link">Estructura de bloque </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#objinfo-structure" class="sidebar-link">Estructura ObjInfo </a></li></ul></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#virtual-machine-commands" class="sidebar-link">Instrucciones de la máquina virtual </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/es/topics/vm.html#bytecode-structure" class="sidebar-link">Estructura ByteCode </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#command-identifiers" class="sidebar-link">Identificadores de comando </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#stack-operation-commands" class="sidebar-link">Instrucciones de operación de pila </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#runtime-structure" class="sidebar-link">Estructura Runtime </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#runcode-function" class="sidebar-link">Función RunCode </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#other-functions-for-operations-with-vm" class="sidebar-link">Otras funciones de la VM </a></li></ul></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#compiler" class="sidebar-link">Compilador </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#lexical-analyzer" class="sidebar-link">Analizador léxico </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/es/topics/vm.html#lextable-lextable-go" class="sidebar-link">lextable/lextable.go </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#lex-go" class="sidebar-link">lex.go </a></li></ul></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#needle-language" class="sidebar-link">Lenguaje Needle </a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/es/topics/vm.html#lexemes" class="sidebar-link">Lexemas </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#types" class="sidebar-link">Tipos </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#expressions" class="sidebar-link">Expresiones </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#scope" class="sidebar-link">Ámbito </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#contract-execution" class="sidebar-link">Ejecución de contratos </a></li><li class="sidebar-sub-header"><a href="/es/topics/vm.html#backus-naur-form-bnf" class="sidebar-link">Forma Backus-Naur (BNF) </a></li></ul></li></ul></li><li><a href="/es/topics/daemons.html" class="sidebar-link">Demonio </a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="compiler-and-virtual-machine"><a href="#compiler-and-virtual-machine" class="header-anchor">#</a> Compilador y máquina virtual </h1> <ul><li><a href="#source-code-storage-and-compilation">Almacenamiento y compilación de código fuente</a></li> <li><a href="#virtual-machine-structures">Estructuras de la máquina virtual</a> <ul><li><a href="#vm-structure">Estructura VM</a></li> <li><a href="#block-structure">Estructura de bloque</a></li> <li><a href="#objinfo-structure">Estructura ObjInfo</a> <ul><li><a href="#contractinfo-structure">Estructura ContractInfo</a> <ul><li><a href="#fieldinfo-structure">Estructura FieldInfo</a></li></ul></li> <li><a href="#funcinfo-structure">Estructura FuncInfo</a> <ul><li><a href="#funcname-structure">Estructura FuncName</a></li></ul></li> <li><a href="#extfuncinfo-structure">Estructura ExtFuncInfo</a></li> <li><a href="#varinfo-structure">Estructura VarInfo</a></li> <li><a href="#objextend-value">Valor ObjExtend</a></li></ul></li></ul></li> <li><a href="#virtual-machine-commands">Instrucciones de la máquina virtual</a> <ul><li><a href="#bytecode-structure">Estructura ByteCode</a></li> <li><a href="#command-identifiers">Identificadores de comando</a></li> <li><a href="#stack-operation-commands">Instrucciones de operación de pila</a></li> <li><a href="#runtime-structure">Estructura Runtime</a> <ul><li><a href="#blockstack-structure">Estructura blockStack</a></li></ul></li> <li><a href="#runcode-function">Función RunCode</a></li> <li><a href="#other-functions-for-operations-with-vm">Otras funciones de la VM</a></li></ul></li> <li><a href="#compiler">Compilador</a></li> <li><a href="#lexical-analyzer">Analizador léxico</a> <ul><li><a href="#lextable-lextable-go">lextable/lextable.go</a></li> <li><a href="#lex-go">lex.go</a></li></ul></li> <li><a href="#needle-language">Lenguaje Needle</a> <ul><li><a href="#lexemes">Lexemas</a></li> <li><a href="#types">Tipos</a></li> <li><a href="#expressions">Expresiones</a></li> <li><a href="#scope">Ámbito</a></li> <li><a href="#contract-execution">Ejecución de contratos</a></li> <li><a href="#backus-naur-form-bnf">Forma Backus-Naur (BNF)</a></li></ul></li></ul> <p>Esta sección cubre la compilación de programas y operaciones en el lenguaje Needle en la máquina virtual.</p> <h2 id="source-code-storage-and-compilation"><a href="#source-code-storage-and-compilation" class="header-anchor">#</a> Almacenamiento y compilación de código fuente </h2> <p>Los contratos inteligentes y las funciones están escritos en lenguaje Go y se almacenan en la tabla de contratos inteligentes del ecosistema.</p> <p>Al ejecutar un contrato inteligente, se lee su código fuente de la base de datos y se compila en bytecode.</p> <p>Cuando se realiza un cambio en el contrato inteligente, su código fuente se actualiza y se guarda en la base de datos. Luego, se compila el código fuente, lo que resulta en un cambio en el bytecode correspondiente.</p> <p>El bytecode no se almacena físicamente en ningún lugar, por lo que cuando se ejecuta el programa nuevamente, se vuelve a compilar el código fuente.</p> <p>Todo el código fuente descrito en la tabla de contratos inteligentes del ecosistema se compila estrictamente en orden en una máquina virtual, cuyo estado es el mismo en todos los nodos.</p> <p>Cuando se llama a un contrato inteligente, la máquina virtual no cambia su estado de ninguna manera. La ejecución de cualquier contrato inteligente o llamada a función ocurre en una pila de ejecución separada creada en cada llamada externa.</p> <p>Cada ecosistema puede tener un llamado &quot;ecosistema virtual&quot;, que se puede utilizar junto con una tabla de datos fuera de la cadena en un solo nodo y no puede afectar directamente a la cadena de bloques o a otros ecosistemas virtuales. En este caso, el nodo que aloja este ecosistema virtual compilará sus contratos inteligentes y creará su propia máquina virtual.</p> <h2 id="virtual-machine-structures"><a href="#virtual-machine-structures" class="header-anchor">#</a> Estructuras de la máquina virtual  </h2> <h3 id="vm-structure"><a href="#vm-structure" class="header-anchor">#</a> Estructura VM </h3> <p>La máquina virtual se define en la memoria de acuerdo con la siguiente estructura.</p> <div class="language- extra-class"><pre class="language-text"><code>type VM struct {
    Block
    ExtCost       func(string) int64
    FuncCallsDB   map[string]struct{}
    Extern        bool
    ShiftContract int64
    logger        *log.Entry
}
</code></pre></div><p>La estructura VM tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Block</strong> - Contiene una <a href="#block-structure">estructura de bloque</a>;</li> <li><strong>ExtCost</strong> - Una función que devuelve el costo de ejecución de una función externa de Golang;</li> <li><strong>FuncCallsDB</strong> - Una colección de nombres de funciones de Golang que devuelven el costo de procesamiento de la base de datos como primer parámetro. Estas funciones utilizan <strong>EXPLAIN</strong> para calcular el costo;</li> <li><strong>Extern</strong> - Una identificación booleana que indica si el contrato inteligente es externo. Cuando se crea la VM, se establece en verdadero y no es necesario llamar explícitamente al contrato inteligente compilado. Esto permite llamar al código del contrato inteligente que se determinará en el futuro;</li> <li><strong>ShiftContract</strong> - El ID del primer contrato inteligente en la VM;</li> <li><strong>logger</strong> - La salida de registro de errores de la VM.</li></ul></blockquote> <h3 id="block-structure"><a href="#block-structure" class="header-anchor">#</a> Estructura de bloque </h3> <p>La máquina virtual está compuesta por un árbol de objetos del tipo <strong>Block type</strong>.</p> <p>Un bloque es una unidad independiente que contiene algunos bytes de código. En pocas palabras, todo lo que se coloca dentro de los corchetes (<code>{}</code>) de un lenguaje es un bloque.</p> <p>Por ejemplo, el siguiente código crea un bloque con una función. Este bloque contiene otro bloque con una declaración <em>if</em>, que a su vez contiene otro bloque con una declaración <em>while</em>.</p> <div class="language- extra-class"><pre class="language-text"><code>func my() {
     if true {
          while false {
               ...
           }
     }
} 
</code></pre></div><p>El bloque se define en la memoria con la siguiente estructura:</p> <div class="language- extra-class"><pre class="language-text"><code>type Block struct {
    Objects  map[string]*ObjInfo
    Type     int
    Owner    *OwnerInfo
    Info     interface{}
    Parent   *Block
    Vars     []reflect.Type
    Code     ByteCodes
    Children Blocks
}
</code></pre></div><p>La estructura de bloque tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Objects</strong> - Un mapeo de objetos internos de tipo puntero <a href="#objinfo-structure">ObjInfo</a>. Por ejemplo, si hay una variable en el bloque, se puede obtener información sobre ella a través de su nombre;</li> <li><strong>Typeo</strong> - El tipo de bloque. Cuando el bloque es una función, el tipo es <strong>ObjFunc</strong>. Cuando el bloque es un contrato inteligente, el tipo es <strong>ObjContract</strong>;</li> <li><strong>Owner</strong> - Una estructura de tipo puntero <strong>OwnerInfo</strong>. Esta estructura contiene información sobre el propietario del contrato inteligente compilado. Se especifica durante la compilación del contrato inteligente o se obtiene de la tabla <strong>contracts</strong>;</li> <li><strong>Info</strong> - Contiene información sobre el objeto, que depende del tipo de bloque;</li> <li><strong>Parent</strong> - Un puntero que apunta al bloque padre;</li> <li><strong>Vars</strong> - Un array que contiene el tipo de variables del bloque actual;</li> <li><strong>Code</strong> - El bytecode del bloque en sí mismo, que se ejecutará cuando el control se transfiera a este bloque, por ejemplo, en una llamada de función o en un bucle;</li> <li><strong>Children</strong>* - Un array que contiene bloques secundarios, como funciones anidadas, bucles y operadores condicionales.</li></ul></blockquote> <h3 id="objinfo-structure"><a href="#objinfo-structure" class="header-anchor">#</a> Estructura ObjInfo </h3> <p>La estructura <strong>ObjInfo</strong> contiene información sobre objetos internos.</p> <div class="language- extra-class"><pre class="language-text"><code>type ObjInfo struct {
   Type int
   Value interface{}
}
</code></pre></div><p>La estructura ObjInfo tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Type</strong> es el tipo de objeto. Puede ser uno de los siguientes valores:
<ul><li><strong>ObjContract</strong> -- <a href="#contractinfo-structure">Contrato inteligente</a>；</li> <li><strong>ObjFunc</strong> -- función;</li> <li><strong>ObjExtFunc</strong> -- función externa de golang;</li> <li><strong>ObjVar</strong> -- variable;</li> <li><strong>ObjExtend</strong> -- variable $name.</li></ul></li> <li><strong>Value</strong> -- contiene la estructura de cada tipo.</li></ul></blockquote> <h4 id="contractinfo-structure"><a href="#contractinfo-structure" class="header-anchor">#</a> Estructura ContractInfo </h4> <p>Apunta al tipo <strong>ObjContract</strong>, el campo <strong>Value</strong> contiene la estructura <strong>ContractInfo</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type ContractInfo struct {
    ID uint32
    Name string
    Owner *OwnerInfo
    Used map[string]bool
    Tx *[]*FieldInfo
}
</code></pre></div><h4 id="fieldinfo-structure"><a href="#fieldinfo-structure" class="header-anchor">#</a> Estructura FieldInfo </h4> <p>La estructura FieldInfo se usa en la estructura <strong>ContractInfo</strong> y describe los elementos del contrato inteligente <a href="/es/topics/script.html#data-section">sección de datos</a>.</p> <div class="language- extra-class"><pre class="language-text"><code>type FieldInfo struct {
      Name string
      Type reflect.Type
      Original uint32
      Tags string
}
</code></pre></div><p>La estructura FieldInfo tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Name</strong> - Nombre del campo;</li> <li><strong>Type</strong> - Tipo de campo;</li> <li><strong>Original</strong> - Campo opcional;</li> <li><strong>Tags</strong> -- Etiquetas adicionales para el campo.</li></ul></blockquote> <h4 id="funcinfo-structure"><a href="#funcinfo-structure" class="header-anchor">#</a> Estructura FuncInfo </h4> <p>La estructura FuncInfo apunta al tipo <strong>ObjFunc</strong>, el campo <strong>Value</strong> contiene la estructura <strong>FuncInfo</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncInfo struct {
    Params []reflect.Type
    Results []reflect.Type
    Names *map[string]FuncName
    Variadic bool
    ID uint32
}
</code></pre></div><p>La estructura FuncInfo tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Params</strong> -- un array de tipos de parámetros;</li> <li><strong>Results</strong> -- un array de tipos de resultados;</li> <li><strong>Names</strong> -- un mapeo de datos de la función de cola, por ejemplo, <code>DBFind().Columns()</code>;</li> <li><strong>Variadic</strong> -- si la función puede tener un número variable de parámetros, es verdadero;</li> <li><strong>ID</strong> -- el ID de la función.</li></ul></blockquote> <h4 id="funcname-structure"><a href="#funcname-structure" class="header-anchor">#</a> Estructura FuncName </h4> <p>La estructura FuncName se utiliza en <strong>FuncInfo</strong> y describe los datos de la función de cola.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
</code></pre></div><p>La estructura FuncName tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Params</strong> -- un array de tipos de parámetros;</li> <li><strong>Offset</strong> -- un array de desplazamientos de estas variables. De hecho, todos los parámetros pueden inicializarse en la función utilizando el punto <code>.</code>;</li> <li><strong>Variadic</strong> -- si la función de la cola puede tener un número variable de parámetros, es verdadero.</li></ul></blockquote> <h4 id="extfuncinfo-structure"><a href="#extfuncinfo-structure" class="header-anchor">#</a> Estructura ExtFuncInfo </h4> <p><strong>ObjExtFunc</strong> es un tipo que apunta a una función externa y el campo <strong>Value</strong> contiene la estructura <strong>ExtFuncInfo</strong>. Se utiliza para describir una función de Golang.</p> <div class="language- extra-class"><pre class="language-text"><code>type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
</code></pre></div><p>La estructura ExtFuncInfo tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Name</strong>, <strong>Params</strong>, <strong>Results</strong> son los mismos parámetros que la estructura <a href="#funcinfo-structure">FuncInfo</a>;</li> <li><strong>Auto</strong> -- un arreglo de variables que se pasan como parámetros adicionales a la función, por ejemplo, la variable de tipo <em>SmartContract</em> llamada <em>sc</em>;</li> <li><strong>Func</strong> -- una función de golang.</li></ul></blockquote> <h4 id="varinfo-structure"><a href="#varinfo-structure" class="header-anchor">#</a> Estructura VarInfo </h4> <p>La estructura VarInfo apunta al tipo <strong>ObjVar</strong>, y el campo <strong>Value</strong> contiene una estructura <strong>VarInfo</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
</code></pre></div><p>La estructura VarInfo tiene los siguientes elementos:</p> <blockquote><ul><li><strong>Obj</strong> -- Información sobre el tipo de variable y su valor;</li> <li><strong>Owner</strong> -- Puntero al bloque al que pertenece.</li></ul></blockquote> <h4 id="objextend-value"><a href="#objextend-value" class="header-anchor">#</a> Valor ObjExtend </h4> <p>Apunta al tipo <strong>ObjExtend</strong>, el campo <strong>Value</strong> contiene una cadena que incluye el nombre de una variable o función.</p> <h2 id="virtual-machine-commands"><a href="#virtual-machine-commands" class="header-anchor">#</a> Instrucciones de la máquina virtual </h2> <h3 id="bytecode-structure"><a href="#bytecode-structure" class="header-anchor">#</a> Estructura ByteCode </h3> <p>Un bytecode es una secuencia de estructuras de tipo <strong>ByteCode</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type ByteCode struct {
   Cmd uint16
   Value interface{}
}
</code></pre></div><p>La estructura tiene los siguientes campos:</p> <blockquote><ul><li><strong>Cmd</strong> - Almacena el identificador de la instrucción;</li> <li><strong>Value</strong> - Contiene el operando (valor).</li></ul></blockquote> <p>En general, la instrucción opera en el elemento superior de la pila y, si es necesario, escribe el resultado en ella.</p> <h3 id="command-identifiers"><a href="#command-identifiers" class="header-anchor">#</a> Identificadores de comando </h3> <p>El archivo <em>vm/cmds_list.go</em> describe los identificadores de las instrucciones de la máquina virtual.</p> <blockquote><ul><li><strong>cmdPush</strong> -- Coloca el valor del campo <em>Value</em> en la pila. Por ejemplo, coloca números y líneas en la pila;</li> <li><strong>cmdVar</strong> -- Coloca el valor de la variable en la pila. <em>Value</em> contiene un puntero a la estructura <em>VarInfo</em> y la información sobre la variable;</li> <li><strong>cmdExtend</strong> -- Coloca el valor de la variable externa en la pila. <em>Value</em> contiene una cadena con el nombre de la variable (comenzando con <code>$</code>);</li> <li><strong>cmdCallExtend</strong> -- Llama a una función externa (cuyo nombre comienza con <code>$</code>). Los argumentos de la función se obtienen de la pila y el resultado se coloca en la pila. <em>Value</em> contiene el nombre de la función (comenzando con <code>$</code>);</li> <li><strong>cmdPushStr</strong> -- Coloca la cadena del campo <em>Value</em> en la pila;</li> <li><strong>cmdCall</strong> -- Llama a una función de la máquina virtual. <em>Value</em> contiene la estructura <strong>ObjInfo</strong>. Esta instrucción se utiliza para las funciones <strong>ObjExtFunc</strong> de Golang y las funciones <strong>ObjFunc</strong> de Needle. Cuando se llama a la función, se obtienen sus argumentos de la pila y se coloca el valor del resultado en la pila;</li> <li><strong>cmdCallVari</strong> -- Similar a la instrucción <strong>cmdCall</strong>, llama a una función de la máquina virtual. Esta instrucción se utiliza para llamar a funciones con un número variable de argumentos;</li> <li><strong>cmdReturn</strong> -- Se utiliza para salir de una función. El valor de retorno se coloca en la pila y no se utiliza el campo <em>Value</em>;</li> <li><strong>cmdIf</strong> -- Transfiere el control al bytecode en la estructura <strong>bloque</strong> que se pasa en el campo <em>Value</em>. El control se transfiere a la pila solo si la función <em>valueToBool</em> devuelve <code>true</code> para el elemento superior de la pila. De lo contrario, el control se transfiere a la siguiente instrucción;</li> <li><strong>cmdElse</strong> -- Funciona de la misma manera que la instrucción <strong>cmdIf</strong>, pero el control se transfiere a la estructura especificada solo si la función <em>valueToBool</em> devuelve <code>false</code> para el elemento superior de la pila;</li> <li><strong>cmdAssignVar</strong> -- Obtiene una lista de variables de tipo <strong>VarInfo</strong> del campo <em>Value</em>. Estas variables obtienen sus valores mediante la instrucción <strong>cmdAssign</strong>;</li> <li><strong>cmdAssign</strong> -- Asigna los valores de la pila a las variables obtenidas mediante la instrucción <strong>cmdAssignVar</strong>;</li> <li><strong>cmdLabel</strong> -- Define una etiqueta que se utiliza para devolver el control durante un ciclo while;</li> <li><strong>cmdContinue</strong> -- Transfiere el control a la etiqueta <strong>cmdLabel</strong>. No se utiliza el campo <em>Value</em> al ejecutar una nueva iteración del ciclo;</li> <li><strong>cmdWhile</strong> -- Utiliza la función <em>valueToBool</em> para comprobar el elemento superior de la pila. Si este valor es <code>true</code>, se llama a la estructura <strong>bloque</strong> del campo <em>value</em>;</li> <li><strong>cmdBreak</strong> -- Sale del ciclo;</li> <li><strong>cmdIndex</strong> -- Coloca el valor del <em>map</em> o <em>array</em> en la pila mediante un índice. No se utiliza el campo <em>Value</em>. Por ejemplo: <code>(map | array) (index value) =&gt; (map | array [index value])</code>;</li> <li><strong>cmdSetIndex</strong> -- Asigna el valor del elemento superior de la pila a un elemento del <em>map</em> o <em>array</em>. No se utiliza el campo <em>Value</em>. Por ejemplo: <code>(map | array) (index value) (value) =&gt; (map | array)</code>;</li> <li><strong>cmdFuncName</strong> -- Describe los parámetros agregados mediante puntos <code>.</code>. Por ejemplo: <code>func name =&gt; Func (...) .Name (...)</code>;</li> <li><strong>cmdUnwrapArr</strong> -- Define una bandera booleana si el elemento superior de la pila es un array;</li> <li><strong>cmdMapInit</strong> -- Inicializa los valores del <em>map</em>;</li> <li><strong>cmdArrayInit</strong> -- Inicializa los valores del <em>array</em>;</li> <li><strong>cmdError</strong> -- Se crea cuando el contrato inteligente o la función se detienen debido a un error especificado (<code>error, warning, info</code>).</li></ul></blockquote> <h3 id="stack-operation-commands"><a href="#stack-operation-commands" class="header-anchor">#</a> Instrucciones de operación de pila </h3> <div class="language-text extra-class"><pre class="language-text"><code>En la versión actual, estos comandos no tienen una conversión de tipo completamente automática. Por ejemplo:
`string + float | int | decimal =&gt; float | int | decimal`，`float + int | str =&gt; float`，pero `int + string =&gt; runtime error`。
</code></pre></div><p>Aquí están las instrucciones que manejan directamente la pila. Estas instrucciones no utilizan el campo <em>Value</em>.</p> <ul><li><strong>cmdNot</strong> -- Negación lógica. <code>(val) =&gt; (!ValueToBool(val))</code>;</li> <li><strong>cmdSign</strong> -- Cambio de signo. <code>(val) =&gt; (-val)</code>;</li> <li><strong>cmdAdd</strong> -- Suma. <code>(val1)(val2) =&gt; (val1 + val2)</code>;</li> <li><strong>cmdSub</strong> -- Resta. <code>(val1)(val2) =&gt; (val1 - val2)</code>;</li> <li><strong>cmdMul</strong> -- Multiplicación. <code>(val1)(val2) =&gt; (val1 * val2)</code>;</li> <li><strong>cmdDiv</strong> -- División. <code>(val1)(val2) =&gt; (val1 / val2)</code>;</li> <li><strong>cmdAnd</strong> -- Operación lógica AND. <code>(val1)(val2) =&gt; (valueToBool(val1) &amp;&amp; valueToBool(val2))</code>;</li> <li><strong>cmdOr</strong> -- Operación lógica OR. <code>(val1)(val2) =&gt; (valueToBool(val1) || valueToBool(val2))</code>;</li> <li><strong>cmdEqual</strong> -- Comparación de igualdad, devuelve bool. <code>(val1)(val2) =&gt; (val1 == val2)</code>;</li> <li><strong>cmdNotEq</strong> -- Comparación de desigualdad, devuelve bool. <code>(val1)(val2) =&gt; (val1 != val2)</code>;</li> <li><strong>cmdLess</strong> -- Comparación de menor que, devuelve bool. <code>(val1)(val2) =&gt; (val1 &lt; val2)</code>;</li> <li><strong>cmdNotLess</strong> -- Comparación de mayor o igual que, devuelve bool. <code>(val1)(val2) =&gt; (val1 &gt;= val2)</code>;</li> <li><strong>cmdGreat</strong> -- Comparación de mayor que, devuelve bool. <code>(val1)(val2) =&gt; (val1 &gt; val2)</code>;</li> <li><strong>cmdNotGreat</strong> -- Comparación de menor o igual que, devuelve bool. <code>(val1)(val2) =&gt; (val1 &lt;= val2)</code>.</li></ul> <h3 id="runtime-structure"><a href="#runtime-structure" class="header-anchor">#</a> Estructura Runtime </h3> <p>La ejecución del bytecode no afecta a la máquina virtual. Por ejemplo, permite que varias funciones y contratos inteligentes se ejecuten simultáneamente en una sola máquina virtual.</p> <p>La estructura <strong>Runtime</strong> se utiliza para ejecutar funciones y contratos inteligentes, así como cualquier expresión y bytecode.</p> <div class="language- extra-class"><pre class="language-text"><code>type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}
</code></pre></div><ul><li><strong>stack</strong> -- La pila que ejecuta el bytecode;</li> <li><strong>blocks</strong> -- La pila de llamadas de bloques;</li> <li><strong>vars</strong> -- La pila de variables. Cuando se llama al bytecode dentro de un bloque, sus variables se agregarán a esta pila de variables. Después de salir del bloque, el tamaño de la pila de variables volverá a su valor anterior;</li> <li><strong>extend</strong> -- Puntero de mapeo de valores de variables externas (<code>$name</code>);</li> <li><strong>vm</strong> -- Puntero de la máquina virtual;</li> <li><strong>cost</strong> -- Unidad de combustible para el resultado de la ejecución;</li> <li><strong>err</strong> -- Error durante la ejecución.</li></ul> <h4 id="blockstack-structure"><a href="#blockstack-structure" class="header-anchor">#</a> Estructura blockStack </h4> <p>La estructura blockStack se utiliza en la estructura <strong>Runtime</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>type blockStack struct {
     Block *Block
     Offset int
}
</code></pre></div><ul><li><strong>Block</strong> -- Puntero al bloque en ejecución;</li> <li><strong>Offset</strong> -- Desplazamiento de la última instrucción ejecutada en el bytecode del bloque especificado.</li></ul> <h3 id="runcode-function"><a href="#runcode-function" class="header-anchor">#</a> Función RunCode </h3> <p>El bytecode se ejecuta en la función <strong>RunCode</strong>. Contiene un bucle que ejecuta la operación correspondiente para cada instrucción del bytecode. Antes de procesar el bytecode, es necesario inicializar los datos necesarios.</p> <p>Aquí se añade un nuevo bloque a otros bloques.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = append(rt.blocks, &amp;blockStack{block, len(rt.vars)})
</code></pre></div><p>A continuación, se obtiene la información de los parámetros relevantes de la función de cola. Estos parámetros están contenidos en el último elemento de la pila.</p> <div class="language- extra-class"><pre class="language-text"><code>var namemap map[string][]interface{}
if block.Type == ObjFunc &amp;&amp; block.Info.(*FuncInfo).Names != nil {
    if rt.stack[len(rt.stack)-1] != nil {
        namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
    }
    rt.stack = rt.stack[:len(rt.stack)-1]
}
</code></pre></div><p>Entonces, es necesario inicializar todas las variables definidas en el bloque actual con sus valores iniciales.</p> <div class="language- extra-class"><pre class="language-text"><code>start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
   rt.cost--
   var value interface{}
</code></pre></div><p>Debido a que las variables en una función también son variables, necesitamos extraerlas del último elemento de la pila en el orden descrito por la función en sí.</p> <div class="language- extra-class"><pre class="language-text"><code>    if block.Type == ObjFunc &amp;&amp; vkey &lt; len(block.Info.(*FuncInfo).Params) {
      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
    } else {
</code></pre></div><p>Inicializar la variable local con el valor inicial aquí.</p> <div class="language- extra-class"><pre class="language-text"><code>        value = reflect.New(vpar).Elem().Interface()
        if vpar == reflect.TypeOf(map[string]interface{}{}) {
           value = make(map[string]interface{})
        } else if vpar == reflect.TypeOf([]interface{}{}) {
           value = make([]interface{}, 0, len(rt.vars)+1)
        }
    }
rt.vars = append(rt.vars, value)
}
</code></pre></div><p>Siguiente, actualice los valores de los parámetros de variables que se pasan en la función de cola.</p> <div class="language- extra-class"><pre class="language-text"><code>if namemap != nil {
  for key, item := range namemap {
    params := (*block.Info.(*FuncInfo).Names)[key]
    for i, value := range item {
       if params.Variadic &amp;&amp; i &gt;= len(params.Params)-1 {
</code></pre></div><p>Si los parámetros de variable pasados son un número variable de parámetros, entonces combinarlos en un arreglo variable.</p> <div class="language- extra-class"><pre class="language-text"><code>                off := varoff + params.Offset[len(params.Params)-1]
                rt.vars[off] = append(rt.vars[off].([]interface{}), value)
            } else {
                rt.vars[varoff+params.Offset[i]] = value
            }
        }
    }
}
</code></pre></div><p>Después, lo que tenemos que hacer es eliminar los valores que se pasaron como parámetros de función desde la parte superior de la pila, para así mover la pila. Ya hemos copiado sus valores en un arreglo de variables.</p> <div class="language- extra-class"><pre class="language-text"><code>if block.Type == ObjFunc {
     start -= len(block.Info.(*FuncInfo).Params)
}
</code></pre></div><p>Después de que se complete la ejecución del ciclo de instrucciones de bytecode, es necesario limpiar correctamente la pila.</p> <div class="language- extra-class"><pre class="language-text"><code>last := rt.blocks[len(rt.blocks)-1]
</code></pre></div><p>Eliminar el bloque actual de la pila de bloques.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
</code></pre></div><p>Si salimos con éxito de una función que ha sido ejecutada, agregaremos el valor de retorno al final de la pila anterior.</p> <div class="language- extra-class"><pre class="language-text"><code>if last.Block.Type == ObjFunc {
   for count := len(last.Block.Info.(*FuncInfo).Results); count &gt; 0; count-- {
     rt.stack[start] = rt.stack[len(rt.stack)-count]
     start++
   }
   status = statusNormal
 } else {
</code></pre></div><p>Como puede ver, si no ejecutamos la función, no restauraremos el estado de la pila y saldremos de la función tal como está. La razón es que los bucles y estructuras condicionales que ya se han ejecutado en la función también son bloques de código de bytes.</p> <div class="language- extra-class"><pre class="language-text"><code>return
    }
}
rt.stack = rt.stack[:start]
</code></pre></div><h3 id="other-functions-for-operations-with-vm"><a href="#other-functions-for-operations-with-vm" class="header-anchor">#</a> Otras funciones de la VM </h3> <p>Utilice la función <strong>NewVM</strong> para crear una máquina virtual. Cada máquina virtual tiene la función <strong>Extend</strong> que agrega cuatro funciones: <strong>ExecContract, MemoryUsage, CallContract</strong> y <strong>Settings</strong>.</p> <div class="language- extra-class"><pre class="language-text"><code>for key, item := range ext.Objects {
    fobj := reflect.ValueOf(item).Type()
</code></pre></div><p>Nosotros iteramos a través de todos los objetos pasados y solo miramos las funciones.</p> <div class="language- extra-class"><pre class="language-text"><code>switch fobj.Kind() {
case reflect.Func:
</code></pre></div><p>De acuerdo con la información relevante recibida sobre la función, llene la estructura <strong>ExtFuncInfo</strong> y agréguela al mapa de <strong>Objects</strong> de nivel superior por nombre.</p> <div class="language- extra-class"><pre class="language-text"><code>data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()), 
   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}
for i := 0; i &lt; fobj.NumIn(); i++ {
</code></pre></div><p>La estructura <strong>ExtFuncInfo</strong> tiene un array de parámetros llamado <strong>Auto</strong>. Normalmente, el primer parámetro es <code>sc *SmartContract</code> o <code>rt *Runtime</code>.</p> <p>No podemos pasarlos desde el lenguaje Needle, ya que son necesarios para ejecutar algunas funciones de Golang. Por lo tanto, especificamos que estos variables se utilizarán automáticamente al llamar a la función.</p> <p>En este caso, el primer parámetro de las cuatro funciones mencionadas es <code>rt *Runtime</code>.</p> <div class="language- extra-class"><pre class="language-text"><code>if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
  data.Auto[i] = isauto
}
</code></pre></div><p>Asignar información sobre el parámetro.</p> <div class="language- extra-class"><pre class="language-text"><code>data.Params[i] = fobj.In(i)
}
</code></pre></div><p>y el tipo del valor devuelto.</p> <div class="language- extra-class"><pre class="language-text"><code>for i := 0; i &lt; fobj.NumOut(); i++ {
   data.Results[i] = fobj.Out(i)
}
</code></pre></div><p>Agregar una función a la raíz <strong>Objects</strong>, de esta manera el compilador podrá encontrarlas más tarde cuando se utilice el contrato inteligente.</p> <div class="language- extra-class"><pre class="language-text"><code>vm.Objects[key] = &amp;ObjInfo{ObjExtFunc, data}
    }
}
</code></pre></div><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> Compilador </h2> <p>El archivo <em>compile.go</em> contiene funciones encargadas de compilar el array de tokens obtenido del analizador léxico. La compilación puede dividirse en dos niveles condicionalmente, en el nivel superior, se manejan funciones, contratos inteligentes, bloques de código, declaraciones condicionales y de bucle, definiciones de variables, entre otros. En el nivel inferior, compilamos bloques de código en bucles y declaraciones condicionales o expresiones dentro de condiciones.</p> <p>En primer lugar, describamos el nivel inferior de manera simple. La función <strong>compileEval</strong> puede completar la conversión de una expresión en bytecode. Dado que estamos utilizando una máquina virtual de pila, es necesario convertir una expresión de registro de infijo normal a notación de sufijo o notación polaca inversa. Por ejemplo, <code>1+2</code> se convierte en <code>12+</code>, luego colocamos <code>1</code> y <code>2</code> en la pila, luego aplicamos la operación de suma a los dos últimos elementos de la pila y escribimos el resultado en la pila. Este <a href="https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/" target="_blank" rel="noopener noreferrer">algoritmo de conversión<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> se puede encontrar en Internet.</p> <p>La variable global <code>opers = map [uint32] operPrior</code> contiene la prioridad de las operaciones necesarias para convertir a notación polaca inversa.</p> <p>Las siguientes variables se definen al comienzo de la función <strong>compileEval</strong>:</p> <blockquote><ul><li><strong>buffer</strong> -- un búfer temporal para las instrucciones de bytecode;</li> <li><strong>bytecode</strong> -- un búfer final para las instrucciones de bytecode;</li> <li><strong>parcount</strong> -- un búfer temporal para calcular los parámetros al llamar a una función;</li> <li><strong>setIndex</strong> -- una variable que se establece en [true]{.title-ref} durante el proceso de trabajo al asignar elementos a un <em>map</em> o <em>array</em>. Por ejemplo, en el caso de <code>a[&quot;my&quot;] = 10</code>, necesitamos usar la instrucción <strong>cmdSetIndex</strong> especificada.</li></ul></blockquote> <p>Obtenemos una marca en un bucle y realizamos la acción correspondiente, por ejemplo, si encontramos una llave, detenemos el análisis de la expresión. Al mover una cadena, verificamos si la sentencia anterior es un operador y si está dentro de paréntesis, de lo contrario, salimos y analizamos la expresión.</p> <div class="language- extra-class"><pre class="language-text"><code>case isRCurly, isLCurly:
     i--
     if prevLex == isComma || prevLex == lexOper {
                return errEndExp
           }
    break main
case lexNewLine:
      if i &gt; 0 &amp;&amp; ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {
           continue main
      }
     for k := len(buffer) - 1; k &gt;= 0; k-- {
          if buffer[k].Cmd == cmdSys {
              continue main
         }
     }
    break main
</code></pre></div><p>En circunstancias normales, este algoritmo corresponde a un algoritmo de conversión a notación polaca inversa. Teniendo en cuenta algunas llamadas necesarias a contratos inteligentes, funciones e índices, así como otras cosas que no se encuentran durante el análisis del marcador de tipo <em>lexIdent</em>, comprobaremos si hay una variable, función o contrato inteligente con este nombre. Si no se encuentra ningún contenido relevante y esto no es una llamada a una función o contrato inteligente, se indicará un error.</p> <div class="language- extra-class"><pre class="language-text"><code>objInfo, tobj := vm.findObj(lexem.Value.(string), block)
if objInfo == nil &amp;&amp; (!vm.Extern || i &gt; *ind || i &gt;= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {
      return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))
}
</code></pre></div><p>Podríamos encontrarnos en una situación en la que describiremos una llamada de contrato inteligente más adelante. En este ejemplo, si no se encuentra una función o variable con el mismo nombre, consideramos que se llamará al contrato inteligente.</p> <p>En este lenguaje de programación, no hay diferencia entre la llamada de contrato inteligente y la llamada de función. Pero necesitamos llamar al contrato inteligente utilizando la función <strong>ExecContract</strong> utilizada en el bytecode.</p> <blockquote><div class="language- extra-class"><pre class="language-text"><code>if objInfo.Type == ObjContract {
    if objInfo.Value != nil {
              objContract = objInfo.Value.(*Block)
            }
    objInfo, tobj = vm.findObj(`ExecContract`, block)
    isContract = true
}
</code></pre></div></blockquote> <p>En este código, estamos registrando la cantidad de variables hasta el momento en la variable <code>count</code>, la cual también se escribe en la pila junto con la cantidad de argumentos de la función. Cada vez que se verifica un argumento posteriormente, simplemente necesitamos aumentar la cantidad en una unidad en el último elemento de la pila.</p> <div class="language- extra-class"><pre class="language-text"><code>count := 0
if (*lexems)[i+2].Type != isRPar {
    count++
}
</code></pre></div><p>Tenemos un parámetro de lista <em>Used</em> que indica los contratos inteligentes que han sido llamados, por lo que necesitamos marcar cuando se llama a un contrato inteligente. Si se llama al contrato inteligente sin ningún parámetro, debemos agregar dos parámetros vacíos para llamar a <strong>ExecContract</strong> y obtener al menos dos parámetros.</p> <div class="language- extra-class"><pre class="language-text"><code>if isContract {
   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))
   for j := len(*block) - 1; j &gt;= 0; j-- {
      topblock := (*block)[j]
      if topblock.Type == ObjContract {
            if topblock.Info.(*ContractInfo).Used == nil {
                 topblock.Info.(*ContractInfo).Used = make(map[string]bool)
            }
           topblock.Info.(*ContractInfo).Used[name] = true
       }
    }
    bytecode = append(bytecode, &amp;ByteCode{cmdPush, name})
    if count == 0 {
       count = 2
       bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
       bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
     }
    count++

}
</code></pre></div><p>Si vemos que hay un corchete cuadrado al lado, entonces agregamos el comando <strong>cmdIndex</strong> para obtener el valor por el índice.</p> <div class="language- extra-class"><pre class="language-text"><code>if (*lexems)[i+1].Type == isLBrack {
     if objInfo == nil || objInfo.Type != ObjVar {
         return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))
     }
    buffer = append(buffer, &amp;ByteCode{cmdIndex, 0})
}
</code></pre></div><p>La función <strong>CompileBlock</strong> puede generar un árbol de objetos y bytecode independiente de expresiones. El proceso de compilación se basa en una máquina de estados finitos, al igual que un analizador léxico, pero con las siguientes diferencias.</p> <p>En primer lugar, no usamos símbolos sino etiquetas.</p> <p>En segundo lugar, describimos inmediatamente todas las variables de estado y transición en <em>states</em>.</p> <p>Esto representa un arreglo de objetos indexados por tipo de etiqueta, cada etiqueta tiene una estructura de <em>compileState</em> y se especifica un nuevo estado en <em>NewState</em>.</p> <p>Si ya hemos entendido esta estructura, podemos especificar la función de manejador en el campo <em>Func</em>.</p> <p>Tomemos como ejemplo el estado principal.</p> <p>Si encontramos un salto de línea o un comentario, mantendremos el mismo estado. Si encontramos la palabra clave <strong>contract</strong>, cambiaremos el estado a <em>stateContract</em> y comenzaremos a analizar esa estructura.</p> <p>Si encontramos la palabra clave <strong>func</strong>, cambiaremos el estado a <em>stateFunc</em>. Si recibimos cualquier otra etiqueta, se llamará a una función que genere un error.</p> <div class="language- extra-class"><pre class="language-text"><code>{ // stateRoot
   lexNewLine: {stateRoot, 0},
   lexKeyword | (keyContract &lt;&lt; 8): {stateContract | statePush, 0},
   lexKeyword | (keyFunc &lt;&lt; 8): {stateFunc | statePush, 0},
   lexComment: {stateRoot, 0},
   0: {errUnknownCmd, cfError},
},
</code></pre></div><p>Supongamos que nos encontramos con la palabra clave <strong>func</strong> y hemos cambiado el estado a <em>stateFunc</em>. Debido a que el nombre de la función debe seguir la palabra clave <strong>func</strong>, al cambiar el nombre de la función mantendremos el mismo estado. Para todos los demás tokens, generaremos un error correspondiente.</p> <p>Si obtenemos el nombre de la función en el token de identificador, pasamos al estado <em>stateFParams</em>, donde podemos obtener los parámetros de la función.</p> <div class="language- extra-class"><pre class="language-text"><code>{ // stateFunc
    lexNewLine: {stateFunc, 0},
    lexIdent: {stateFParams, cfNameBlock},
    0: {errMustName, cfError},
},
</code></pre></div><p>Durante la operación anterior, llamamos a la función <strong>fNameBlock</strong>. Es importante tener en cuenta que la estructura <em>Block</em> se crea utilizando la marca <em>statePush</em>, y aquí la obtenemos del búfer y llenamos los datos que necesitamos. La función <strong>fNameBlock</strong> se utiliza para contratos inteligentes y funciones (incluyendo funciones y contratos inteligentes anidados).</p> <p>Utiliza la estructura correspondiente para llenar el campo <em>Info</em> y se escribe a sí misma en los <em>Objects</em> del bloque padre. De esta manera, podemos llamar a esta función o contrato inteligente mediante el nombre especificado.</p> <p>Del mismo modo, creamos funciones correspondientes para todos los estados y variables. Estas funciones suelen ser muy pequeñas y realizan algunas tareas al construir el árbol de la máquina virtual.</p> <div class="language- extra-class"><pre class="language-text"><code>func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {
    var itype int

    prev := (*buf)[len(*buf)-2]
    fblock := (*buf)[len(*buf)-1]
   name := lexem.Value.(string)
   switch state {
     case stateBlock:
        itype = ObjContract
       name = StateName((*buf)[0].Info.(uint32), name)
       fblock.Info = &amp;ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,
           Owner: (*buf)[0].Owner}
    default:
       itype = ObjFunc
       fblock.Info = &amp;FuncInfo{}
     }
     fblock.Type = itype
    prev.Objects[name] = &amp;ObjInfo{Type: itype, Value: fblock}
    return nil
}
</code></pre></div><p>Para la función <strong>CompileBlock</strong>, simplemente recorre todas las etiquetas y cambia el estado según lo descrito en <em>states</em>. Casi todas las etiquetas adicionales corresponden a código de programa adicional.</p> <blockquote><ul><li><strong>statePush</strong> -- Agrega el objeto <strong>Block</strong> al árbol de objetos;</li> <li><strong>statePop</strong> -- Se utiliza cuando el bloque termina con una llave de cierre;</li> <li><strong>stateStay</strong> -- Cuando se cambia a un nuevo estado, es necesario mantener la etiqueta actual;</li> <li><strong>stateToBlock</strong> -- Cambia al estado <strong>stateBlock</strong>, utilizado para procesar <em>while</em> y <em>if</em>. Después de procesar la expresión, es necesario procesar el bloque dentro de las llaves;</li> <li><strong>stateToBody</strong> -- Cambia al estado <strong>stateBody</strong>;</li> <li><strong>stateFork</strong> -- Guarda la posición de la etiqueta. Se utiliza cuando la expresión comienza con un identificador o un nombre que comienza con <code>$</code>, lo que indica una llamada a función o una asignación;</li> <li><strong>stateToFork</strong> -- Se utiliza para obtener la etiqueta almacenada en <strong>stateFork</strong>. Esta etiqueta se pasará a la función de procesamiento;</li> <li><strong>stateLabel</strong> -- Se utiliza para insertar la instrucción <strong>cmdLabel</strong>. La estructura <em>while</em> necesita esta etiqueta;</li> <li><strong>stateMustEval</strong> -- Verifica la disponibilidad de la expresión condicional al comienzo de las estructuras <em>if</em> y <em>while</em>.</li></ul></blockquote> <p>Aparte de la función <strong>CompileBlock</strong>, también se debe mencionar la función <strong>FlushBlock</strong>.</p> <p>Pero el problema es que el árbol de bloques es independiente de la construcción actual de la máquina virtual, es decir, obtenemos información sobre las funciones y contratos inteligentes existentes en la máquina virtual, pero recopilamos los bloques ya compilados en un árbol separado.</p> <p>De lo contrario, si ocurre un error durante la compilación, debemos revertir el estado de la máquina virtual a un estado anterior. Por lo tanto, compilamos el árbol por separado, pero después de una compilación exitosa, debemos llamar a la función <strong>FlushContract</strong>.</p> <p>Esta función agregará el árbol de bloques completado a la máquina virtual actual. En este punto, la fase de compilación se ha completado.</p> <h2 id="lexical-analyzer"><a href="#lexical-analyzer" class="header-anchor">#</a> Analizador léxico </h2> <p>El analizador léxico procesa la cadena de entrada y forma una secuencia de tokens de los siguientes tipos:</p> <ul><li><strong>lexSys</strong> - Token de sistema, como: <code>{}</code>, <code>[]</code>, <code>()</code>, <code>,</code>, <code>.</code>, etc.;</li> <li><strong>lexOper</strong> - Token de operación, como: <code>+</code>, <code>-</code>, <code>/</code>, <code>\</code>, <code>*</code>;</li> <li><strong>lexNumber</strong> - Número;</li> <li><strong>lexident</strong> - Identificador;</li> <li><strong>lexNewline</strong> - Salto de línea;</li> <li><strong>lexString</strong> - Cadena de caracteres;</li> <li><strong>lexComment</strong> - Comentario;</li> <li><strong>lexKeyword</strong> - Palabra clave;</li> <li><strong>lexType</strong> - Tipo;</li> <li><strong>lexExtend</strong> - Referencia a variables o funciones externas, como: <code>$myname</code>.</li></ul> <p>En la versión actual, se construyó una tabla de conversión (máquina de estados finitos) con la ayuda del archivo <a href="#lextable-lextable-go">script/lextable/lextable.go</a> para analizar tokens y escribirlos en el archivo <em>lex_table.go</em>. En general, se puede separar de la tabla de conversión inicial generada por ese archivo y crear una tabla de conversión en memoria (<code>init()</code>) inmediatamente al inicio.</p> <p>El análisis léxico en sí ocurre en la función <strong>lexParser</strong> en el archivo <a href="#lex-go">lex.go</a>.</p> <h3 id="lextable-lextable-go"><a href="#lextable-lextable-go" class="header-anchor">#</a> lextable/lextable.go </h3> <p>Aquí definimos nuestro alfabeto de operación y describimos cómo una máquina de estados finitos cambia de un estado a otro según el siguiente símbolo recibido.</p> <p><em>states</em> contiene un objeto JSON con una lista de estados.</p> <p>Excepto por símbolos específicos, <code>d</code> se utiliza para representar todos los símbolos no especificados en el estado.</p> <p><code>n</code> representa 0x0a, <code>s</code> representa un espacio, <code>q</code> representa una comilla simple, <code>Q</code> representa una comilla doble, <code>r</code> representa caracteres &gt;= 128, <code>a</code> representa AZ y az, <code>1</code> representa 1-9.</p> <p>El nombre del estado es la clave y el objeto de valor enumera los posibles valores. Luego, para cada conjunto, hay un nuevo estado al que se debe cambiar. Luego viene el nombre de la etiqueta, si necesitamos volver al estado inicial, el tercer parámetro es una marca de servicio que indica cómo procesar el símbolo actual.</p> <p>Por ejemplo, tenemos un estado principal y un carácter de entrada &quot;/&quot;, <code>&quot;/&quot;: [&quot;solidus&quot;, &quot;&quot;, &quot;push next&quot;],</code></p> <blockquote><ul><li><strong>push</strong> - hace que la instrucción recuerde que está en una pila separada;</li> <li><strong>next</strong> - pasa al siguiente carácter, mientras cambiamos el estado a <strong>solidus</strong>, luego obtenemos el siguiente carácter y miramos el estado de <strong>solidus</strong>.</li></ul></blockquote> <p>Si el siguiente carácter es &quot;/&quot; o &quot;/<em>&quot;, entonces pasamos al estado de comentario <strong>comment</strong>, ya que comienzan con &quot;//&quot; o &quot;/</em>&quot;.
Obviamente, cada comentario tiene un estado posterior diferente, ya que terminan con diferentes símbolos.</p> <p>Si el siguiente carácter no es &quot;/&quot; ni &quot;*&quot;, entonces registramos todo el contenido de la pila como una marca de tipo <strong>lexOper</strong>, limpiamos la pila y volvemos al estado principal.</p> <p>El siguiente módulo convierte el árbol de estados en una matriz numérica y lo escribe en el archivo <em>lex_table.go</em>.</p> <p>En el primer bucle:</p> <p>Formamos un alfabeto de símbolos válidos.</p> <div class="language- extra-class"><pre class="language-text"><code>for ind, ch := range alphabet {
i := byte(ind)
</code></pre></div><p>Además, en <strong>state2int</strong>, proporcionamos un identificador de secuencia único para cada estado.</p> <div class="language- extra-class"><pre class="language-text"><code>state2int := map[string]uint{`main`: 0}
if err := json.Unmarshal([]byte(states), &amp;data); err == nil {
for key := range data {
if key != `main` {
state2int[key] = uint(len(state2int))
</code></pre></div><p>Cuando recorremos todos los estados y cada conjunto en el estado y cada símbolo en el conjunto, escribimos un número de tres bytes [identificador de nuevo estado (0=principal)] + [tipo de marca (0-sin marca)] + [marca].</p> <p>La bidimensionalidad del array <em>table</em> se debe a que se divide en estados y 34 símbolos de entrada del array <em>alphabet</em>, que se ordenan en el mismo orden.</p> <p>Estamos en el estado <em>main</em> en la fila cero de la tabla <em>table</em>. Tomamos el primer carácter, buscamos su índice en el array <em>alphabet</em> y obtenemos el valor de la columna correspondiente al índice dado.</p> <p>A partir del valor recibido, recibimos la marca en el byte de menor orden. Si se completa el análisis, el segundo byte indica el tipo de marca recibida. En el tercer byte, recibimos el índice del nuevo estado siguiente.</p> <p>Todo esto se describe con más detalle en la función <strong>lexParser</strong> en <em>lex.go</em>.</p> <p>Si desea agregar nuevos caracteres, debe agregarlos al array <em>alphabet</em> y aumentar la constante <em>AlphaSize</em>.
Si desea agregar nuevas combinaciones de símbolos, debe describirlas en el estado, similar a las opciones existentes. Después de esto, ejecute el archivo <em>lextable.go</em> para actualizar el archivo <em>lex_table.go</em>.</p> <h3 id="lex-go"><a href="#lex-go" class="header-anchor">#</a> lex.go </h3> <p><strong>lexParser</strong></p> <p>La función genera directamente el análisis léxico y devuelve una matriz de tokens recibidos según la cadena de entrada proporcionada. Analicemos la estructura de los tokens.</p> <div class="language- extra-class"><pre class="language-text"><code>type Lexem struct {
   Type uint32 // Type of the lexem
   Value interface{} // Value of lexem
   Line uint32 // Line of the lexem
   Column uint32 // Position inside the line
}
</code></pre></div><ul><li><strong>Type</strong> -- Tipo de marcador. Tiene uno de los siguientes valores: <code>lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend</code>;</li> <li><strong>Value</strong> -- Valor del marcador. El tipo de valor depende del tipo de marcador, analicemos más detalladamente:
<ul><li><strong>lexSys</strong> -- Incluye paréntesis, comas, etc. En este caso, <code>Type = ch &lt;&lt; 8 | lexSys</code>, consulte las constantes <code>isLPar ... isRBrack</code>, este valor es uint32;</li> <li><strong>lexOper</strong> -- El valor se representa como una secuencia de caracteres equivalente en forma de uint32. Consulte las constantes <code>isNot ... isOr</code>;</li> <li><strong>lexNumber</strong> -- El número se almacena como <em>int64</em> o <em>float64</em>. Si el número tiene un punto decimal, es <em>float64</em>;</li> <li><strong>lexIdent</strong> -- El identificador se almacena como <em>string</em>;</li> <li><strong>lexNewLine</strong> -- Salto de línea. También se utiliza para calcular la línea y la posición del marcador;</li> <li><strong>lexString</strong> -- La cadena se almacena como <em>string</em>;</li> <li><strong>lexComment</strong> -- El comentario se almacena como <em>string</em>;</li> <li><strong>lexKeyword</strong> -- La palabra clave solo almacena el índice correspondiente, consulte las constantes <code>keyContract ... keyTail</code>. En este caso, <code>Type = KeyID &lt;&lt; 8 | lexKeyword</code>.
Además, debe tenerse en cuenta que las palabras clave <code>true, false, nil</code> se convierten inmediatamente en un marcador de tipo <strong>lexNumber</strong> y se utilizan los tipos correspondientes <code>bool</code> e <code>intreface {}</code>;</li> <li><strong>lexType</strong> -- Este valor contiene el valor de tipo <code>reflect.Type</code> correspondiente;</li> <li><strong>lexExtend</strong> -- Identificador que comienza con el símbolo <code>$</code>. Estas variables y funciones se pasan desde el exterior, por lo que se asignan a un tipo de marcador especial. Este valor contiene el nombre en forma de cadena, sin el símbolo <code>$</code> al principio.</li></ul></li> <li><strong>Líne</strong> -- Línea en la que se encuentra el marcador;</li> <li><strong>Column</strong> -- Posición del marcador dentro de la línea.</li></ul> <p>Vamos a analizar en detalle la función <strong>lexParser</strong>. La función <strong>todo</strong> busca el índice del símbolo en el alfabeto y recupera un nuevo estado, un identificador de token (si lo hay) y otras banderas de la tabla de transición en función del estado actual y el símbolo entrante.</p> <p>El análisis en sí implica llamar a la función <strong>todo</strong> para cada carácter siguiente y cambiar a un nuevo estado. Una vez que se recibe un token, creamos el token correspondiente en el criterio de salida y continuamos analizando.</p> <p>Cabe señalar que durante el análisis, no acumulamos tokens de símbolos en una pila o matriz separada, ya que solo guardamos el desplazamiento donde comienza el token. Después de obtener el token, movemos el desplazamiento del siguiente token a la posición actual de análisis.</p> <p>La parte restante es verificar las banderas de estado léxico utilizadas en el análisis:</p> <blockquote><ul><li><strong>lexfPush</strong> -- Esta bandera significa que comenzamos a acumular símbolos en un nuevo token;</li> <li><strong>lexfNext</strong> -- Este carácter debe agregarse al token actual;</li> <li><strong>lexfPop</strong> -- Se recibe el token y, por lo general, tenemos el tipo de identificador de token para el análisis;</li> <li><strong>lexfSkip</strong> -- Esta bandera se utiliza para excluir caracteres del análisis, como barras de control en cadenas <code>\n \r \&quot;</code>. Se reemplazan automáticamente durante la fase de análisis léxico.</li></ul></blockquote> <h2 id="needle-language"><a href="#needle-language" class="header-anchor">#</a> Lenguaje Needle </h2> <h3 id="lexemes"><a href="#lexemes" class="header-anchor">#</a> Lexemas </h3> <p>El código fuente del programa debe estar codificado en UTF-8.</p> <p>Los siguientes tipos léxicos:</p> <blockquote><ul><li><strong>Palabras clave</strong> - <code>action</code>, <code>break</code>, <code>conditions</code>, <code>continue</code>,
<code>contract</code>, <code>data</code>, <code>else</code>, <code>error</code>, <code>false</code>, <code>func</code>, <code>if</code>,
<code>info</code>, <code>nil</code>, <code>return</code>, <code>settings</code>, <code>true</code>, <code>var</code>, <code>warning</code>,
<code>while</code>;</li> <li><strong>Números</strong> - Solo se aceptan números decimales. Hay dos tipos básicos: <strong>int</strong> y <strong>float</strong>. Si un número tiene un punto decimal, se convierte en un número de punto flotante <strong>float</strong>. El tipo <strong>int</strong> es equivalente a <strong>int64</strong> en golang. El tipo <strong>float</strong> es equivalente a <strong>float64</strong> en golang.</li> <li><strong>Cadenas</strong> - Las cadenas pueden estar entre comillas dobles (<code>&quot;una cadena&quot;</code>) o acentos graves (<code>\</code>una cadena`<code>). Ambos tipos de cadenas pueden contener saltos de línea. Las cadenas entre comillas dobles pueden contener comillas dobles, saltos de línea y retornos de carro escapados con una barra invertida. Por ejemplo,</code>&quot;Esto es una &quot;primera cadena&quot;.rnEsto es una segunda cadena.&quot;`.</li> <li><strong>Comentarios</strong> - Hay dos tipos de comentarios. Los comentarios de una sola línea usan dos barras inclinadas hacia adelante (<code>//</code>). Por ejemplo, <code>// Este es un comentario de una sola línea</code>. Los comentarios de varias líneas usan una barra inclinada hacia adelante y un asterisco (<code>/* */</code>) y pueden abarcar varias líneas. Por ejemplo, <code>/* Este es un comentario de varias líneas */</code>.</li> <li><strong>Identificadores</strong> - Nombres de variables y funciones que consisten en letras a-z y A-Z, símbolos UTF-8, números y guiones bajos. Los nombres pueden comenzar con una letra, guión bajo, <code>@</code> o <code>$</code>. Los nombres que comienzan con <code>$</code> son nombres de variables definidos en la <strong>sección de datos</strong>. Los nombres que comienzan con <code>$</code> también se pueden usar para definir variables globales dentro de la <strong>sección de condiciones</strong> y la <strong>sección de acciones</strong>. Los contratos inteligentes del ecosistema pueden usar el símbolo <code>@</code> para la invocación. Por ejemplo: <code>@1NewTable(...)</code>.</li></ul></blockquote> <h3 id="types"><a href="#types" class="header-anchor">#</a> Tipos </h3> <p>En la clase Needle, se especifica el tipo correspondiente de golang junto a ella.</p> <ul><li><strong>bool</strong> - bool, con un valor predeterminado de <strong>false</strong>;</li> <li><strong>bytes</strong> - []byte{}, con un valor predeterminado de una matriz de bytes vacía;</li> <li><strong>int</strong> - int64, con un valor predeterminado de <strong>0</strong>;</li> <li><strong>address</strong> - uint64, con un valor predeterminado de <strong>0</strong>;</li> <li><strong>array</strong> - []interface{}, con un valor predeterminado de una matriz vacía;</li> <li><strong>map</strong> - map[string]interface{}, con un valor predeterminado de un objeto de matriz vacío;</li> <li><strong>money</strong> - decimal.Decimal, con un valor predeterminado de <strong>0</strong>;</li> <li><strong>float</strong> - float64, con un valor predeterminado de <strong>0</strong>;</li> <li><strong>string</strong> - string, con un valor predeterminado de una cadena vacía;</li> <li><strong>file</strong> - map[string]interface{}, con un valor predeterminado de un objeto de matriz vacío.</li></ul> <p>Estos tipos de variables se definen utilizando la palabra clave <code>var</code>. Por ejemplo, <code>var var1, var2 int</code>. Cuando se define una variable de esta manera, recibirá el valor predeterminado de su tipo.</p> <p>Todos los valores de variables tienen el tipo <em>interface{}</em>, y luego se asignan al tipo de golang requerido. Por lo tanto, por ejemplo, los tipos <em>array</em> y <em>map</em> son tipos de golang <em>[]interface{}</em> y <em>map[string]interface{}</em>.</p> <p>Ambos tipos de matrices pueden contener elementos de cualquier tipo.</p> <h3 id="expressions"><a href="#expressions" class="header-anchor">#</a> Expresiones </h3> <p>Las expresiones pueden contener operaciones aritméticas, operaciones lógicas y llamadas a funciones. Todas las expresiones se evalúan de izquierda a derecha según su prioridad de operación. Si la prioridad de la operación es la misma, la evaluación también es de izquierda a derecha.</p> <p>La lista de operaciones de mayor a menor prioridad:</p> <ul><li><strong>Llamadas a funciones y paréntesis</strong> - Al llamar a una función, los parámetros pasados se evalúan de izquierda a derecha;</li> <li><strong>Operaciones unarias</strong> - Negación lógica <code>!</code> y cambio de signo aritmético <code>-</code>;</li> <li><strong>Multiplicación y división</strong> - Multiplicación aritmética <code>*</code> y división <code>/</code>;</li> <li><strong>Suma y resta</strong> - Suma aritmética <code>+</code> y resta <code>-</code>;</li> <li><strong>Comparación lógica</strong> - <code>&gt;= &gt; &gt; &gt;=</code>;</li> <li><strong>Igualdad y desigualdad lógica</strong> - <code>== !=</code>;</li> <li><strong>AND lógico</strong> - <code>&amp;&amp;</code>;</li> <li><strong>OR lógico</strong> - <code>||</code>.</li></ul> <p>Al evaluar el AND lógico y el OR lógico, siempre se evalúan ambos lados de la expresión.</p> <p>Needle no tiene comprobación de tipos en tiempo de compilación. Al evaluar operandos, intenta convertir el tipo a un tipo más complejo. El orden de complejidad para los tipos puede ser el siguiente: <code>string, int, float, money</code>, y solo se implementan conversiones de tipo parcial. El tipo de cadena admite operaciones de suma, lo que resulta en concatenación de cadenas. Por ejemplo, <code>string + string = string, money - int = money, int * float = float</code>.</p> <p>Para las funciones, se realiza una comprobación de tipos en los tipos <code>string</code> e <code>int</code> durante la ejecución.</p> <p>El tipo <strong>array</strong> y el tipo <strong>map</strong> pueden ser direccionados mediante índices.</p> <p>Para el tipo <strong>array</strong>, se debe especificar un valor <strong>int</strong> como índice. Para el tipo <strong>map</strong>, se debe especificar una variable o un valor <strong>string</strong> como índice.</p> <p>Si se asigna un valor a un elemento de un <strong>array</strong> con un índice mayor al índice máximo actual, se añadirán elementos vacíos al array. Estos elementos tendrán un valor de inicialización de <strong>nil</strong>. Por ejemplo: .. código:</p> <div class="language- extra-class"><pre><code>var my array
my[5] = 0
var mymap map
mymap[&quot;index&quot;] = my[3]
</code></pre></div><p>En las expresiones de lógica condicional (por ejemplo, <code>if</code>, <code>while</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>), el tipo se convertirá automáticamente en un valor lógico, si el tipo no es el valor predeterminado, entonces será verdadero.</p> <div class="language- extra-class"><pre class="language-text"><code>var mymap map
var val string
if mymap &amp;&amp; val {
...
}
</code></pre></div><h3 id="scope"><a href="#scope" class="header-anchor">#</a> Ámbito </h3> <p>Las llaves especifican un bloque que puede contener variables de ámbito local. Por defecto, el ámbito de la variable se extiende a su propio bloque y a todos los bloques anidados. En un bloque, se puede definir una nueva variable con el nombre de una variable existente. En este caso, la variable externa con el mismo nombre no está disponible.</p> <div class="language- extra-class"><pre class="language-text"><code>var a int
a = 3
{
   var a int
   a = 4
   Println(a) // 4
}
Println(a) // 3
</code></pre></div><h3 id="contract-execution"><a href="#contract-execution" class="header-anchor">#</a> Ejecución de contratos </h3> <p>Al llamar a un contrato inteligente, los parámetros definidos en la sección <strong>data</strong> deben ser pasados a él. Antes de ejecutar el contrato inteligente, la máquina virtual recibe estos parámetros y los asigna a las variables correspondientes ($Param).</p> <p>Luego se llaman la función predefinida <strong>conditions</strong> y la función <strong>action</strong>.</p> <p>Los errores que ocurren durante la ejecución de un contrato inteligente se pueden dividir en dos tipos: errores formales y errores ambientales. Los errores formales se generan utilizando comandos especiales: <code>error, warning, info</code> y cuando la función incorporada devuelve <code>err</code> no igual a <em>nil</em>.</p> <p>El lenguaje Needle no maneja excepciones. Cualquier error terminará la ejecución del contrato inteligente. Dado que se crea una pila separada y una estructura para almacenar valores de variables al ejecutar un contrato inteligente, el mecanismo de recolección de basura de golang eliminará automáticamente estos datos cuando se complete la ejecución del contrato inteligente.</p> <h3 id="backus-naur-form-bnf"><a href="#backus-naur-form-bnf" class="header-anchor">#</a> Forma Backus-Naur (BNF) </h3> <p>En informática, BNF es una técnica de símbolos utilizada para gramáticas libres de contexto, generalmente utilizada para describir la sintaxis de los lenguajes utilizados en informática.</p> <ul><li><p>&lt;decimal digit&gt; :</p> <div class="language- extra-class"><pre><code>'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
</code></pre></div></li> <li><p>&lt;decimal number&gt; :</p> <div class="language- extra-class"><pre><code>&lt;decimal digit&gt; {&lt;decimal digit&gt;}
</code></pre></div></li> <li><p>&lt;symbol code&gt; :</p> <div class="language- extra-class"><pre><code>'''&lt;any symbol&gt;'''
</code></pre></div></li> <li><p>&lt;real number&gt; :</p> <div class="language- extra-class"><pre><code>['-'] &lt;decimal number'.'[&lt;decimal number&gt;]
</code></pre></div></li> <li><p>&lt;integer number&gt; :</p> <div class="language- extra-class"><pre><code>['-'] &lt;decimal number&gt; | &lt;symbol code&gt;
</code></pre></div></li> <li><p>&lt;number&gt; :</p> <div class="language- extra-class"><pre><code>'&lt;integer number&gt; | &lt;real number&gt;'
</code></pre></div></li> <li><p>&lt;letter&gt; :</p> <div class="language- extra-class"><pre><code>'A' | 'B' | ... | 'Z' | 'a' | 'b' | ... | 'z' | 0x80 | 0x81 | ... | 0xFF
</code></pre></div></li> <li><p>&lt;space&gt; :</p> <div class="language- extra-class"><pre><code>'0x20'
</code></pre></div></li> <li><p>&lt;tabulation&gt; :</p> <div class="language- extra-class"><pre><code>'0x09'
</code></pre></div></li> <li><p>&lt;newline&gt; :</p> <div class="language- extra-class"><pre><code>'0x0D 0x0A'
</code></pre></div></li> <li><p>&lt;special symbol&gt; :</p> <div class="language- extra-class"><pre><code>'!' | '&quot;' | '$' | ''' | '(' | ')' | '\*' | '+' | ',' | '-' | '.' | '/' | '&lt;' | '=' | '&gt;' | '[' | '\\' | ']' | '_' | '|' | '}' | '{' | &lt;tabulation&gt; | &lt;space&gt; | &lt;newline&gt;
</code></pre></div></li> <li><p>&lt;symbol&gt; :</p> <div class="language- extra-class"><pre><code>&lt;decimal digit&gt; | &lt;letter&gt; | &lt;special symbol&gt;
</code></pre></div></li> <li><p>&lt;name&gt; :</p> <div class="language- extra-class"><pre><code>(&lt;letter&gt; | '_') {&lt;letter&gt; | '_' | &lt;decimal digit&gt;}
</code></pre></div></li> <li><p>&lt;function name&gt; :</p> <div class="language- extra-class"><pre><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;variable name&gt; :</p> <div class="language- extra-class"><pre><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;type name&gt; :</p> <div class="language- extra-class"><pre><code>&lt;name&gt;
</code></pre></div></li> <li><p>&lt;string symbol&gt; :</p> <div class="language- extra-class"><pre><code>&lt;tabulation&gt; | &lt;space&gt; | '!' | '#' | ... | '[' | ']' | ... 
</code></pre></div></li> <li><p>&lt;string element&gt; :</p> <div class="language- extra-class"><pre><code>{&lt;string symbol&gt; | '\&quot;' | '\n' | '\r' }
</code></pre></div></li> <li><p>&lt;string&gt; :</p> <div class="language- extra-class"><pre><code>'&quot;' { &lt;string element&gt; } '&quot;' | '\`'  { &lt;string element&gt; } '\`'
</code></pre></div></li> <li><p>&lt;assignment operator&gt; :</p> <div class="language- extra-class"><pre><code>'=' 
</code></pre></div></li> <li><p>&lt;unary operator&gt; :</p> <div class="language- extra-class"><pre><code>'-'
</code></pre></div></li> <li><p>&lt;binary operator&gt; :</p> <div class="language- extra-class"><pre><code>'==' | '!=' | '&gt;' | '&lt;' | '&lt;=' | '&gt;=' | '&amp;&amp;' | '||' | '\*' | '/' | '+' | '-' 
</code></pre></div></li> <li><p>&lt;operator&gt; :</p> <div class="language- extra-class"><pre><code>&lt;assignment operator&gt; | &lt;unary operator&gt; | &lt;binary operator&gt;
</code></pre></div></li> <li><p>&lt;parameters&gt; :</p> <div class="language- extra-class"><pre><code>&lt;expression&gt; {','&lt;expression&gt;}
</code></pre></div></li> <li><p>&lt;contract call&gt; :</p> <div class="language- extra-class"><pre><code>&lt;contract name&gt; '(' [&lt;parameters&gt;] ')'
</code></pre></div></li> <li><p>&lt;function call&gt; :</p> <div class="language- extra-class"><pre><code>&lt;contract call&gt; [{'.' &lt;name&gt; '(' [&lt;parameters&gt;] ')'}]
</code></pre></div></li> <li><p>&lt;block contents&gt; :</p> <div class="language- extra-class"><pre><code>&lt;block command&gt; {&lt;newline&gt;&lt;block command&gt;}
</code></pre></div></li> <li><p>&lt;block&gt; :</p> <div class="language- extra-class"><pre><code>'{'&lt;block contents&gt;'}'
</code></pre></div></li> <li><p>&lt;block command&gt; :</p> <div class="language- extra-class"><pre><code>(&lt;block&gt; | &lt;expression&gt; | &lt;variables definition&gt; | &lt;if&gt; | &lt;while&gt; | break | continue | return)
</code></pre></div></li> <li><p>&lt;if&gt; :</p> <div class="language- extra-class"><pre><code>'if &lt;expression&gt;&lt;block&gt; [else &lt;block&gt;]'
</code></pre></div></li> <li><p>&lt;while&gt; :</p> <div class="language- extra-class"><pre><code>'while &lt;expression&gt;&lt;block&gt;'
</code></pre></div></li> <li><p>&lt;contract&gt; :</p> <div class="language- extra-class"><pre><code>'contract &lt;name&gt; '{'[&lt;data section&gt;] {&lt;function&gt;} [&lt;conditions&gt;] [&lt;action&gt;]'}''
</code></pre></div></li> <li><p>&lt;data section&gt; :</p> <div class="language- extra-class"><pre><code>'data '{' {&lt;data parameter&gt;&lt;newline&gt;} '}''
</code></pre></div></li> <li><p>&lt;data parameter&gt; :</p> <div class="language- extra-class"><pre><code>&lt;variable name&gt; &lt;type name&gt; '&quot;'{&lt;tag&gt;}'&quot;' 
</code></pre></div></li> <li><p>&lt;tag&gt; :</p> <div class="language- extra-class"><pre><code>'optional | image | file | hidden | text | polymap | map | address | signature:&lt;name&gt;'
</code></pre></div></li> <li><p>&lt;conditions&gt; :</p> <div class="language- extra-class"><pre><code>'conditions &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;action&gt; :</p> <div class="language- extra-class"><pre><code>'action &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;function&gt; :</p> <div class="language- extra-class"><pre><code>'func &lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'[{&lt;tail&gt;}] [&lt;type name&gt;] &lt;block&gt;'
</code></pre></div></li> <li><p>&lt;variable description&gt; :</p> <div class="language- extra-class"><pre><code>&lt;variable name&gt; {',' &lt;variable name&gt;} &lt;type name&gt;
</code></pre></div></li> <li><p>&lt;tail&gt; :</p> <div class="language- extra-class"><pre><code>'.'&lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'
</code></pre></div></li> <li><p>&lt;variables definition&gt; :</p> <div class="language- extra-class"><pre><code>'var &lt;variable description&gt;{','&lt;variable description&gt;}'
</code></pre></div></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/IBAX-io/documentation/edit/master/docs/es/topics/vm.md" target="_blank" rel="noopener noreferrer">Edita esta página en GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Última actualización:</span> <span class="time">25/6/2023, 15:46:02</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/es/topics/templates2.html" class="prev">
        Lenguaje de plantillas 
      </a></span> <span class="next"><a href="/es/topics/daemons.html">
        Demonio 
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8ffd1d30.js" defer></script><script src="/assets/js/2.8d94a0db.js" defer></script><script src="/assets/js/46.facf3822.js" defer></script>
  </body>
</html>
