<!DOCTYPE html>
<html lang="tr-TR">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Compiler and Virtual Machine | IBAX Belgeleri</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="apple-touch-icon" size="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" size="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" size="16x16" href="/favicon-16x16.png">
    <link rel="mask-icon" color="#5bbad5" href="/safari-pinned-tab.svg">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="description" content="A Decentralized Commercial Cross-Chain infrastructure Network">
    
    <link rel="preload" href="/assets/css/0.styles.844a2aa8.css" as="style"><link rel="preload" href="/assets/js/app.1fdb8a3a.js" as="script"><link rel="preload" href="/assets/js/2.14a295a1.js" as="script"><link rel="preload" href="/assets/js/128.fde84ac4.js" as="script"><link rel="prefetch" href="/assets/js/10.83378578.js"><link rel="prefetch" href="/assets/js/100.dcda4418.js"><link rel="prefetch" href="/assets/js/101.3f002483.js"><link rel="prefetch" href="/assets/js/102.93011a96.js"><link rel="prefetch" href="/assets/js/103.7288a5c6.js"><link rel="prefetch" href="/assets/js/104.8f885d74.js"><link rel="prefetch" href="/assets/js/105.6b3019b7.js"><link rel="prefetch" href="/assets/js/106.2ddf3989.js"><link rel="prefetch" href="/assets/js/107.b7bef053.js"><link rel="prefetch" href="/assets/js/108.2ad33fac.js"><link rel="prefetch" href="/assets/js/109.72abead6.js"><link rel="prefetch" href="/assets/js/11.279ca8e2.js"><link rel="prefetch" href="/assets/js/110.4114438c.js"><link rel="prefetch" href="/assets/js/111.55ff9cad.js"><link rel="prefetch" href="/assets/js/112.9afb3e2d.js"><link rel="prefetch" href="/assets/js/113.fe55a09e.js"><link rel="prefetch" href="/assets/js/114.2d7b1c8b.js"><link rel="prefetch" href="/assets/js/115.f538cdf8.js"><link rel="prefetch" href="/assets/js/116.bd5b4011.js"><link rel="prefetch" href="/assets/js/117.e12a9fbf.js"><link rel="prefetch" href="/assets/js/118.f513f593.js"><link rel="prefetch" href="/assets/js/119.760ef2ca.js"><link rel="prefetch" href="/assets/js/12.7bb4f7bb.js"><link rel="prefetch" href="/assets/js/120.0be976db.js"><link rel="prefetch" href="/assets/js/121.d5cedafb.js"><link rel="prefetch" href="/assets/js/122.8dff3a57.js"><link rel="prefetch" href="/assets/js/123.bdff3bcb.js"><link rel="prefetch" href="/assets/js/124.bb513256.js"><link rel="prefetch" href="/assets/js/125.de1e04a4.js"><link rel="prefetch" href="/assets/js/126.1979b4ba.js"><link rel="prefetch" href="/assets/js/127.3b445fcd.js"><link rel="prefetch" href="/assets/js/129.5fdca64d.js"><link rel="prefetch" href="/assets/js/13.845b3ac4.js"><link rel="prefetch" href="/assets/js/130.aacd2cdb.js"><link rel="prefetch" href="/assets/js/131.174c03f0.js"><link rel="prefetch" href="/assets/js/132.dc402607.js"><link rel="prefetch" href="/assets/js/133.71b40ea8.js"><link rel="prefetch" href="/assets/js/134.d6af2ba1.js"><link rel="prefetch" href="/assets/js/135.031ac685.js"><link rel="prefetch" href="/assets/js/136.79fa1a1e.js"><link rel="prefetch" href="/assets/js/137.d48f478a.js"><link rel="prefetch" href="/assets/js/138.7e763317.js"><link rel="prefetch" href="/assets/js/139.77214828.js"><link rel="prefetch" href="/assets/js/14.d492bd0f.js"><link rel="prefetch" href="/assets/js/140.3d3f94c2.js"><link rel="prefetch" href="/assets/js/141.b71bc8c6.js"><link rel="prefetch" href="/assets/js/142.837769b4.js"><link rel="prefetch" href="/assets/js/143.a934de75.js"><link rel="prefetch" href="/assets/js/144.5b723479.js"><link rel="prefetch" href="/assets/js/145.9382ab60.js"><link rel="prefetch" href="/assets/js/146.da6f9125.js"><link rel="prefetch" href="/assets/js/147.e3e6894e.js"><link rel="prefetch" href="/assets/js/148.aba3ae3a.js"><link rel="prefetch" href="/assets/js/149.273acb61.js"><link rel="prefetch" href="/assets/js/15.97374dd5.js"><link rel="prefetch" href="/assets/js/150.1537541e.js"><link rel="prefetch" href="/assets/js/16.d5fadb1f.js"><link rel="prefetch" href="/assets/js/17.85070bd8.js"><link rel="prefetch" href="/assets/js/18.1cff6c24.js"><link rel="prefetch" href="/assets/js/19.142e1664.js"><link rel="prefetch" href="/assets/js/20.6aa700a9.js"><link rel="prefetch" href="/assets/js/21.f79562fe.js"><link rel="prefetch" href="/assets/js/22.c36f814f.js"><link rel="prefetch" href="/assets/js/23.3fc4b8f0.js"><link rel="prefetch" href="/assets/js/24.ff0bd2fa.js"><link rel="prefetch" href="/assets/js/25.a364ffe9.js"><link rel="prefetch" href="/assets/js/26.4d190cda.js"><link rel="prefetch" href="/assets/js/27.f7273c62.js"><link rel="prefetch" href="/assets/js/28.7895237d.js"><link rel="prefetch" href="/assets/js/29.d8f4cc81.js"><link rel="prefetch" href="/assets/js/3.5bcf211a.js"><link rel="prefetch" href="/assets/js/30.94b3175d.js"><link rel="prefetch" href="/assets/js/31.4e810261.js"><link rel="prefetch" href="/assets/js/32.ab295dfc.js"><link rel="prefetch" href="/assets/js/33.720c5bbd.js"><link rel="prefetch" href="/assets/js/34.789ca12e.js"><link rel="prefetch" href="/assets/js/35.2b42f8e4.js"><link rel="prefetch" href="/assets/js/36.fba2560a.js"><link rel="prefetch" href="/assets/js/37.d9363eaf.js"><link rel="prefetch" href="/assets/js/38.059132ee.js"><link rel="prefetch" href="/assets/js/39.0b03c921.js"><link rel="prefetch" href="/assets/js/4.1e8ca44e.js"><link rel="prefetch" href="/assets/js/40.c1393e87.js"><link rel="prefetch" href="/assets/js/41.04c6038d.js"><link rel="prefetch" href="/assets/js/42.905da8ae.js"><link rel="prefetch" href="/assets/js/43.19649e28.js"><link rel="prefetch" href="/assets/js/44.94776414.js"><link rel="prefetch" href="/assets/js/45.3ba157f9.js"><link rel="prefetch" href="/assets/js/46.8687d0eb.js"><link rel="prefetch" href="/assets/js/47.aff2b61b.js"><link rel="prefetch" href="/assets/js/48.dc9554ed.js"><link rel="prefetch" href="/assets/js/49.37da269e.js"><link rel="prefetch" href="/assets/js/5.50ebf2b0.js"><link rel="prefetch" href="/assets/js/50.61cbf8e3.js"><link rel="prefetch" href="/assets/js/51.b4b41ad6.js"><link rel="prefetch" href="/assets/js/52.63b36668.js"><link rel="prefetch" href="/assets/js/53.96aace2f.js"><link rel="prefetch" href="/assets/js/54.58c1c613.js"><link rel="prefetch" href="/assets/js/55.d9ffd6d6.js"><link rel="prefetch" href="/assets/js/56.86ca51c4.js"><link rel="prefetch" href="/assets/js/57.84653a3c.js"><link rel="prefetch" href="/assets/js/58.71b16290.js"><link rel="prefetch" href="/assets/js/59.75f73182.js"><link rel="prefetch" href="/assets/js/6.b72a56bb.js"><link rel="prefetch" href="/assets/js/60.257187e5.js"><link rel="prefetch" href="/assets/js/61.e593a701.js"><link rel="prefetch" href="/assets/js/62.5a57fa28.js"><link rel="prefetch" href="/assets/js/63.72e4ec3c.js"><link rel="prefetch" href="/assets/js/64.251500bf.js"><link rel="prefetch" href="/assets/js/65.13440155.js"><link rel="prefetch" href="/assets/js/66.b3f22aae.js"><link rel="prefetch" href="/assets/js/67.d643eaeb.js"><link rel="prefetch" href="/assets/js/68.1391041a.js"><link rel="prefetch" href="/assets/js/69.f076f69f.js"><link rel="prefetch" href="/assets/js/7.97328cfb.js"><link rel="prefetch" href="/assets/js/70.21d1fa26.js"><link rel="prefetch" href="/assets/js/71.a3d3f1cd.js"><link rel="prefetch" href="/assets/js/72.03370bd4.js"><link rel="prefetch" href="/assets/js/73.a5e6fbb3.js"><link rel="prefetch" href="/assets/js/74.3ed5a665.js"><link rel="prefetch" href="/assets/js/75.15c05bc2.js"><link rel="prefetch" href="/assets/js/76.cf457c63.js"><link rel="prefetch" href="/assets/js/77.b62b05f7.js"><link rel="prefetch" href="/assets/js/78.95a748e7.js"><link rel="prefetch" href="/assets/js/79.fec1765f.js"><link rel="prefetch" href="/assets/js/8.596f1de1.js"><link rel="prefetch" href="/assets/js/80.fc3ac8ab.js"><link rel="prefetch" href="/assets/js/81.b35c265f.js"><link rel="prefetch" href="/assets/js/82.ffbae7df.js"><link rel="prefetch" href="/assets/js/83.2c1a7eea.js"><link rel="prefetch" href="/assets/js/84.e36356eb.js"><link rel="prefetch" href="/assets/js/85.3341d558.js"><link rel="prefetch" href="/assets/js/86.92e9c8e8.js"><link rel="prefetch" href="/assets/js/87.32878110.js"><link rel="prefetch" href="/assets/js/88.ddffedd6.js"><link rel="prefetch" href="/assets/js/89.0715a479.js"><link rel="prefetch" href="/assets/js/9.ae816606.js"><link rel="prefetch" href="/assets/js/90.14e64fc9.js"><link rel="prefetch" href="/assets/js/91.cbdc1e1b.js"><link rel="prefetch" href="/assets/js/92.3726c36e.js"><link rel="prefetch" href="/assets/js/93.9b6ae4dd.js"><link rel="prefetch" href="/assets/js/94.cf9dd272.js"><link rel="prefetch" href="/assets/js/95.dc1f3866.js"><link rel="prefetch" href="/assets/js/96.e8b2265d.js"><link rel="prefetch" href="/assets/js/97.3c6e04b7.js"><link rel="prefetch" href="/assets/js/98.ecfbcf5d.js"><link rel="prefetch" href="/assets/js/99.516d8b9f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.844a2aa8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/tr-TR/" class="home-link router-link-active"><img src="/ibax.ico" alt="IBAX Belgeleri" class="logo"> <span class="site-name can-hide">IBAX Belgeleri</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tr-TR/concepts/about-the-platform.html" class="nav-link">
  Genel Bakış
</a></div><div class="nav-item"><a href="/tr-TR/tutorials/app_tutorial.html" class="nav-link">
  öğretici
</a></div><div class="nav-item"><a href="/tr-TR/topics/script.html" class="nav-link">
  kılavuz
</a></div><div class="nav-item"><a href="/tr-TR/reference/api2.html" class="nav-link">
  başvurmak
</a></div><div class="nav-item"><a href="/tr-TR/howtos/deployment.html" class="nav-link">
  dağıtmak
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Bir dil seçin" class="dropdown-title"><span class="title">Bir dil seçin</span> <span class="arrow down"></span></button> <button type="button" aria-label="Bir dil seçin" class="mobile-dropdown-title"><span class="title">Bir dil seçin</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/topics/vm.html" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/de/topics/vm.html" class="nav-link">
  Deutsch
</a></li><li class="dropdown-item"><!----> <a href="/es/topics/vm.html" class="nav-link">
  Español
</a></li><li class="dropdown-item"><!----> <a href="/fr/topics/vm.html" class="nav-link">
  Français
</a></li><li class="dropdown-item"><!----> <a href="/it/topics/vm.html" class="nav-link">
  Italiano
</a></li><li class="dropdown-item"><!----> <a href="/ja/topics/vm.html" class="nav-link">
  日本語
</a></li><li class="dropdown-item"><!----> <a href="/zh-CN/topics/vm.html" class="nav-link">
  简体中文
</a></li><li class="dropdown-item"><!----> <a href="/tr-TR/topics/vm.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Türkçe
</a></li></ul></div></div> <a href="https://github.com/IBAX-io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tr-TR/concepts/about-the-platform.html" class="nav-link">
  Genel Bakış
</a></div><div class="nav-item"><a href="/tr-TR/tutorials/app_tutorial.html" class="nav-link">
  öğretici
</a></div><div class="nav-item"><a href="/tr-TR/topics/script.html" class="nav-link">
  kılavuz
</a></div><div class="nav-item"><a href="/tr-TR/reference/api2.html" class="nav-link">
  başvurmak
</a></div><div class="nav-item"><a href="/tr-TR/howtos/deployment.html" class="nav-link">
  dağıtmak
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Bir dil seçin" class="dropdown-title"><span class="title">Bir dil seçin</span> <span class="arrow down"></span></button> <button type="button" aria-label="Bir dil seçin" class="mobile-dropdown-title"><span class="title">Bir dil seçin</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/topics/vm.html" class="nav-link">
  English
</a></li><li class="dropdown-item"><!----> <a href="/de/topics/vm.html" class="nav-link">
  Deutsch
</a></li><li class="dropdown-item"><!----> <a href="/es/topics/vm.html" class="nav-link">
  Español
</a></li><li class="dropdown-item"><!----> <a href="/fr/topics/vm.html" class="nav-link">
  Français
</a></li><li class="dropdown-item"><!----> <a href="/it/topics/vm.html" class="nav-link">
  Italiano
</a></li><li class="dropdown-item"><!----> <a href="/ja/topics/vm.html" class="nav-link">
  日本語
</a></li><li class="dropdown-item"><!----> <a href="/zh-CN/topics/vm.html" class="nav-link">
  简体中文
</a></li><li class="dropdown-item"><!----> <a href="/tr-TR/topics/vm.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Türkçe
</a></li></ul></div></div> <a href="https://github.com/IBAX-io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>kılavuz</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tr-TR/topics/script.html" class="sidebar-link">Akıllı kontratlar</a></li><li><a href="/tr-TR/topics/templates2.html" class="sidebar-link">Şablon Dili</a></li><li><a href="/tr-TR/topics/vm.html" aria-current="page" class="active sidebar-link">Compiler and Virtual Machine</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tr-TR/topics/vm.html#kaynak-kodu-depolama-ve-derleme" class="sidebar-link">Kaynak kodu depolama ve derleme</a></li><li class="sidebar-sub-header"><a href="/tr-TR/topics/vm.html#sanal-makine-yapıları" class="sidebar-link">Sanal makine yapıları</a></li><li class="sidebar-sub-header"><a href="/tr-TR/topics/vm.html#sanal-makine-komutları" class="sidebar-link">Sanal makine komutları</a></li><li class="sidebar-sub-header"><a href="/tr-TR/topics/vm.html#compiler" class="sidebar-link">Compiler</a></li><li class="sidebar-sub-header"><a href="/tr-TR/topics/vm.html#lexical-analizor" class="sidebar-link">Lexical analizör</a></li><li class="sidebar-sub-header"><a href="/tr-TR/topics/vm.html#needle-dili" class="sidebar-link">Needle dili</a></li></ul></li><li><a href="/tr-TR/topics/daemons.html" class="sidebar-link">Arka plan programı</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="compiler-and-virtual-machine"><a href="#compiler-and-virtual-machine" class="header-anchor">#</a> Compiler and Virtual Machine</h1> <ul><li><a href="#Kaynak-kodu-depolama-ve-derleme">Kaynak kodu depolama ve derleme</a></li> <li><a href="#Sanal-makine-yap%C4%B1lar%C4%B1">Sanal makine yapıları</a> <ul><li><a href="#VM-Yap%C4%B1lar%C4%B1">VM Yapıları</a></li> <li><a href="#Blok-Yap%C4%B1lar%C4%B1">Blok Yapıları</a></li> <li><a href="#ObjInfo-Yap%C4%B1s%C4%B1">ObjInfo Yapısı</a> <ul><li><a href="#ContractInfo-Yap%C4%B1s%C4%B1">ContractInfo Yapısı</a></li> <li><a href="#FieldInfo-Yap%C4%B1s%C4%B1">FieldInfo Yapısı</a></li> <li><a href="#FuncInfo-Yap%C4%B1s%C4%B1">FuncInfo Yapısı</a></li> <li><a href="#FuncName-Yap%C4%B1s%C4%B1">FuncName Yapısı</a></li> <li><a href="#ExtFuncInfo-Yap%C4%B1s%C4%B1">ExtFuncInfo Yapısı</a></li> <li><a href="#VarInfo-Yap%C4%B1s%C4%B1">VarInfo Yapısı</a></li> <li><a href="#ObjExtend-De%C4%9Fer">ObjExtend Değer</a></li></ul></li></ul></li> <li><a href="#Sanal-makine-komutlar%C4%B1">Sanal makine komutları</a> <ul><li><a href="#ByteCode-Yap%C4%B1s%C4%B1">ByteCode Yapısı</a></li> <li><a href="#command-identifiers">Command identifiers</a></li> <li><a href="#Y%C4%B1%C4%9F%C4%B1n-i%C5%9Flem-komutlar%C4%B1">Yığın işlem komutları</a></li> <li><a href="#Runtime-Yap%C4%B1s%C4%B1">Runtime Yapısı</a> <ul><li><a href="#blockStack-Yap%C4%B1s%C4%B1">blockStack Yapısı</a></li></ul></li> <li><a href="#RunCode-Fonksiyonu">RunCode Fonksiyonu</a></li> <li><a href="#VM-ile-i%C5%9Flemler-i%C3%A7in-di%C4%9Fer-i%C5%9Flevler">VM ile işlemler için diğer işlevler</a></li></ul></li> <li><a href="#compiler">Compiler</a></li> <li><a href="#Lexical-analiz%C3%B6r">Lexical analizör</a> <ul><li><a href="#lextable-lextable-go">lextable/lextable.go</a></li> <li><a href="#lex-go">lex.go</a></li></ul></li> <li><a href="#needle-dili">Needle dili</a> <ul><li><a href="#lexemes">Lexemes</a></li> <li><a href="#Types">Türler</a></li> <li><a href="#expressions">Expressions</a></li> <li><a href="#scope">Scope</a></li> <li><a href="#Kontrat-Y%C3%BCr%C3%BCtme">Kontrat yürütme</a></li> <li><a href="#Backus%E2%80%93Naur-Formu-(BNF)">Backus–Naur Formu (BNF)</a></li></ul></li></ul> <p>Bu bölüm, Sanal Makinede (VM) program derleme ve Needle dili işlemlerini içerir.</p> <h2 id="kaynak-kodu-depolama-ve-derleme"><a href="#kaynak-kodu-depolama-ve-derleme" class="header-anchor">#</a> Kaynak kodu depolama ve derleme</h2> <p>Sözleşmeler ve fonksiyonlar Golang ile yazılır ve ekosistemlerin sözleşme tablolarında saklanır.</p> <p>Bir sözleşme yürütüldüğünde, kaynak kodu veritabanından okunacak ve bayt koduna derlenecektir.</p> <p>Bir sözleşme değiştirildiğinde, kaynak kodu güncellenecek ve veritabanına kaydedilecektir. Daha sonra kaynak kod derlenir, böylece ilgili sanal makinedeki bayt kodu güncellenir.</p> <p>Bayt kodları fiziksel olarak kaydedilmediği için program tekrar çalıştırıldığında yeniden derlenecektir.</p> <p>Her ekosistemin sözleşme tablosunda açıklanan kaynak kodunun tamamı katı bir sırayla sanal bir makinede derlenir ve sanal makinenin durumu tüm düğümlerde aynıdır.</p> <p>Sözleşme çağrıldığında, sanal makine durumunu hiçbir şekilde değiştirmeyecektir. Herhangi bir sözleşmenin yürütülmesi veya herhangi bir işlevin çağrılması, her harici çağrı sırasında oluşturulan ayrı bir çalışan yığında gerçekleşir.</p> <p>Her ekosistem, blok zinciri veya diğer sanal ekosistemler üzerinde doğrudan etki olmaksızın blok zinciri dışındaki tablolarla birlikte bir düğüm içinde kullanılabilen sanal bir ekosisteme sahip olabilir. Bu durumda böyle bir sanal ekosistemi barındıran düğüm, sözleşmesini derleyecek ve kendi sanal makinesini oluşturacaktır.</p> <h2 id="sanal-makine-yapıları"><a href="#sanal-makine-yapıları" class="header-anchor">#</a> Sanal makine yapıları</h2> <h3 id="vm-yapıları"><a href="#vm-yapıları" class="header-anchor">#</a> VM Yapıları</h3> <p>Bir sanal makine, aşağıdaki gibi bir yapı olarak bellekte düzenlenmiştir.</p> <div class="language- extra-class"><pre class="language-text"><code>type VM struct {
   Block
   ExtCost func(string) int64
   FuncCallsDB map[string]struct{}
   Extern bool
   ShiftContract int64
   logger *log.Entry
}
</code></pre></div><p>Bir VM yapısı aşağıdaki öğelere sahiptir:</p> <ul><li>Blok - bir <a href="#block-structure">blok yapısı</a>;</li> <li>ExtCost - bir işlev, harici bir golang işlevini yürütmenin maliyetini döndürür;</li> <li>FuncCallsDB - Golang işlev adlarının bir koleksiyonu. Bu işlev, yürütme maliyetini ilk parametre olarak döndürür. Bu işlevler, veritabanı işleme maliyetini hesaplamak için EXPLAIN'i kullanır;</li> <li>Extern - bir sözleşmenin harici bir sözleşme olup olmadığını gösteren bir Boole bayrağı. Bir VM oluşturulduğunda true olarak ayarlanır. Kod derlendiğinde çağrılan sözleşmeler görüntülenmez. Yani ileride belirlenen sözleşme kodunun çağrılmasını sağlar;</li> <li>ShiftContract - VM'deki ilk sözleşmenin kimliği;</li> <li>logger - VM hata günlüğü çıktısı.</li></ul> <h3 id="blok-yapıları"><a href="#blok-yapıları" class="header-anchor">#</a> Blok Yapıları</h3> <p>Sanal makine, <strong>Blok tipi</strong> nesnelerden oluşan bir ağaçtır.</p> <p>Bir blok, bazı bayt kodları içeren bağımsız bir birimdir. Basit bir ifadeyle, dilde parantezler (<code>{}</code>) içine koyduğunuz her şey bir bloktur.</p> <p>Örneğin, aşağıdaki kod, fonksiyonlara sahip bir blok oluşturacaktır. Bu blok ayrıca bir if ifadesine sahip başka bir blok içerir ve bu blok while ifadesine sahip bir blok içerir.</p> <div class="language- extra-class"><pre class="language-text"><code>func my() {
   if true {
      while false {
      ...
      }
   }
}
</code></pre></div><p>Blok, bellekte aşağıdaki gibi bir yapı olarak düzenlenmiştir.</p> <div class="language- extra-class"><pre class="language-text"><code>type Block struct {
   Objects map[string]*ObjInfo
   Type int
   Owner *OwnerInfo
   Info interface{}
   Parent *Block
   Vars []reflect.Type
   Code ByteCodes
   Children Blocks
}
</code></pre></div><p>Bir blok yapısı aşağıdaki unsurlardan oluşur:</p> <ul><li><strong>Objects</strong> - <a href="#objInfo-structure">ObjInfo</a> pointer türündeki internal objelerin haritası. Örneğin, blokta bir değişken varsa, onun adıyla ilgili bilgi alabilirsiniz;</li> <li><strong>Type</strong> - bloğun türü. Bir fonksiyon bloğu için tipi <strong>ObjFunc</strong>; bir sözleşme bloğu için türü <strong>ObjContract</strong>'tır;</li> <li><strong>Owner</strong> - <strong>OwnerInfo</strong> işaretçi türünün yapısı. Bu yapı, sözleşmenin derlenmesi sırasında belirtilen veya <strong>sözleşmeler</strong> tablosundan elde edilen, derlenmiş sözleşmenin sahibine ilişkin bilgileri içerir;</li> <li><strong>Info</strong> - blok türüne bağlı olarak nesne hakkında bilgi içerir;</li> <li><strong>Parent</strong> - üst bloğa bir işaretçi;</li> <li><strong>Vars</strong> - mevcut blok değişkenlerinin türlerini içeren bir dizi;</li> <li><strong>Code</strong> - örneğin fonksiyon çağrıları veya döngü gövdeleri gibi kontrol hakları bloğa aktarıldığında yürütülecek bloğun kendisinin bayt kodu;</li> <li><strong>Children</strong> - fonksiyon iç içe yerleştirme, döngüler, koşullu operatörler gibi alt blokları içeren bir dizi.</li></ul> <h3 id="objinfo-yapısı"><a href="#objinfo-yapısı" class="header-anchor">#</a> ObjInfo Yapısı</h3> <p>ObjInfo yapısı, internal nesneler hakkında bilgi içerir.</p> <div class="language- extra-class"><pre class="language-text"><code>type ObjInfo struct {
   Type int
   Value interface{}
}
</code></pre></div><p>ObjInfo yapısı aşağıdaki öğelere sahiptir:</p> <ul><li><strong>Type</strong> is the object type, which has any of the following values:
<ul><li><strong>ObjContract</strong> – <a href="#contractInfo-structure">contract</a>;</li> <li><strong>ObjFunc</strong> - function;</li> <li><strong>ObjExtFunc</strong> - external golang function;</li> <li><strong>ObjVar</strong> - variable;</li> <li><strong>ObjExtend</strong> - $name variable.</li></ul></li> <li><strong>Value</strong> – it contains the structure of each type.</li></ul> <h4 id="contractinfo-yapısı"><a href="#contractinfo-yapısı" class="header-anchor">#</a> ContractInfo Yapısı</h4> <p><strong>ObjContract</strong> türüne işaret edilir ve <strong>Value</strong> alanı bir <strong>ContractInfo</strong> yapısı içerir.</p> <div class="language- extra-class"><pre class="language-text"><code>type ContractInfo struct {
   ID uint32
   Name string
   Owner *OwnerInfo
   Used map[string]bool
   Tx *[]*FieldInfo
}
</code></pre></div><p>ContractInfo yapısı aşağıdaki değişkenlere sahiptir:</p> <ul><li><strong>ID</strong> - sözleşme çağrılırken blok zincirinde görüntülenen contractID</li> <li><strong>Name</strong> - contract adı;</li> <li><strong>Owner</strong> - sözleşme ile ilgili diğer bilgiler;</li> <li><strong>Used</strong> - çağrılan sözleşme adlarının haritası;</li> <li><strong>Tx</strong> - kontratın <a href="/tr-TR/topics/script.html#data-section">data section</a> açıklanan bir veri dizisi.</li></ul> <h4 id="fieldinfo-yapısı"><a href="#fieldinfo-yapısı" class="header-anchor">#</a> FieldInfo Yapısı</h4> <p>FieldInfo yapısı <strong>ContractInfo</strong> yapısında kullanılır ve bir sözleşmenin <a href="/tr-TR/topics/script.html#data-section">datasection</a> içindeki öğeleri açıklar.</p> <div class="language- extra-class"><pre class="language-text"><code>type FieldInfo struct {
   Name string
   Type reflect.Type
   Original uint32
   Tags string
}
</code></pre></div><p>FieldInfo yapısı aşağıdaki öğelere sahiptir:</p> <ul><li><strong>Name</strong> - field adı;</li> <li><strong>Type</strong> - field tipi;</li> <li><strong>Original</strong> - opsiyonel field;</li> <li><strong>Tags</strong> - bu alan için ek etiketler.</li></ul> <h4 id="funcinfo-yapısı"><a href="#funcinfo-yapısı" class="header-anchor">#</a> FuncInfo Yapısı</h4> <p>ObjFunc tipine işaret eden ve Değer alanı bir FuncInfo yapısı içerir.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncInfo struct {
   Params []reflect.Type
   Results []reflect.Type
   Names *map[string]FuncName
   Variadic bool
   ID uint32
}
</code></pre></div><p>FuncInfo yapısı aşağıdaki değişkenlere sahiptir:</p> <ul><li><strong>Params</strong> - bir dizi parametre türü;</li> <li><strong>Results</strong> - bir dizi döndürülen tür;</li> <li><strong>Names</strong> - örneğin kuyruk fonksiyonları için veri haritası, <code>DBFind().Columns ()</code>;</li> <li><strong>Variadic</strong> - işlev değişken sayıda parametreye sahip olabilirse true;</li> <li><strong>ID</strong> - function ID.</li></ul> <h4 id="funcname-yapısı"><a href="#funcname-yapısı" class="header-anchor">#</a> FuncName Yapısı</h4> <p>FuncName yapısı, FuncInfo için kullanılır ve bir kuyruk fonksiyonunun verilerini tanımlar.</p> <div class="language- extra-class"><pre class="language-text"><code>type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
</code></pre></div><p>FuncName yapısı aşağıdaki öğelere sahiptir:</p> <ul><li><strong>Params</strong> - bir dizi parametre türü;</li> <li><strong>Offset</strong> - bu değişkenler için ofset dizisi. Aslında, bir fonksiyondaki tüm parametrelerin değerleri dot. ile başlatılabilir;</li> <li><strong>Variadic</strong> - tail işlevi değişken sayıda parametreye sahip olabilirse true.</li></ul> <h4 id="extfuncinfo-yapısı"><a href="#extfuncinfo-yapısı" class="header-anchor">#</a> ExtFuncInfo Yapısı</h4> <p>ObjExtFunc türüne işaret eden ve Değer alanı bir ExtFuncInfo yapısı içerir. Golang fonksiyonlarını tanımlamak için kullanılır.</p> <div class="language- extra-class"><pre class="language-text"><code>type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
</code></pre></div><p>ExtFuncInfo yapısı aşağıdaki öğelere sahiptir:</p> <ul><li><strong>Name</strong>, <strong>Params</strong>, <strong>Results</strong> parametreler <a href="#funcinfo-structure">FuncInfo</a> ile aynı yapıya sahiptir;</li> <li><strong>Auto</strong> - bir dizi değişken. Varsa ek parametre olarak fonksiyona geçer. Örneğin, SmartContract sc türünde bir değişken;</li> <li><strong>Func</strong> - golang fonksiyonu.</li></ul> <h4 id="varinfo-yapısı"><a href="#varinfo-yapısı" class="header-anchor">#</a> VarInfo Yapısı</h4> <p><strong>ObjVar</strong> türüne işaret edilir ve <strong>Value</strong> alanı bir <strong>VarInfo</strong> yapısı içerir.</p> <div class="language- extra-class"><pre class="language-text"><code>type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
</code></pre></div><p>VarInfo yapısı aşağıdaki unsurlara sahiptir:</p> <ul><li><strong>Obj</strong> - değişkenin türü ve değeri hakkında bilgi;</li> <li><strong>Owner</strong> - Owner bloğunun pointerı.</li></ul> <h4 id="objextend-deger"><a href="#objextend-deger" class="header-anchor">#</a> ObjExtend Değer</h4> <p><strong>ObjExtend</strong> türüne işaret edilir ve <strong>Value</strong> alanı, değişken veya işlevin adını içeren bir dize içerir.</p> <h2 id="sanal-makine-komutları"><a href="#sanal-makine-komutları" class="header-anchor">#</a> Sanal makine komutları</h2> <h3 id="bytecode-yapısı"><a href="#bytecode-yapısı" class="header-anchor">#</a> ByteCode Yapısı</h3> <p>Bir bayt kodu, <strong>ByteCode</strong> tipi yapıların bir dizisidir.</p> <div class="language- extra-class"><pre class="language-text"><code>type ByteCode struct {
   Cmd uint16
   Value interface{}
}
</code></pre></div><p>Bu yapı aşağıdaki alanlara sahiptir:</p> <ul><li><strong>Cmd</strong> - the identifier of the storage commands;</li> <li><strong>Value</strong> - işleneni içerir (değer).</li></ul> <p>Genel olarak komutlar, yığının en üst öğesinde bir işlem gerçekleştirir ve gerekirse sonuç değerini buna yazar.</p> <h3 id="command-identifiers"><a href="#command-identifiers" class="header-anchor">#</a> Command identifiers</h3> <p>Sanal makine komutlarının identifiersları, vm/cmds_list.go dosyasında açıklanmıştır.</p> <ul><li><strong>cmdPush</strong> – Değer alanından yığına bir değer koyun. Örneğin, yığına sayılar ve satırlar koyun;</li> <li><strong>cmdVar</strong> - bir değişkenin değerini yığına koyun. Değer, VarInfo yapısına bir işaretçi ve değişken hakkında bilgi içerir;</li> <li><strong>cmdExtend</strong> – yığına harici bir değişkenin değerini koyun. Değer, değişken adıyla ($ ile başlayan) bir dize içerir;</li> <li><strong>cmdCallExtend</strong> – harici bir işlevi çağırın ($ ile başlayan). Fonksiyonun parametreleri yığından elde edilir ve sonuçlar yığına yerleştirilir. Değer bir fonksiyon adı içerir ($ ile başlar);</li> <li><strong>cmdPushStr</strong> – dizeyi Değer'e yığına koyun;</li> <li><strong>cmdCall</strong> - sanal makine işlevini çağırır. Değer bir <strong>ObjInfo</strong> yapısı içerir. Bu komut, <strong>ObjExtFunc</strong> golang işlevi ve <strong>ObjFunc</strong> İğne işlevi için geçerlidir. Bir fonksiyon çağrılırsa, parametreleri yığından alınacak ve sonuç değerleri yığına yerleştirilecektir;</li> <li><strong>cmdCallVari</strong> - <strong>cmdCall</strong> komutuna benzer şekilde sanal makine işlevini çağırır. Bu komut, değişken sayıda parametreye sahip bir işlevi çağırmak için kullanılır;</li> <li><strong>cmdReturn</strong> - fonksiyondan çıkmak için kullanılır. Dönüş değerleri yığına konur ve Değer alanı kullanılmaz;</li> <li><strong>cmdIf</strong> – Değer alanına iletilen <strong>blok</strong> yapısındaki bayt koduna kontrolü aktarın. Kontrol, yalnızca yığının en üst öğesi <em>valueToBool</em> işlevi tarafından çağrıldığında ve 'true' döndürüldüğünde yığına aktarılacaktır. Aksi takdirde, kontrol bir sonraki komuta aktarılacaktır;</li> <li><strong>cmdElse</strong> - bu komut, <strong>cmdIf</strong> ile aynı şekilde çalışır, ancak yalnızca yığının üst öğesi valueToBool işlevi tarafından çağrıldığında ve 'false' döndürüldüğünde, kontrol belirtilen bloğa aktarılacaktır;</li> <li><strong>cmdAssignVar</strong> – Value'dan <strong>VarInfo</strong> türündeki değişkenlerin bir listesini alın. Bu değişkenler,<strong>cmdAssign</strong> değeri almak için komut;</li> <li><strong>cmdAssign</strong> – yığındaki değeri <strong>cmdAssignVar</strong> komutuyla elde edilen değişkene atayın;</li> <li><strong>cmdLabel</strong> - while döngüsü sırasında kontrol döndürüldüğünde bir etiket tanımlar;</li> <li><strong>cmdContinue</strong> - bu komut, kontrolü <strong>cmdLabel</strong> etiketine aktarır. Döngünün yeni bir yinelemesi yürütülürken Değer kullanılmaz;</li> <li><strong>cmdWhile</strong> – yığının üst öğesini kontrol etmek için valueToBool kullanın. Bu değer &quot;doğru&quot; ise,<strong>block</strong> yapı, değer alanından çağrılır;</li> <li><strong>cmdBreak</strong> - döngüden çıkar;</li> <li><strong>cmdIndex</strong> – Değer kullanmadan, haritadaki veya dizideki değeri dizine göre yığına koyun. Örneğin, <code>(map | array) (index value) =&gt; (map | array [index value])</code>;</li> <li><strong>cmdSetIndex</strong> – Değer kullanmadan, yığının en üst öğesinin değerini harita veya dizi öğelerine atar. Örneğin, <code>(map | array) (index value) (value) =&gt; (map | array)</code>;</li> <li><strong>cmdFuncName</strong> - dot. ile bölünen sıralı açıklamalar kullanılarak geçirilen parametreleri ekler. Örneğin, <code>func name =&gt; Func (...) .Name (...)</code>;</li> <li><strong>cmdUnwrapArr</strong> - yığının en üst öğesi bir dizi ise bir Boole bayrağı tanımlar;</li> <li><strong>cmdMapInit</strong> – map değerini başlatır;</li> <li><strong>cmdArrayInit</strong> - dizinin değerini başlatır;</li> <li><strong>cmdError</strong> - bu komut, bir sözleşme veya işlev belirtilen bir ile sona erdiğinde oluşturulur.<code>error, warning, info</code>.</li></ul> <h3 id="yıgın-islem-komutları"><a href="#yıgın-islem-komutları" class="header-anchor">#</a> Yığın işlem komutları</h3> <blockquote><p>Not</p></blockquote> <blockquote><p>Mevcut sürümde, bu komutlar için otomatik tip dönüştürme tam olarak uygulanamaz. Örneğin,</p></blockquote> <blockquote><p><code>string + float | int | decimal =&gt; float | int | decimal, float + int | str =&gt; float, but int + string =&gt; runtime error</code>.</p></blockquote> <p>Aşağıdakiler, doğrudan yığın işleme için komutlardır. Bu komutlarda Değer alanı kullanılmaz.</p> <ul><li><strong>cmdNot</strong> - logical negation. <code>(val) =&gt; (!ValueToBool(val))</code>;</li> <li><strong>cmdSign</strong> - change of sign. <code>(val) =&gt; (-val)</code>;</li> <li><strong>cmdAdd</strong> - addition. <code>(val1)(val2) =&gt; (val1 + val2)</code>;</li> <li><strong>cmdSub</strong> - subtraction. <code>(val1)(val2) =&gt; (val1-val2)</code>;</li> <li><strong>cmdMul</strong> - multiplication. <code>(val1)(val2) =&gt; (val1 * val2)</code>;</li> <li><strong>cmdDiv</strong> - division. <code>(val1)(val2) =&gt; (val1 / val2)</code>;</li> <li><strong>cmdAnd</strong> - logical AND. <code>(val1)(val2) =&gt; (valueToBool(val1) &amp;&amp; valueToBool(val2))</code>;</li> <li><strong>cmdOr</strong> - logical OR. <code>(val1)(val2) =&gt; (valueToBool(val1) || valueToBool(val2))</code>;</li> <li><strong>cmdEqual</strong> - equality comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 == val2)</code>;</li> <li><strong>cmdNotEq</strong> - inequality comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 != val2)</code>;</li> <li><strong>cmdLess</strong> - less-than comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 &lt;val2)</code>;</li> <li><strong>cmdNotLess</strong> - greater-than-or-equal comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 &gt;= val2)</code>;</li> <li><strong>cmdGreat</strong> - greater-than comparison, bool is returned. <code>(val1)(val2) =&gt; (val1&gt; val2)</code>;</li> <li><strong>cmdNotGreat</strong> - less-than-or-equal comparison, bool is returned. <code>(val1)(val2) =&gt; (val1 &lt;= val2)</code>.</li></ul> <h3 id="runtime-yapısı"><a href="#runtime-yapısı" class="header-anchor">#</a> Runtime Yapısı</h3> <p>Bayt kodlarının yürütülmesi sanal makineyi etkilemez. Örneğin, çeşitli işlevlerin ve sözleşmelerin tek bir sanal makinede aynı anda çalışmasına izin verir. Runtime yapısı, herhangi bir ifade ve bayt kodunun yanı sıra işlevleri ve sözleşmeleri çalıştırmak için kullanılır.</p> <div class="language- extra-class"><pre class="language-text"><code>type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}
</code></pre></div><ul><li><strong>stack</strong> - bayt kodunu yürütmek için yığın;</li> <li><strong>blocks</strong> - calls yığınını engelle;</li> <li><strong>vars</strong> - değişken yığını. Blokta bayt kodu çağrıldığında, değişkeni değişken yığınına eklenecektir. Bloktan çıktıktan sonra, değişken yığınının boyutu önceki değere dönecektir;</li> <li><strong>extend</strong> - external değişkenlerin değerleriyle eşlenecek bir işaretçi (<code>$name</code>);</li> <li><strong>vm</strong> - bir sanal makine işaretçisi;</li> <li><strong>cost</strong> - ortaya çıkan yürütme maliyetinin yakıt birimi;</li> <li><strong>err</strong> - yürütme sırasında hata oluştu.</li></ul> <h4 id="blockstack-yapısı"><a href="#blockstack-yapısı" class="header-anchor">#</a> blockStack Yapısı</h4> <p>Runtime yapısında blockStack yapısı kullanılır.</p> <div class="language- extra-class"><pre class="language-text"><code>type blockStack struct {
   Block *Block
   Offset int
}
</code></pre></div><ul><li><strong>Block</strong> - yürütülmekte olan bloğa bir işaretçi;</li> <li><strong>Offset</strong> – belirtilen bloğun bayt kodunda yürütülen son komutun ofseti.</li></ul> <h3 id="runcode-fonksiyonu"><a href="#runcode-fonksiyonu" class="header-anchor">#</a> RunCode Fonksiyonu</h3> <p>Bayt kodları <strong>RunCode</strong> işlevinde yürütülür. Her bayt kodu komutu için karşılık gelen işlemi gerçekleştiren bir döngü içerir. Bir bayt kodunu işlemeden önce, gerekli veriler başlatılmalıdır.</p> <p>Diğer bloklara yeni bloklar eklenir.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = append(rt.blocks, &amp;blockStack{block, len(rt.vars)})
</code></pre></div><p>Ardından, kuyruk fonksiyonunun ilgili parametrelerinin bilgilerini alın. Bu parametreler yığının son elemanında bulunur.</p> <div class="language- extra-class"><pre class="language-text"><code>var namemap map[string][]interface{}
if block.Type == ObjFunc &amp;&amp; block.Info.(*FuncInfo).Names != nil {
   if rt.stack[len(rt.stack)-1] != nil {
      namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
   }
   rt.stack = rt.stack[:len(rt.stack)-1]
}
</code></pre></div><p>Ardından, mevcut blokta tanımlanan tüm değişkenler, başlangıç ​​değerleri ile başlatılmalıdır.</p> <div class="language- extra-class"><pre class="language-text"><code>start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
   rt.cost--
   var value interface{}
</code></pre></div><p>Fonksiyondaki değişkenler de değişken olduğundan, onları fonksiyonun tanımladığı sıraya göre yığının son elemanından almamız gerekir.</p> <div class="language- extra-class"><pre class="language-text"><code>   if block.Type == ObjFunc &amp;&amp; vkey &lt;len(block.Info.(*FuncInfo).Params) {
      value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
   } else {
</code></pre></div><p>Yerel değişkenleri başlangıç ​​değerleriyle başlatın.</p> <div class="language- extra-class"><pre class="language-text"><code>      value = reflect.New(vpar).Elem().Interface()

      if vpar == reflect.TypeOf(map[string]interface{}{}) {

         value = make(map[string]interface{})
      } else if vpar == reflect.TypeOf([]interface{}{}) {
         value = make([]interface{}, 0, len(rt.vars)+1)
      }
   }
   rt.vars = append(rt.vars, value)
}
</code></pre></div><p>Ardından, tail işlevinde geçirilen değişken parametrelerin değerlerini güncelleyin.</p> <div class="language- extra-class"><pre class="language-text"><code>if namemap != nil {
   for key, item := range namemap {
      params := (*block.Info.(*FuncInfo).Names)[key]
      for i, value := range item {
         if params.Variadic &amp;&amp; i &gt;= len(params.Params)-1 {
</code></pre></div><p>Geçirilen değişken parametreler değişken sayıda parametreye aitse, bu parametreler bir dizi değişkende birleştirilir.</p> <div class="language- extra-class"><pre class="language-text"><code>            off := varoff + params.Offset[len(params.Params)-1]
            rt.vars[off] = append(rt.vars[off].([]interface{}), value)
         } else {
            rt.vars[varoff+params.Offset[i]] = value
         }
      }
   }
}
</code></pre></div><p>Bundan sonra tek yapmamız gereken, yığının tepesinden fonksiyon parametreleri olarak geçen değerleri silmek ve böylece yığını taşımaktır. Değerlerini bir değişken dizisine kopyaladık.</p> <div class="language- extra-class"><pre class="language-text"><code>if block.Type == ObjFunc {
   start -= len(block.Info.(*FuncInfo).Params)
}
</code></pre></div><p>Bir bayt kodu komut döngüsü bittiğinde, yığını doğru şekilde temizlemeliyiz.</p> <div class="language- extra-class"><pre class="language-text"><code>last := rt.blocks[len(rt.blocks)-1]
</code></pre></div><p>Mevcut bloğu blok yığınından silin.</p> <div class="language- extra-class"><pre class="language-text"><code>rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
</code></pre></div><p>Halihazırda yürütülen bir fonksiyondan başarıyla çıkılırsa, dönüş değerini önceki yığının sonuna ekleyeceğiz.</p> <div class="language- extra-class"><pre class="language-text"><code>   if last.Block.Type == ObjFunc {
      for count := len(last.Block.Info.(*FuncInfo).Results); count &gt; 0; count-- {
         rt.stack[start] = rt.stack[len(rt.stack)-count]
         start++
      }
      status = statusNormal
   } else {
</code></pre></div><p>Gördüğünüz gibi, fonksiyonu çalıştırmazsak, yığın durumunu geri yüklemeyeceğiz ve fonksiyondan olduğu gibi çıkmayacağız. Bunun nedeni, fonksiyonda yürütülen döngüler ve koşullu yapıların da bayt kodu blokları olmasıdır.</p> <div class="language- extra-class"><pre class="language-text"><code>   return

   }
}

rt.stack = rt.stack[:start]
</code></pre></div><h3 id="vm-ile-islemler-icin-diger-islevler"><a href="#vm-ile-islemler-icin-diger-islevler" class="header-anchor">#</a> VM ile işlemler için diğer işlevler</h3> <p><strong>NewVM</strong> işleviyle sanal bir makine oluşturabilirsiniz. Her sanal makine, <strong>Extend</strong> işlevi aracılığıyla <strong>ExecContract</strong>, <strong>MemoryUsage</strong>, <strong>CallContract</strong> ve <strong>Settings</strong> gibi dört işlevle eklenecektir.</p> <div class="language- extra-class"><pre class="language-text"><code>for key, item := range ext.Objects {
   fobj := reflect.ValueOf(item).Type()
</code></pre></div><p>Geçen tüm nesneleri dolaşıyoruz ve sadece işlevlere bakıyoruz.</p> <div class="language- extra-class"><pre class="language-text"><code>   switch fobj.Kind() {
   case reflect.Func:
</code></pre></div><p><strong>ExtFuncInfo</strong> yapısını fonksiyon hakkında aldığımız bilgilere göre dolduruyoruz ve yapısını üst seviye haritasına <strong>Objects</strong> ismiyle ekliyoruz.</p> <div class="language- extra-class"><pre class="language-text"><code>   data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()), make([]reflect.Type, fobj.NumOut()),
   make([]string, fobj.NumIn()), fobj.IsVariadic(), item}
   for i := 0; i &lt;fobj.NumIn(); i++ {
</code></pre></div><p><strong>ExtFuncInfo</strong> yapısı bir <strong>Auto</strong> parametre dizisine sahiptir. Genellikle ilk parametre <code>sc *SmartContract</code>veya <code>rt *Runtime</code>'dır, onları Needle dilinden geçiremeyiz, çünkü bunlar bizim için bazı golang fonksiyonlarını yürütmemiz için gereklidir. Bu nedenle bu fonksiyonlar çağrıldığında bu değişkenlerin otomatik olarak kullanılacağını belirtiyoruz. Bu durumda, yukarıdaki dört işlevin ilk parametresi <code>rt *Runtime</code>dır.</p> <div class="language- extra-class"><pre class="language-text"><code>   if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
      data.Auto[i] = isauto
   }
</code></pre></div><p>Parametrelerin atanması hakkında bilgi.</p> <div class="language- extra-class"><pre class="language-text"><code>      data.Params[i] = fobj.In(i)
   }
</code></pre></div><p>Ve dönüş değerleri türleri.</p> <div class="language- extra-class"><pre class="language-text"><code>for i := 0; i &lt;fobj.NumOut(); i++ {
   data.Results[i] = fobj.Out(i)
}
</code></pre></div><p>Derleyicinin daha sonra sözleşmeyi kullanırken bulabilmesi için <strong>Objects</strong> köküne bir işlev ekler.</p> <div class="language- extra-class"><pre class="language-text"><code>      vm.Objects[key] = &amp;ObjInfo{ObjExtFunc, data}
   }

}
</code></pre></div><h2 id="compiler"><a href="#compiler" class="header-anchor">#</a> Compiler</h2> <p>compile.go dosyasındaki işlevler, sözcük çözümleyicisinden elde edilen belirteç dizisini derlemekten sorumludur. Derleme şartlı olarak iki seviyeye ayrılabilir. En üst düzeyde, işlevler, sözleşmeler, kod blokları, koşullu ve döngü ifadeleri, değişken tanımları vb. ile ilgileniyoruz. Alt düzeyde, ifadeleri kod bloklarında veya koşulları döngülerde ve koşullu ifadelerde derleriz.</p> <p>İlk olarak, basit alt seviyeden başlayacağız. <strong>compileEval</strong> işlevinde ifadeler bayt koduna dönüştürülebilir. Yığınlı bir sanal makine kullandığımız için, sıradan infix kayıt ifadelerini postfix notasyonuna veya ters Lehçe notasyonuna dönüştürmek gerekir. Örneğin, <code>1+2</code>yi <code>12+</code>ya çeviririz ve yığına <code>1</code> ve <code>2</code> koyarız. Ardından stack içerisindeki son iki elemana toplama işlemini uyguluyoruz ve sonucu stack’e yazıyoruz. Bu <a href="https://master.virmandy.net/perevod-iz-infiksnoy-notatsii-v-postfiksnuyu-obratnaya-polskaya-zapis/" target="_blank" rel="noopener noreferrer">conversion<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> algoritmasını İnternette bulabilirsiniz.</p> <p><code>opers = map [uint32] operPrior</code> global değişkeni, invers Polish gösterime dönüştürmek için gereken işlemlerin önceliğini içerir.</p> <p><strong>compileEval</strong> işlevinin başında aşağıdaki değişkenler tanımlanır:</p> <ul><li><strong>buffer</strong> - bayt kodu komutları için geçici arabellek;</li> <li><strong>bytecode</strong> - bayt kodu komutlarının son arabelleği;</li> <li><strong>parcount</strong> - bir işlevi çağırırken parametreleri hesaplamak için kullanılan geçici buffer;</li> <li><strong>setIndex</strong> - harita veya dizi öğeleri atadığımızda, çalışma sürecindeki değişkenler true olarak ayarlanacaktır. Örneğin, <code>a[&quot;my&quot;] = 10</code>. Bu durumda belirtilen <strong>cmdSetIndex</strong> komutunu kullanmamız gerekiyor.</li></ul> <p>Bir döngüde bir token alırız ve buna göre işleriz. Örneğin, braces bulunursa ifade eşlemesi durdurulacaktır. Stringi taşırken önceki statement bir işlem olup olmadığını ve parantez içinde olup olmadığını kontrol ederiz, aksi halde parse edilen ifadeden çıkacaktır.</p> <div class="language- extra-class"><pre class="language-text"><code>case isRCurly, isLCurly:
   i--
   if prevLex == isComma || prevLex == lexOper {
      return errEndExp
   }
   break main
case lexNewLine:
   if i &gt; 0 &amp;&amp; ((*lexems)[i-1].Type == isComma || (*lexems)[i-1].Type == lexOper) {
      continue main
   }
   for k := len(buffer) - 1; k &gt;= 0; k-- {
   if buffer[k].Cmd == cmdSys {
      continue main
   }
}
break main

</code></pre></div><p>Genel olarak, algoritmanın kendisi, inverse Polish notasyonuna dönüştürmek için bir algoritmaya karşılık gelir. Gerekli sözleşmelerin, işlevlerin ve dizinlerin çağrılmasının yanı sıra ayrıştırma sırasında karşılaşılmayan diğer şeyler ve lexIdent tipi belirteçleri ayrıştırma seçenekleri göz önüne alındığında, bu adla değişkenler, işlevler veya sözleşmeler kontrol edilecektir. Hiçbir şey bulunamazsa ve bu bir işlev veya sözleşme çağrısı değilse, bir hata olduğunu gösterir.</p> <div class="language- extra-class"><pre class="language-text"><code>objInfo, tobj := vm.findObj(lexem.Value.(string), block)
if objInfo == nil &amp;&amp; (!vm.Extern || i&gt; *ind || i &gt;= len(*lexems)-2 || (*lexems)[i+1].Type != isLPar) {
   return fmt.Errorf(`unknown identifier %s`, lexem.Value.(string))
}
</code></pre></div><p>Böyle bir durumla karşılaşabiliriz ve sözleşme görüşmesi daha sonra anlatılacaktır. Bu örnekte, aynı isimde herhangi bir fonksiyon veya değişken bulunamazsa, bir sözleşme çağırmanın gerekli olduğunu düşünüyoruz. Bu derlenmiş dilde, sözleşmeler ve işlev çağrıları arasında hiçbir fark yoktur. Ancak sözleşmeyi bytecode'da kullanılan <strong>ExecContract</strong> işlevi aracılığıyla çağırmamız gerekiyor.</p> <div class="language- extra-class"><pre class="language-text"><code>if objInfo.Type == ObjContract {
   if objInfo.Value != nil {
      objContract = objInfo.Value.(*Block)
   }
   objInfo, tobj = vm.findObj(`ExecContract`, block)
   isContract = true
}
</code></pre></div><p>Şimdiye kadarki değişkenlerin sayısını, fonksiyon parametrelerinin sayısı ile birlikte yığına da yazılacak olan <code>count</code> içine kaydederiz. Parametrelerin sonraki her tespitinde, yığının son elemanında bu sayıyı yalnızca bir birim artırmamız gerekir.</p> <div class="language- extra-class"><pre class="language-text"><code>count := 0
if (*lexems)[i+2].Type != isRPar {
   count++
}
</code></pre></div><p>Kontratlar için kullanılan parametreleri içeren bir listemiz var, sonra kontratın çağrıldığı durumu işaretlememiz gerekiyor. Kontrat parametresiz çağrılırsa, en az iki parametre almak için <strong>ExecContract</strong> çağrısına iki boş parametre eklemeliyiz.</p> <div class="language- extra-class"><pre class="language-text"><code>if isContract {
   name := StateName((*block)[0].Info.(uint32), lexem.Value.(string))
   for j := len(*block) - 1; j &gt;= 0; j-- {
   topblock := (*block)[j]
      if topblock.Type == ObjContract {
         if topblock.Info.(*ContractInfo).Used == nil {
            topblock.Info.(*ContractInfo).Used = make(map[string]bool)
         }
         topblock.Info.(*ContractInfo).Used[name] = true
      }
   }
   bytecode = append(bytecode, &amp;ByteCode{cmdPush, name})
   if count == 0 {
      count = 2
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
      bytecode = append(bytecode, &amp;ByteCode{cmdPush, &quot;&quot;})
   }
   count++
}
</code></pre></div><p>Yanında bir braces olduğunu görürsek, indekse göre değeri almak için <strong>cmdIndex</strong> komutunu ekliyoruz.</p> <div class="language- extra-class"><pre class="language-text"><code>if (*lexems)[i+1].Type == isLBrack {
   if objInfo == nil || objInfo.Type != ObjVar {
      return fmt.Errorf(`unknown variable %s`, lexem.Value.(string))
   }
   buffer = append(buffer, &amp;ByteCode{cmdIndex, 0})
}
</code></pre></div><p><strong>CompileBlock</strong> işlevi, nesne ağaçları ve ifadeden bağımsız bayt kodları oluşturabilir. Derleme işlemi, tıpkı bir sözlüksel çözümleyici gibi, ancak aşağıdaki farklılıklarla birlikte, sonlu durumlu bir makineye dayanmaktadır. İlk olarak, semboller değil tokenlar kullanıyoruz; ikinci olarak, tüm durumlar ve geçişlerdeki <em>durumlar</em> değişkenlerini hemen tanımlayacağız. Belirteç türüne göre dizine alınmış bir dizi nesneyi temsil eder. Her simgenin bir <em>compileState</em> yapısı vardır ve <em>NewState</em> içinde yeni bir durum belirtilir. Hangi yapıyı çözdüğümüz açıksa, <em>Func</em> alanında işleyicinin fonksiyonunu belirtebiliriz.</p> <p>Örnek olarak ana durumu inceleyelim.</p> <p>Bir satırsonu veya yorumla karşılaşırsak, aynı durumda kalırız. <strong>contract</strong> anahtar kelimesiyle karşılaşırsak, durumu <em>stateContract</em> olarak değiştirir ve yapıyı ayrıştırmaya başlarız. <strong>func</strong> anahtar kelimesiyle karşılaşırsak, durumu <em>stateFunc</em> olarak değiştiririz. Diğer belirteçler alınırsa, fonksiyon üreten hata çağrılır.</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateRoot
   lexNewLine: {stateRoot, 0},
   lexKeyword | (keyContract &lt;&lt; 8): {stateContract | statePush, 0},
   lexKeyword | (keyFunc &lt;&lt; 8): {stateFunc | statePush, 0},
   lexComment: {stateRoot, 0},
   0: {errUnknownCmd, cfError},
},
</code></pre></div><p><strong>func</strong> anahtar sözcüğüyle karşılaştığımızı ve durumu <em>stateFunc</em> olarak değiştirdiğimizi varsayalım. İşlev adının <strong>func</strong> anahtar sözcüğünü takip etmesi gerektiğinden, işlev adını değiştirirken aynı durumu koruyacağız. Diğer tüm belirteçler için ilgili hataları üreteceğiz. Belirteç tanımlayıcıda işlev adını alırsak, işlevin parametrelerini alabileceğimiz <em>stateFParams</em> durumuna gideriz.</p> <div class="language- extra-class"><pre class="language-text"><code>{// stateFunc
   lexNewLine: {stateFunc, 0},
   lexIdent: {stateFParams, cfNameBlock},
   0: {errMustName, cfError},
},
</code></pre></div><p>Yukarıdaki işlemlerle aynı zamanda <strong>fNameBlock</strong> fonksiyonunu çağıracağız. Unutulmamalıdır ki Block yapısı, tampondan aldığımız ve ihtiyacımız olan verilerle doldurduğumuz statePush işareti ile oluşturulmaktadır. <strong>fNameBlock</strong> işlevi, sözleşmeler ve işlevler için uygundur (iç içe geçmiş olanlar dahil). <em>Bilgi</em> alanını ilgili yapı ile doldurur ve kendisini üst bloğun <em>Nesnelerine</em> yazar. Bu şekilde belirtilen isim ile fonksiyonu veya sözleşmeyi çağırabiliriz. Benzer şekilde, tüm durumlar ve değişkenler için karşılık gelen fonksiyonlar yaratırız. Bu işlevler genellikle çok küçüktür ve sanal makine ağacını oluştururken bazı görevleri yerine getirir.</p> <div class="language- extra-class"><pre class="language-text"><code>func fNameBlock(buf *[]*Block, state int, lexem *Lexem) error {
   var itype int
   prev := (*buf)[len(*buf)-2]
   fblock := (*buf)[len(*buf)-1]
   name := lexem.Value.(string)
   switch state {
      case stateBlock:
         itype = ObjContract
         name = StateName((*buf)[0].Info.(uint32), name)
         fblock.Info = &amp;ContractInfo{ID: uint32(len(prev.Children) - 1), Name: name,
         Owner: (*buf)[0].Owner}
      default:
         itype = ObjFunc
         fblock.Info = &amp;FuncInfo{}
   }
   fblock.Type = itype
   prev.Objects[name] = &amp;ObjInfo{Type: itype, Value: fblock}
   return nil
}
</code></pre></div><p><strong>CompileBlock</strong> işlevi için, tüm belirteçler arasında geçiş yapar ve durumlarda açıklanan belirteçlere göre durumları değiştirir. Hemen hemen tüm ek belirteçler, ek program kodlarına karşılık gelir.</p> <ul><li><strong>statePush</strong> – <strong>Blok</strong> nesnesini nesne ağacına ekler;</li> <li><strong>statePop</strong> - blok bir kapatma braces ile sona erdiğinde kullanılır;</li> <li><strong>stateStay</strong> - yeni bir duruma geçerken mevcut işareti korumanız gerekir;</li> <li><strong>stateToBlock</strong> - <em>while</em> ve <em>if</em> işlemek için <strong>stateBlock</strong> durumuna geçiş. İfadeleri işledikten sonra, parantez içindeki blokları işlemeniz gerekir;</li> <li><strong>stateToBody</strong> - <strong>stateBody</strong> durumuna geçiş;</li> <li><strong>stateFork</strong> - işaretli konumu kaydedin. İfade bir tanımlayıcı veya <code>$</code> ile bir isim ile başladığında, fonksiyon çağrıları veya atamalar yapabiliriz;</li> <li><strong>stateToFork</strong> – işlem işlevine iletilecek olan <strong>stateFork</strong> içinde saklanan belirteci almak için kullanılır;</li> <li><strong>stateLabel</strong> – <strong>cmdLabel</strong> komutlarını eklemek için kullanılır. <em>while</em> yapısı bu bayrağı gerektirir;</li> <li><strong>stateMustEval</strong> – <em>if</em> ve <em>while</em> yapılarının başında koşullu ifadelerin kullanılabilirliğini kontrol edin.</li></ul> <p><strong>CompileBlock</strong> işlevine ek olarak, <strong>FlushBlock</strong> işlevinden de bahsedilmelidir. Ancak sorun, blok ağacının mevcut sanal makinelerden bağımsız olarak oluşturulmasıdır. Daha doğrusu sanal bir makinede var olan işlevler ve sözleşmeler hakkında bilgi alıyoruz ancak derlenen blokları ayrı bir ağaçta topluyoruz. Aksi halde derleme sırasında bir hata oluşursa sanal makineyi bir önceki duruma döndürmemiz gerekir. Bu nedenle derleme ağacına ayrı ayrı gidiyoruz fakat derleme başarılı olduktan sonra <strong>FlushContract</strong> fonksiyonu çağrılmalıdır. Bu işlev, tamamlanmış blok ağacını mevcut sanal makineye ekler. Derleme aşaması artık tamamlanmıştır.</p> <h2 id="lexical-analizor"><a href="#lexical-analizor" class="header-anchor">#</a> Lexical analizör</h2> <p>Sözcüksel çözümleyici, gelen dizeleri işler ve aşağıdaki türlerde bir dizi belirteç oluşturur:</p> <ul><li><strong>lexSys</strong> - system token, örnek: <code>{}, [], (), ,, .</code> etc;</li> <li><strong>lexOper</strong> - operation token, örnek: <code>+, -, /, \, *</code>;</li> <li><strong>lexNumber</strong> - number;</li> <li><strong>lexident</strong> - identifier;</li> <li><strong>lexNewline</strong> - newline character;</li> <li><strong>lexString</strong> - string;</li> <li><strong>lexComment</strong> - comment;</li> <li><strong>lexKeyword</strong> - keyword;</li> <li><strong>lexType</strong> - type;</li> <li><strong>lexExtend</strong> - harici değişkenlere veya fonksiyonlara referans, örneğin: <code>$myname</code>.</li></ul> <p>Mevcut sürümde, lex_table.go dosyasına yazılan belirteçleri ayrıştırmak için başlangıçta <a href="#lextablelextablego">script/lextable/lextable.go</a> dosyası yardımıyla bir dönüşüm tablosu (sonlu durum makinesi) oluşturulur. Genel olarak, dosya tarafından başlangıçta oluşturulan dönüştürme tablosundan kurtulabilir ve başlangıçta hemen bellekte (<code>init()</code>) bir dönüştürme tablosu oluşturabilirsiniz. Sözcük analizinin kendisi <a href="#lex-go">lex.go</a> dosyasındaki lexParser işlevinde gerçekleşir.</p> <h3 id="lextable-lextable-go"><a href="#lextable-lextable-go" class="header-anchor">#</a> <span id="lextable-lextable-go">lextable/lextable.go</span></h3> <p>Burada çalışacak alfabeyi tanımlıyoruz ve sonlu durum makinesinin bir sonraki alınan sembole göre bir durumdan diğerine nasıl değiştiğini açıklıyoruz.</p> <p><em>durumlar</em>, bir durum listesi içeren bir JSON nesnesidir.</p> <p>Belirli semboller dışında, <code>d</code>, durumda belirtilmeyen tüm sembolleri ifade eder.
<code>n</code> 0x0a, <code>s</code> boşluk, <code>q</code> ters alıntı, <code>Q</code> çift tırnak, <code>r</code> &gt;= 128, <code>a</code> AZ ve az ve <code>1</code> 1-9 anlamına gelir.</p> <p>Bu durumların adı anahtarlardır ve olası değerler değer nesnesinde listelenir. Daha sonra her grup için geçiş yapılacak yeni bir durum vardır. Sonra jetonun adı var. İlk duruma geri dönmemiz gerekirse, üçüncü parametre, mevcut sembolün nasıl ele alınacağını gösteren hizmet simgesidir.</p> <p>Örneğin, ana durumumuz ve gelen karakterler <code>/</code>, <code>&quot;/&quot;: [&quot;solidus&quot;, &quot;&quot;, &quot;push next&quot;]</code>,</p> <ul><li><strong>push</strong> - gayrı bir yığında olduğunu hatırlama komutunu verir;</li> <li><strong>next</strong> - sonraki karaktere gider ve aynı zamanda durumu <strong>solidus</strong> olarak değiştiririz. Bundan sonra, bir sonraki karakteri alır ve <strong>solidus</strong>'un durumunu kontrol edin.</li></ul> <p>Sonraki karakterde <code>/</code> veya <code>/*</code> varsa, o zaman <code>//</code> veya <code>/*</code> ile başladıkları için yorum <strong>yorum</strong> durumuna gideriz. Açıkçası, her yorumun daha sonra farklı bir durumu vardır, çünkü farklı bir sembolle biterler.</p> <p>Sonraki karakter <code>/</code> ve <code>*</code> değilse, yığındaki her şeyi <strong>lexOper</strong> tipi etiketler olarak kaydeder, yığını temizler ve ana duruma döneriz.</p> <p>Aşağıdaki modül, durum ağacını sayısal bir diziye dönüştürür ve onu <em>lex_table.go</em> dosyasına yazar.</p> <p>İlk döngüde:</p> <p>Geçerli sembollerden oluşan bir alfabe oluşturuyoruz.</p> <div class="language- extra-class"><pre class="language-text"><code>for ind, ch := range alphabet {
   i := byte(ind)
</code></pre></div><p>Ek olarak, <strong>state2int</strong> içinde her duruma kendi dizi tanımlayıcısını sağlarız.</p> <div class="language- extra-class"><pre class="language-text"><code>   state2int := map[string]uint{`main`: 0}
   if err := json.Unmarshal([]byte(states), &amp;data); err == nil {
   for key := range data {
   if key != `main` {
   state2int[key] = uint(len(state2int))
</code></pre></div><p>Tüm durumları ve bir durumdaki her bir kümeyi ve bir kümedeki her bir sembolü geçtiğimizde, üç baytlık bir sayı yazarız [new state identifier (0 = main)] + [token type ( 0-no token)] + [token]. .
<em>table</em> dizisinin iki boyutluluğu, durumlara ve aynı sırada düzenlenmiş <em>alfabe</em> dizisinden 34 giriş sembolüne bölünmüş olmasıdır.
<em>Tablonun</em> sıfır satırında <em>main</em> durumundayız. İlk karakteri alın, <em>alphabet</em> dizisinde dizinini bulun ve verilen dizine sahip sütundan değeri alın. Alınan değerden başlayarak jetonu düşük bayt olarak alıyoruz. Ayrıştırma tamamlandıysa, ikinci bayt, alınan belirtecin türünü gösterir. Üçüncü baytta, bir sonraki yeni durumun indeksini alırız.
Bunların tümü <em>lex.go</em> içindeki <strong>lexParser</strong> işlevinde daha ayrıntılı olarak açıklanmıştır.
Bazı yeni karakterler eklemek istiyorsanız, bunları <em>alphabet</em> dizisine eklemeniz ve <em>AlphaSize</em> sabitinin miktarını artırmanız gerekir. Yeni bir sembol kombinasyonu eklemek isterseniz, mevcut seçeneklere benzer şekilde durum içinde açıklanmalıdır. Yukarıdaki işlemden sonra <em>lex_table.go</em> dosyasını güncellemek için <em>lextable.go</em> dosyasını çalıştırın.</p> <h3 id="lex-go"><a href="#lex-go" class="header-anchor">#</a> <span id="lex-go">lex.go</span></h3> <p><strong>lexParser</strong> işlevi doğrudan sözcüksel analiz oluşturur ve gelen dizelere dayalı olarak bir dizi alınan etiket döndürür. Tokenların yapısını analiz edelim.</p> <div class="language- extra-class"><pre class="language-text"><code>type Lexem struct {
   Type  uint32 // Type of the lexem
   Value interface{} // Value of lexem
   Line  uint32 // Line of the lexem
   Column uint32 // Position inside the line
}
</code></pre></div><ul><li><strong>Type</strong> - belirteç türü. Aşağıdaki değerlerden birine sahiptir: <code>lexSys, lexOper, lexNumber, lexIdent, lexString, lexComment, lexKeyword, lexType, lexExtend</code>;</li> <li><strong>Value</strong> – token değeri. Değerin türü, belirteç türüne bağlıdır, daha ayrıntılı olarak analiz edelim:
<ul><li><strong>lexSys</strong> - parantez, virgül vb. içerir. Bu durumda, <code>Type = ch &lt;&lt; 8 | lexSys</code>, lütfen <code>isLPar ... isRBrack</code> sabitine bakın ve değeri uint32 bittir;</li> <li><strong>lexOper</strong> - değer, uint32 biçimindeki eşdeğer bir karakter dizisini temsil eder. 'isNot ... isOr' sabitlerine bakın;</li> <li><strong>lexNumber</strong> - sayılar int64 veya float64 olarak saklanır. Sayının ondalık noktası varsa, float64'tür;</li> <li><strong>lexIdent</strong> - tanımlayıcılar dize olarak saklanır;</li> <li><strong>lexNewLine</strong> - yeni satır karakteri. Ayrıca satır ve token konumunu hesaplamak için kullanılır;</li> <li><strong>lexString</strong> - satırlar dize olarak saklanır;</li> <li><strong>lexComment</strong> - yorumlar dize olarak saklanır;</li> <li><strong>lexKeyword</strong> - anahtar sözcükler için yalnızca ilgili dizinler saklanır, bkz. <code>keyContract ... keyTail' sabiti. Bu durumda</code>Tür = AnahtarKimliği &lt;&lt; 8 | lexKeyword`. Ayrıca, &quot;true, false, nil&quot; anahtar sözcüklerinin hemen lexNumber tipi belirteçlere dönüştürüleceği ve ilgili &quot;bool&quot; ve &quot;interface {}&quot; türlerinin kullanılacağına dikkat edilmelidir;</li> <li><strong>lexType</strong> – bu değer, karşılık gelen &quot;reflect.Type&quot; tipi değerini içerir;</li> <li><strong>lexExtend</strong> – <code>$</code> ile başlayan tanımlayıcılar. Bu değişkenler ve işlevler dışarıdan iletilir ve bu nedenle özel türdeki belirteçlere atanır. Bu değer, adı başında $ olmadan bir dize olarak içerir.</li></ul></li> <li><strong>Line</strong> - tokenın bulunduğu satır;</li> <li><strong>Column</strong> - tokenın satır içi konumu.</li></ul> <p><strong>lexParser</strong> işlevini ayrıntılı olarak analiz edelim. <strong>todo</strong> işlevi, mevcut duruma ve gelen sembole göre alfabedeki sembol dizinini arar ve dönüşüm tablosundan yeni bir durum, belirteç tanımlayıcısı (varsa) ve diğer belirteçleri alır. Ayrıştırmanın kendisi, her bir sonraki karakter için sırayla <strong>todo</strong> işlevini çağırmayı ve yeni bir duruma geçmeyi içerir. Etiket alındıktan sonra çıktı kriterlerinde karşılık gelen jetonu oluşturup ayrıştırma işlemine devam ediyoruz. Ayrıştırma işlemi sırasında belirteç sembollerini ayrı bir yığın veya dizide biriktirmediğimize dikkat edilmelidir, çünkü yalnızca belirtecin başlangıcının ofsetini kaydederiz. Belirteci aldıktan sonra, bir sonraki belirtecin ofsetini mevcut ayrıştırma konumuna taşırız.</p> <p>Geriye kalan tek şey, ayrıştırmada kullanılan sözcüksel durum belirteçlerini kontrol etmektir:</p> <ul><li><strong>lexfPush</strong> - bu simge, yeni bir simgede simgeler biriktirmeye başladığımız anlamına gelir;</li> <li><strong>lexfNext</strong> - karakter, geçerli simgeye eklenmelidir;</li> <li><strong>lexfPop</strong> - tokenın alınması tamamlandı. Genellikle, bu bayrakla, ayrıştırılmış belirtecin tanımlayıcı türüne sahibiz;</li> <li><strong>lexfSkip</strong> - bu token, karakterleri ayrıştırmanın dışında tutmak için kullanılır. Örneğin, dizgedeki kontrol eğik çizgileri \n \r &quot; şeklindedir. Sözcüksel analiz aşamasında bunlar otomatik olarak değiştirilecektir..</li></ul> <h2 id="needle-dili"><a href="#needle-dili" class="header-anchor">#</a> Needle dili</h2> <h3 id="lexemes"><a href="#lexemes" class="header-anchor">#</a> Lexemes</h3> <p>Bir programın kaynak kodu UTF-8 kodlamasında olmalıdır.</p> <p>Aşağıdaki sözcük türleri işlenir:</p> <ul><li><strong>Keywords</strong> - <code>action, break, conditions, continue, contract, data, else, error, false, func, If, info, nil, return, settings, true, var, warning, while</code>;</li> <li><strong>Number</strong> - sadece ondalık sayılar kabul edilir. İki temel tür vardır: <strong>int</strong> ve <strong>float</strong>. Sayının ondalık noktası varsa, kayan nokta ** kayan nokta** olur. <strong>int</strong> türü, golang'da <strong>int64</strong> ile eşdeğerdir, <strong>float</strong> türü ise golang'da <strong>float64</strong> ile eşdeğerdir.</li> <li><strong>String</strong> - dize <code>(&quot;a dize&quot;)</code> çift tırnak içine alınabilir veya <code>(\`a dize\`)</code> ters tırnak içine alınabilir. Her iki dize türü de yeni satır karakterleri içerebilir. Çift tırnak içindeki dizeler, çift tırnak, yeni satır karakterleri ve eğik çizgilerle kaçan satır başları içerebilir. Örneğin, <code>&quot;Bu bir \&quot;ilk dizedir\&quot;.\r\nBu ikinci bir dizedir.&quot;</code>.</li> <li><strong>Comment</strong> - iki tür yorum vardır. Tek satırlı yorumlar iki eğik çizgi (//) kullanır. Örneğin, // Bu tek satırlık bir yorumdur. Çok satırlı yorumlar eğik çizgi ve yıldız sembollerini kullanır ve birden çok satıra yayılabilir. Örneğin, <code>/* Bu çok satırlı bir yorumdur */</code>.</li> <li><strong>Identifier</strong> - a-z ve A-Z harfleri, UTF-8 sembolleri, sayılar ve alt çizgilerden oluşan değişkenlerin ve fonksiyonların adları. Ad bir harf, alt çizgi, <code>@</code> veya <code>$</code> ile başlayabilir. <code>$</code> ile başlayan ad, <strong>data</strong> tanımlanan değişkenin adıdır. <code>$</code> ile başlayan ad, <strong>conditons</strong> ve <strong>actions</strong> kapsamındaki global değişkenleri tanımlamak için de kullanılabilir. Ekosistem sözleşmeleri <code>@</code> sembolü kullanılarak çağrılabilir. Örneğin: <code>@1NewTable(...)</code>.</li></ul> <h3 id="turler"><a href="#turler" class="header-anchor">#</a> Türler</h3> <p>Karşılık gelen golang türleri, Needle türlerinin yanında belirtilir.</p> <ul><li><strong>bool</strong> - bool, <strong>false</strong> by default;</li> <li><strong>bytes</strong> - []byte{}, an empty byte array by default;</li> <li><strong>int</strong> - int64, <strong>0</strong> by default;</li> <li><strong>address</strong> - uint64, <strong>0</strong> by default;</li> <li><strong>array</strong> - []interface{}, an empty array by default;</li> <li><strong>map</strong> - map[string]interface{}, an empty object array by default;</li> <li><strong>money</strong> - decimal. Decimal, <strong>0</strong> by default;</li> <li><strong>float</strong> - float64, <strong>0</strong> by default;</li> <li><strong>string</strong> - string,;</li> <li><strong>file</strong> - map[string]interface{}, varsayılan olarak boş bir nesne dizisi.</li></ul> <p>Bu tür değişkenler <code>var</code> anahtar kelimesi ile tanımlanır. Örneğin, <code>var var1, var2 int</code>. Bu şekilde tanımlandığında, türe göre varsayılan bir değere sahip bir değişken atanacaktır.</p> <p>Tüm değişken değerleri interface{} türündedir ve ardından gerekli golang türlerine atanır. Bu nedenle, örneğin dizi ve harita türleri, []interface{} ve map[array]interface{} golang türleridir. Her iki dizi türü de herhangi bir türden öğe içerebilir.</p> <h3 id="expressions"><a href="#expressions" class="header-anchor">#</a> Expressions</h3> <p>Bir ifade aritmetik işlemleri, mantıksal işlemleri ve işlev çağrılarını içerebilir. Tüm ifadeler, operatörlerin önceliğine göre soldan sağa doğru değerlendirilir. Eşit önceliğe sahipse, operatörler soldan sağa doğru değerlendirilir.</p> <p>Yüksekten düşüğe operasyonların önceliği:</p> <ul><li><strong>Function call and parentheses</strong> - bir fonksiyon çağrıldığında, geçirilen parametreler soldan sağa doğru hesaplanır;</li> <li><strong>Unary Operation</strong> - logical negation <code>!</code> and arithmetic sign change <code>-</code>;</li> <li><strong>Multiplication and Division</strong> - arithmetic multiplication <code>*</code> and division <code>/</code>;</li> <li><strong>Addition and Subtraction</strong> - arithmetic addition <code>+</code> and subtraction <code>-</code>;</li> <li><strong>Logical comparison</strong> - <code>&gt;=&gt;&gt; &gt;=</code>;</li> <li><strong>Logical equality and inequality</strong> - <code>== !=</code>;</li> <li><strong>Logical AND</strong> - <code>&amp;&amp;</code>;</li> <li><strong>Logical OR</strong> - <code>||</code>.</li></ul> <p>Mantıksal AND ve OR değerlendirilirken, her durumda ifadenin her iki tarafı da değerlendirilir.</p> <p>Derleme sırasında iğnenin tip kontrolü yoktur. İşlenenleri değerlendirirken, türü daha karmaşık bir türe dönüştürmeye çalışılır. Karmaşıklık sırasının türü şu şekilde olabilir: <code>string, int, float, money</code>. Tür dönüşümlerinin yalnızca bir kısmı uygulanır. Dize türü, ekleme işlemlerini destekler ve sonuç, dize birleştirme olacaktır. Örneğin, <code>string + string = string, money-int = para, int * float = float</code>.</p> <p>İşlevler için, yürütme sırasında <code>string</code> ve <code>int</code> türlerinde tip kontrolü yapılır.</p> <p><strong>array</strong> ve <strong>map</strong> türleri dizine göre ele alınabilir. <strong>array</strong> türü için <strong>int</strong> değeri dizin olarak belirtilmelidir. <strong>harita</strong> türü için bir değişken veya <strong>dize</strong> değeri belirtilmelidir. Dizini mevcut maksimum dizinden büyük olan bir <strong>array</strong> öğesine bir değer atarsanız, diziye boş bir öğe eklenir. Bu öğelerin başlangıç ​​değeri <strong>nil</strong>'dir. Örneğin: .. code:</p> <div class="language- extra-class"><pre class="language-text"><code>var my array
my[5] = 0
var mymap map
mymap[&quot;index&quot;] = my[3]
</code></pre></div><p>Koşullu mantıksal değerlerin ifadelerinde (<code>if, while, &amp;&amp;, ||, !</code> gibi), tür otomatik olarak mantıksal bir değere dönüştürülür. Tür varsayılan değer değilse, doğrudur.</p> <div class="language- extra-class"><pre class="language-text"><code>var mymap map
var val string
if mymap &amp;&amp; val {
...
}
</code></pre></div><h3 id="scope"><a href="#scope" class="header-anchor">#</a> Scope</h3> <p>Parantezler, yerel kapsam değişkenlerini içerebilen bir blok belirtir. Varsayılan olarak, bir değişkenin kapsamı kendi bloklarına ve tüm iç içe bloklara uzanır. Bir blokta, mevcut bir değişkenin adını kullanarak yeni bir değişken tanımlayabilirsiniz. Ancak bu durumda aynı ada sahip harici değişkenler kullanılamaz hale gelir.</p> <div class="language- extra-class"><pre class="language-text"><code>var a int
a = 3
{
   var a int
   a = 4
   Println(a) // 4
}
Println(a) // 3
</code></pre></div><h3 id="kontrat-yurutme"><a href="#kontrat-yurutme" class="header-anchor">#</a> Kontrat Yürütme</h3> <p>Bir kontratı çağırırken, <strong>data</strong> içinde tanımlanan parametreler ona iletilmelidir. Bir kontratı yürütmeden önce sanal makine bu parametreleri alır ve bunları karşılık gelen değişkenlere ($Param) atar. Ardından, önceden tanımlanmış <strong>conditons</strong> işlevi ve <strong>action</strong> işlevi çağrılır.</p> <p>Kontratın yürütülmesi sırasında meydana gelen hatalar iki türe ayrılabilir: form hataları ve ortam hataları. Form hataları özel komutlar kullanılarak oluşturulur: <code>error, Warning, info</code> ve yerleşik işlev <code>err</code> döndürdüğünde <em>nil</em> değerine eşit değildir.</p> <p>Needle dili istisnaları işlemez. Herhangi bir hata, sözleşmelerin yürütülmesini sonlandıracaktır. Bir sözleşme yürütüldüğünde değişken değerleri kaydetmek için ayrı bir yığın ve yapı oluşturulduğundan, bir sözleşme yürütüldüğünde golang garbage collection tarafından bu verileri otomatik olarak siler.</p> <h3 id="backus-naur-formu-bnf"><a href="#backus-naur-formu-bnf" class="header-anchor">#</a> <span id="backus-naur-form-bnf">Backus–Naur Formu (BNF)</span></h3> <p>Bilgisayar biliminde BNF, bağlamdan bağımsız sözdizimi için bir gösterim tekniğidir ve genellikle hesaplamada kullanılan dilin sözdizimini tanımlamak için kullanılır.</p> <ul><li>&lt;decimal digit&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
</code></pre></div><ul><li>&lt;decimal number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; {&lt;decimal digit&gt;}
</code></pre></div><ul><li>&lt;symbol code&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'''&lt;any symbol&gt;'''
</code></pre></div><ul><li>&lt;real number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number'.'[&lt;decimal number&gt;]
</code></pre></div><ul><li>&lt;integer number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>['-'] &lt;decimal number&gt; | &lt;symbol code&gt;
</code></pre></div><ul><li>&lt;number&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'&lt;integer number&gt; | &lt;real number&gt;'
</code></pre></div><ul><li>&lt;letter&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'A' |'B' | ... |'Z' |'a' |'b' | ... |'z' | 0x80 | 0x81 | ... | 0xFF
</code></pre></div><ul><li>&lt;space&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x20'
</code></pre></div><ul><li>&lt;tabulation&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x09'
</code></pre></div><ul><li>&lt;newline&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'0x0D 0x0A'
</code></pre></div><ul><li>&lt;special symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'!' |'&quot;' |'$' |''' |'(' |')' |'\*' |'+' |',' |'-' |'.' |'/ '|'&lt;' |'=' |'&gt;' |'[' |'\\' |']' |'_' |'|' |'}' | '{' | &lt;tabulation&gt; | &lt;space&gt; | &lt;newline&gt;
</code></pre></div><ul><li>&lt;symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;decimal digit&gt; | &lt;letter&gt; | &lt;special symbol&gt;
</code></pre></div><ul><li>&lt;name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(&lt;letter&gt; |'_') {&lt;letter&gt; |'_' | &lt;decimal digit&gt;}
</code></pre></div><ul><li>&lt;function name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;variable name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;type name&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;name&gt;
</code></pre></div><ul><li>&lt;string symbol&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;tabulation&gt; | &lt;space&gt; |'!' |'#' | ... |'[' |']' | ...
</code></pre></div><ul><li>&lt;string element&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{&lt;string symbol&gt; |'\&quot;' |'\n' |'\r'}
</code></pre></div><ul><li>&lt;string&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'&quot;' {&lt;string element&gt;}'&quot;' |'\`' {&lt;string element&gt;}'\`'
</code></pre></div><ul><li>&lt;assignment operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'='
</code></pre></div><ul><li>&lt;unary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'-'
</code></pre></div><ul><li>&lt;binary operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'==' |'!=' |'&gt;' |'&lt;' |'&lt;=' |'&gt;=' |'&amp;&amp;' |'||' |'\*' |'/' |'+ '|'-'
</code></pre></div><ul><li>&lt;operator&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;assignment operator&gt; | &lt;unary operator&gt; | &lt;binary operator&gt;
</code></pre></div><ul><li>&lt;parameters&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;expression&gt; {','&lt;expression&gt;}
</code></pre></div><ul><li>&lt;contract call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract name&gt;'(' [&lt;parameters&gt;]')'
</code></pre></div><ul><li>&lt;function call&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;contract call&gt; [{'.' &lt;name&gt;'(' [&lt;parameters&gt;]')'}]
</code></pre></div><ul><li>&lt;block contents&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;block command&gt; {&lt;newline&gt;&lt;block command&gt;}
</code></pre></div><ul><li>&lt;block&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'{'&lt;block contents&gt;'}'
</code></pre></div><ul><li>&lt;block command&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(&lt;block&gt; | &lt;expression&gt; | &lt;variables definition&gt; | &lt;if&gt; | &lt;while&gt; | break | continue | return)
</code></pre></div><ul><li>&lt;if&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'if &lt;expression&gt;&lt;block&gt; [else &lt;block&gt;]'
</code></pre></div><ul><li>&lt;while&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'while &lt;expression&gt;&lt;block&gt;'
</code></pre></div><ul><li>&lt;contract&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'contract &lt;name&gt; '{'[&lt;data section&gt;] {&lt;function&gt;} [&lt;conditions&gt;] [&lt;action&gt;]'}''
</code></pre></div><ul><li>&lt;data section&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'data '{' {&lt;data parameter&gt;&lt;newline&gt;} '}''
</code></pre></div><ul><li>&lt;data parameter&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; &lt;type name&gt;'&quot;'{&lt;tag&gt;}'&quot;'
</code></pre></div><ul><li>&lt;tag&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'optional | image | file | hidden | text | polymap | map | address | signature:&lt;name&gt;'
</code></pre></div><ul><li>&lt;conditions&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'conditions &lt;block&gt;'
</code></pre></div><ul><li>&lt;action&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'action &lt;block&gt;'
</code></pre></div><ul><li>&lt;function&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'func &lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'[{&lt;tail&gt;}] [&lt;type name&gt;] &lt;block&gt;'
</code></pre></div><ul><li>&lt;variable description&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;variable name&gt; {',' &lt;variable name&gt;} &lt;type name&gt;
</code></pre></div><ul><li>&lt;tail&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'.'&lt;function name&gt;'('[&lt;variable description&gt;{','&lt;variable description&gt;}]')'
</code></pre></div><ul><li>&lt;variables definition&gt;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>'var &lt;variable description&gt;{','&lt;variable description&gt;}'
</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/IBAX-io/documentation/edit/master/docs/tr-TR/topics/vm.md" target="_blank" rel="noopener noreferrer">Bu sayfayı GitHub da düzenleyin</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">son Güncelleme:</span> <span class="time">01.04.2022 23:20:24</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tr-TR/topics/templates2.html" class="prev">
        Şablon Dili
      </a></span> <span class="next"><a href="/tr-TR/topics/daemons.html">
        Arka plan programı
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1fdb8a3a.js" defer></script><script src="/assets/js/2.14a295a1.js" defer></script><script src="/assets/js/128.fde84ac4.js" defer></script>
  </body>
</html>
